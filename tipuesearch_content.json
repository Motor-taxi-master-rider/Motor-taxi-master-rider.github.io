{"pages":[{"url":"pages/about.html","text":"Why I started this blog My background My family My hobbies","tags":"pages","title":"About"},{"url":"translate-pythonku-jie-shao-shi-yong-luxjin-xing-zhi-neng-ke-shi-shu-ju-fa-xian.html","text":"Âéü‰ΩúËÄÖÔºö Parul Pandey Êé¢Á¥¢ÊÄßÁöÑÊï∞ÊçÆÂàÜÊûêÊòØ‰∏ÄÁßçÊÄÅÂ∫¶ÔºåÊòØ‰∏ÄÁßçÁÅµÊ¥ªÊÄßÔºåÊòØ‰∏ÄÁßçÂéªÂØªÊâæÈÇ£‰∫õÊàë‰ª¨ËÆ§‰∏∫‰∏çÂ≠òÂú®ÁöÑ‰∫ãÁâ©‰ª•ÂèäÊàë‰ª¨Áõ∏‰ø°Â≠òÂú®ÁöÑ‰∫ãÁâ©ÁöÑÊÑèÊÑø„ÄÇ‚Äî John W Tukey Âú®Êï∞ÊçÆÁßëÂ≠¶È¢ÜÂüüÔºåÊï∞ÊçÆÂèØËßÜÂåñÁöÑÈáçË¶ÅÊÄßÂíåÂøÖË¶ÅÊÄßÂπ∂Ê≤°ÊúâÂæóÂà∞Ë∂≥Â§üÁöÑÈáçËßÜ„ÄÇ ‰∏ÄÂº†ÂõæÁâáËÉúËøáÂçÉË®Ä‰∏áËØ≠ÔºåËøôÂè•ËØùÈÄÇÁî®‰∫é‰ªª‰Ωï‰∏éÊï∞ÊçÆÁõ∏ÂÖ≥ÁöÑÈ°πÁõÆÁöÑÁîüÂëΩÂë®Êúü‰∏≠„ÄÇ ÁÑ∂ËÄåÂæàÂ§öÊó∂ÂÄôÔºåÂÆûÁé∞Ëøô‰∫õÂèØËßÜÂåñÁöÑÂ∑•ÂÖ∑ÂæÄÂæÄ‰∏çÂ§üÊô∫ËÉΩ„ÄÇ ‰∫ãÂÆû‰∏äËøôÊÑèÂë≥ÁùÄÔºåÂ∞ΩÁÆ°Êàë‰ª¨ÊúâÊï∞‰ª•ÁôæËÆ°ÁöÑÂèØËßÜÂåñÂ∫ìÔºå‰ΩÜÂÖ∂‰∏≠ÁªùÂ§ßÂ§öÊï∞ÈÉΩË¶ÅÊ±ÇÁî®Êà∑Ëá™Â∑±ÁºñÂÜôÂ§ßÈáè‰ª£Á†ÅÊâçËÉΩÁªòÂà∂ÁÆÄÂçïÂõæÂΩ¢„ÄÇ Ëøô‰ºöËÆ©‰∫∫‰ª¨ÁöÑÂÖ≥Ê≥®ÁÑ¶ÁÇπËΩ¨ÁßªÂà∞ÂèØËßÜÂåñÁöÑÂÜÖÈÉ®Êú∫Âà∂‰∏äÔºåËÄå‰∏çÊòØÁúüÊ≠£ÈáçË¶ÅÁöÑ‰∏úË•øÔºöÊï∞ÊçÆÂÜÖÁöÑÂÖ≥Á≥ª‰∏ä„ÄÇ Â¶ÇÊûúËØ¥Áé∞Âú®Êúâ‰∏ÄÁßçÂ∑•ÂÖ∑ÂèØ‰ª•ÈÄöËøáÂêëÁî®Êà∑Êé®ËçêÁõ∏ÂÖ≥ÁöÑÂèØËßÜÂåñÂª∫ËÆÆÊù•ÁÆÄÂåñÊï∞ÊçÆÊé¢Á¥¢ÁöÑËøáÁ®ãÂë¢Ôºü‰∏Ä‰∏™Âêç‰∏∫Luxüí°ÁöÑÊñ∞Â∫ìÊ®™Á©∫Âá∫‰∏ñÔºåÂÆÉÊ≠£ÊòØ‰∏∫Ëß£ÂÜ≥Ëøô‰∫õÈóÆÈ¢òËÄåÂºÄÂèëÁöÑ„ÄÇ ÂΩìÂâçÈ´òÊïàÊï∞ÊçÆÊé¢Á¥¢Èù¢‰∏¥ÁöÑÊåëÊàò Â¶Ç‰ªäÔºåÊï∞ÊçÆÂàÜÊûêÂ∏àÂèØ‰ª•‰ΩøÁî®Â§öÁßçÂ∑•ÂÖ∑ËøõË°åÊï∞ÊçÆÊé¢Á¥¢„ÄÇ Â∞ΩÁÆ°‰∫§‰∫íÂºèJupyterÁ¨îËÆ∞Êú¨ÂÖÅËÆ∏‰∫∫‰ª¨Âú®ÂÖ∂‰πã‰∏äËø≠‰ª£ÂÆûÈ™åÔºåËøòÊúâ‰∏Ä‰∫õÂº∫Â§ßÁöÑBIÂ∑•ÂÖ∑ÔºåÂ¶ÇPower BIÂíåTableauÔºåËÆ©ÊôÆÈÄö‰∫∫‰ªÖÈúÄÂçïÂáªÈÅçÂèØÂÆûÁé∞È´òÁ∫ßÂà´ÁöÑÊï∞ÊçÆÊé¢Á¥¢ÔºåÂèØÂç≥‰æøÊúâËøô‰∫õÂäüËÉΩÂº∫Â§ßÁöÑÂ∑•ÂÖ∑ÈóÆ‰∏ñÔºåÈòªÁ¢çÊï∞ÊçÆÊé¢Á¥¢ÊµÅÁ®ãÁöÑÊåëÊàò‰ªçÁÑ∂Â≠òÂú®„ÄÇ ÂΩìÊàë‰ª¨‰ªéÂú®ËÑë‰∏≠ÂàÜÊûêÈóÆÈ¢òËΩ¨ÂêëÂú®ÂÆûÈôÖÊé¢ÂØªÂèØË°åÁöÑËß£ÂÜ≥ÊñπÊ°àÊó∂Â∞§ÂÖ∂Â¶ÇÊ≠§„ÄÇ ËÆ©Êàë‰ª¨Áúã‰∏Ä‰∏ãÊï∞ÊçÆÂàÜÊûêÂ∏àÂΩìÂâçÈù¢‰∏¥ÁöÑ‰∏â‰∏™‰∏ªË¶ÅÁöÑ„ÄÅÂèØËØÜÂà´ÁöÑÈöúÁ¢çÔºö ‰ª£Á†Å‰∏é‰∫§‰∫íÂ∑•ÂÖ∑‰πãÈó¥ÁöÑËÑ±ËäÇ ËôΩÁÑ∂ÈúÄË¶ÅÁºñÁ®ãÁöÑÂ∑•ÂÖ∑Êèê‰æõ‰∫ÜÁÅµÊ¥ªÊÄßÔºå‰ΩÜÊòØÁºñÁ®ãÁªèÈ™åËæÉÂ∞ëÁöÑ‰∫∫ÈÄöÂ∏∏‰∏ç‰ºö‰ΩøÁî®ÂÆÉ‰ª¨„ÄÇ Âè¶‰∏ÄÊñπÈù¢ÔºåËôΩÁÑ∂ÁÇπÂáª‰∫§‰∫íÁöÑÂ∑•ÂÖ∑Êòì‰∫é‰ΩøÁî®Ôºå‰ΩÜÂÆÉ‰ª¨ÁöÑÁÅµÊ¥ªÊÄßÊúâÈôê‰∏îÈöæ‰ª•Ëá™ÂÆö‰πâ„ÄÇ ÁªòÂõæÈúÄË¶ÅÂ§ßÈáè‰ª£Á†ÅÂíåÂÖàÂÜ≥Êù°‰ª∂ ÂÖ∂Ê¨°ÔºåÈúÄË¶ÅÂàõÂª∫ÂèØËßÜÂåñÊó∂ÔºåÊàë‰ª¨È¶ñÂÖàÈúÄË¶ÅËÄÉËôëÁöÑÊòØÊâÄÊúâÁöÑËßÑÊ†ºÂ∫îÂΩìÂ¶Ç‰ΩïË¢´ÂèØËßÜÂåñ„ÄÇ ‰πãÂêéÊàë‰ª¨ÈúÄË¶ÅÂ∞ÜËøô‰∫õËßÑÊ†ºÁöÑÁªÜËäÇ‰ø°ÊÅØËΩ¨Êç¢‰∏∫‰ª£Á†Å„ÄÇ ‰∏äÂõæÊòæÁ§∫‰∫ÜÂú®‰∏§‰∏™ÊµÅË°åÁöÑpythonÂ∫ìÔºàMatplotlibÂíåPlotlyÔºâ‰∏≠Ôºå‰ªÖ‰ªÖÊòØ‰∏∫‰∫ÜËæìÂá∫‰∏Ä‰∏™Êü±Áä∂ÂõæÂ∞±ÈúÄË¶ÅÂ§ßÈáèÁöÑÁöÑ‰ª£Á†Å„ÄÇ ËøôÁßçÊÉÖÂÜµÂêåÊ†∑‰ºöÂΩ±ÂìçÊï∞ÊçÆÊµèËßàÔºåÂ∞§ÂÖ∂ÊòØÂΩìÁî®Êà∑ÂØπÊâÄË¶ÅÊü•ÊâæÁöÑÂÜÖÂÆπÂè™ÊúâÊ®°Á≥äÁöÑÊ¶ÇÂøµÊó∂„ÄÇ ËØïÈîôÊòØ‰∏Ä‰∏™Âç≥ÁπÅÁêêÂèà‰ª§‰∫∫Á™íÊÅØÁöÑËøáÁ®ã ÊØèÊ¨°EDAÔºàExploratory data analysisÔºâÈÉΩÈúÄË¶Å‰∏çÊñ≠ÁöÑÂèçÂ§çËØïÈ™å„ÄÇ Áî®Êà∑ÂøÖÈ°ªÂÖàËØïÈ™åÂ§öÁßçÂèØËßÜÂåñÊïàÊûúÔºåÁÑ∂ÂêéÊâçËÉΩÁ°ÆÂÆöÊúÄÁªàÁöÑÂèØËßÜÂåñÊïàÊûú„ÄÇ ÂàÜÊûê‰∫∫ÂëòÊúâÂèØËÉΩ‰ºöÂõ†Ê≠§ÈîôËøáÊï∞ÊçÆÈõÜ‰∏≠ÁöÑÂÖ≥ÈîÆ‰ø°ÊÅØ„ÄÇ Âè¶‰∏Ä‰∏™Â∏∏ËßÅÁöÑÈóÆÈ¢òÊòØÂàÜÊûê‰∫∫ÂëòÂèØËÉΩÂπ∂‰∏çÁü•ÈÅìÂ∫îËØ•ÂØπÊï∞ÊçÆÊâßË°åÂì™‰∫õÊìç‰ΩúÊâçËÉΩËé∑ÂæóÊâÄÈúÄÁöÑÂÖ≥ÈîÆ‰ø°ÊÅØÔºåÂπ∂‰∏î‰ªñ‰ª¨ÂæÄÂæÄ‰ºöËø∑Â§±ÊñπÂêëÔºåÊó†Ê≥ïÂàÜÊûêÂá∫ÊúâÊïàÁöÑÁªìËÆ∫„ÄÇ Âú®‰∫∫‰ª¨ÂàÜÊûêÂíåÊÄùËÄÉ‰ªñ‰ª¨ÁöÑÊï∞ÊçÆ‰∏éÂÆûÈôÖÂ¶Ç‰ΩïÂ§ÑÁêÜÊï∞ÊçÆÊâçËÉΩËé∑ÂæóÊúâ‰ª∑ÂÄºÁöÑ‰ø°ÊÅØ‰πãÈó¥Â≠òÂú®ÊòéÊòæÁöÑÈ∏øÊ≤ü„ÄÇ LuxÊ≠£ÊòØËß£ÂÜ≥Ëøô‰∫õÂèØËÉΩÁöÑÈ∏øÊ≤ü‰∏ÄÊ≠•„ÄÇ Lux LuxÊòØ‰∏Ä‰∏™Êó®Âú®ÈÄöËøáËá™Âä®ÊâßË°åÊüê‰∫õÊñπÈù¢ÁöÑÊï∞ÊçÆÊé¢Êü•ÔºåÊù•Â∏ÆÂä©Áî®Êà∑Êé¢Á¥¢ÂíåÂèëÁé∞‰ªñ‰ª¨Êï∞ÊçÆ‰∏≠ÁöÑÊúâÊÑè‰πâÁöÑËßÅËß£ÁöÑPythonÂ∫ì„ÄÇÂÆÉËØïÂõæÂº•Âêà‰ª£Á†Å‰∏é‰∫§‰∫íÂºèÁïåÈù¢‰πãÈó¥ÁöÑÈ∏øÊ≤ü„ÄÇLux‰ª•‰∏ÄÁßçË°®ÊÑèËØ≠Ë®ÄÁöÑÊñπÂºèÔºå‰ΩøÂæóÂú®Áî®Êà∑‰ªÖ‰ªÖÁªôÂá∫‰∏Ä‰∏™Ê®°Á≥äÁöÑÂàÜÊûêÊÑèÂõæÁöÑÊÉÖÂÜµ‰∏ãÔºåÂÆÉ‰πüËÉΩËá™Âä®Êé®Êñ≠Âá∫ÂÖ∂‰∏≠Êú™ÊåáÂÆöÁöÑÁªÜËäÇÂπ∂ÂÜ≥ÂÆöÈÄÇÂΩìÁöÑÂèØËßÜÂåñÊò†Â∞Ñ„ÄÇ LuxÁöÑÁõÆÊ†áÊòØÔºåÂç≥‰ΩøÊï∞ÊçÆÁßëÂ≠¶ÂÆ∂ÂØπËøòÊ≤°ÊÉ≥Â•Ω‰ªñ‰ª¨ÈúÄË¶Å‰ªÄ‰πàÊúâÁî®ÁöÑ‰ø°ÊÅØÔºå‰ªñ‰ª¨‰πüÂèØ‰ª•Êõ¥ËΩªÊùæÂú∞Êé¢Á¥¢Êï∞ÊçÆ„ÄÇ LuxÂ∞Ü‰∫§‰∫íÂºèÂèØËßÜÂåñÁöÑÂäüËÉΩÁõ¥Êé•ÈõÜÊàêËøõ‰∫ÜJupyter notebooksÔºå‰ª•Âº•Âêà‰ª£Á†Å‰∏é‰∫§‰∫íÂºèÁïåÈù¢‰πãÈó¥ÁöÑÈ∏øÊ≤ü„ÄÇ Lux‰ΩøÁî®Âº∫Â§ßÁöÑË°®ÊÑèËØ≠Ë®ÄÔºåÂÖÅËÆ∏Áî®Êà∑ÊåáÂÆöÂÖ∂Âú®ÂàÜÊûê‰∏≠ÊÑüÂÖ¥Ë∂£ÁöÑÈÉ®ÂàÜ‰ª•Èôç‰ΩéÁºñÁ®ãÊàêÊú¨„ÄÇ Lux‰ºöËá™Âä®ÂêëÁî®Êà∑Êèê‰æõÊï∞ÊçÆÁöÑÂèØËßÜÂåñÂª∫ËÆÆ„ÄÇ Áé∞Âú®ÔºåÊàë‰ª¨ÂØπLuxÊÄéÊ†∑ÂèÇ‰∏éÁî®Êà∑Êé¢Á¥¢Êï∞ÊçÆÊó∂ÈÅáÂà∞ÁöÑÂ∏∏ËßÅÈóÆÈ¢òÊúâ‰∫Ü‰∏Ä‰∏™Ê∏ÖÊô∞ÁöÑËÆ§ËØÜ„ÄÇ Áé∞Âú®ËÆ©Êàë‰ª¨Êù•Áúã‰∏Ä‰∏™‰ΩøÁî®LuxÂ∫ìÁöÑÁ§∫‰æã„ÄÇ ‰∏∫‰∫ÜÊèê‰æõ‰∏Ä‰∏™Âø´ÈÄüÊºîÁ§∫ÔºåÊàëÂ∞Ü‰ΩøÁî®‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊ°à‰æã„ÄÇ Âú®‰Ω†ÂØπËøô‰∏™‰æãÂ≠êÊúâ‰∫ÜÊ∏ÖÊô∞Âú∞ËÆ§ËØÜ‰πãÂêéÔºå‰æøÂèØ‰ª•Â∞ÜÂÖ∂‰∏é‰Ω†ÈÄâÊã©ÁöÑÊï∞ÊçÆÈõÜÁªìÂêà‰ΩøÁî®„ÄÇ Ê°à‰æãÁ†îÁ©∂ÔºöÂàÜÊûêPalmer PenguinsüêßÊï∞ÊçÆÈõÜ Palmer‰ºÅÈπÖÊï∞ÊçÆÈõÜÁõÆÂâçÂ∑≤Êàê‰∏∫Êï∞ÊçÆÁßëÂ≠¶ÁïåÁöÑÊñ∞ÂÆ†ÔºåÂÆÉÊòØË¢´ËøáÂ∫¶‰ΩøÁî®ÁöÑIrisÊï∞ÊçÆÈõÜÁöÑÁõ¥Êé•Êõø‰ª£ÂìÅ„ÄÇ ËØ•Êï∞ÊçÆÈõÜÂåÖÂê´344‰∏™‰ºÅÈπÖÁöÑÊï∞ÊçÆ„ÄÇ Êï∞ÊçÆÁî± Kristen Gorman ÂçöÂ£´ÂíåÂçóÊûÅÊ¥≤ Palmer Station Á´ôÊî∂ÈõÜÂπ∂Êèê‰æõ„ÄÇ È¶ñÂÖàËÆ©Êàë‰ª¨ÂÆâË£ÖÂπ∂ÂØºÂÖ•LuxÂ∫ì„ÄÇ‰Ω†ÂèØ‰ª•ÈÄöËøá Binder Âú®Jupyter notbook‰∏≠ÁªßÁª≠ÈòÖËØªÊú¨ÊïôÁ®ã„ÄÇ ÂÆâË£Ö pip install lux-api # ÊøÄÊ¥ªJupyter notebookÊâ©Â±ï jupyter nbextension install --py luxwidget jupyter nbextension enable --py luxwidget # ÊøÄÊ¥ªJupyter labÊãìÂ±ï jupyter labextension install @jupyter-widgets/jupyterlab-manager jupyter labextension install luxwidget ÊúâÂÖ≥Â¶Ç‰ΩïÂ∞ÜLux‰∏éSQLÂºïÊìéÈÖçÂêà‰ΩøÁî®ÁöÑÊõ¥Â§öËØ¶ÁªÜ‰ø°ÊÅØÔºåËØ∑ÈòÖËØª ÊñáÊ°£ ÔºåËØ•ÊñáÊ°£ÈùûÂ∏∏ËØ¶ÂÆûÂπ∂‰∏îÂåÖÂê´ËÆ∏Â§öÂä®ÊâãÁ§∫‰æã„ÄÇ ÂØºÂÖ•ÂøÖË¶ÅÁöÑÂ∫ì‰∏éÊï∞ÊçÆÈõÜ ‰∏ÄÊó¶LuxÂ∫ìÂÆâË£ÖÂÆåÊØïÔºåÊàë‰ª¨Â∞±ÂèØ‰ª•ÂØºÂÖ•Êï∞ÊçÆÈõÜ‰∫Ü„ÄÇ import pandas as pd import lux df = pd . read_csv ( 'penguins_size.csv' ) df . head () LuxÁöÑ‰∏Ä‰∏™‰∏çÈîôÁöÑÁÇπÊòØÂÆÉÂèØ‰ª•‰∏éPandasÊ°ÜÊû∂‰∏ÄËµ∑‰ΩøÁî®Âπ∂‰∏îÊó†ÈúÄÂØπÁé∞ÊúâÁöÑÊ†ºÂºèËøõË°å‰ªª‰Ωï‰øÆÊîπ„ÄÇ ÊØîÂ¶ÇËØ¥ÔºåÂ¶ÇÊûú‰Ω†ÊÉ≥Âà†Èô§‰ªª‰ΩïË°åÊàñÂàóÔºåLuxÁöÑÂª∫ËÆÆ‰ºöÊ†πÊçÆÊõ¥Êñ∞ÁöÑdataframeÁîüÊàê„ÄÇPandas‰∏≠ÁöÑÂà†Èô§ÂàóÔºåÂØºÂÖ•CSVÁ≠â‰ºòÁßÄÁöÑÂäüËÉΩ‰πüË¢´‰øùÁïô„ÄÇ Êé•‰∏ãÊù•ËÆ©Êàë‰ª¨Êù•Ê¶ÇËßà‰∏Ä‰∏ãÊï∞ÊçÆÈõÜ„ÄÇ df . info () Êï∞ÊçÆÈõÜÈáåÊúâ‰∫õÁ©∫ÂÄºÔºåËÆ©Êàë‰ª¨ÊëÜËÑ±ÂÆÉ‰ª¨„ÄÇ df = df . dropna () Áé∞Âú®Êàë‰ª¨ÁöÑÊï∞ÊçÆÂ∑≤Ë¢´Âä†ËΩΩËá≥ÂÜÖÂ≠òÔºåÊé•‰∏ãÊù•ÁúãLuxÂ¶Ç‰Ωï‰∏∫Êàë‰ª¨ÁÆÄÂåñEDAÁöÑÊµÅÁ®ã„ÄÇ ‰ΩøÁî®LuxËøõË°åEDAÔºöÊîØÊåÅÂèØËßÜÂåñdataframeÂ∑•‰ΩúÊµÅ df ÂΩìdataframeË¢´ÊâìÂç∞Âá∫Êù•Êó∂ÔºåÊàë‰ª¨ÁúãÂà∞ÁöÑÊòØPandasÈªòËÆ§ÁöÑË°®Ê†ºÊ†ºÂºè„ÄÇÊàë‰ª¨ÂèØ‰ª•ÁÇπÂáªÂàáÊç¢Êù•Ëé∑ÂæóÁî±LuxËá™Âä®ÁîüÊàêÁöÑ‰∏ÄÁªÑÂèØËßÜÂåñÂª∫ËÆÆ„ÄÇ Lux‰∏≠ÁöÑÂª∫ËÆÆÁªÑÁªáÂú®‰∏â‰∏™‰∏çÂêåÁöÑÈÄâÈ°πÂç°‰∏≠ÔºåÂàÜÂà´Ë°®Á§∫Áî®Êà∑ÂèØ‰ª•Âú®ÂÖ∂Êé¢Á¥¢ËøáÁ®ã‰∏≠ÂèØ‰ª•ÈááÂèñÁöÑ‰∏ã‰∏ÄÊ≠•„ÄÇ Áõ∏ÂÖ≥ÊÄßÈÄâÈ°πÂç°Ôºö ÊòæÁ§∫ÂÆöÈáèÂ±ûÊÄß‰πãÈó¥ÁöÑÊàêÂØπÂÖ≥Á≥ªÔºåÊåâÊúÄÈ´òÁõ∏ÂÖ≥Ëá≥ÊúÄ‰ΩéÁõ∏ÂÖ≥ÊéíÂ∫è„ÄÇ Êàë‰ª¨ÂèØ‰ª•ÁúãÂà∞‰ºÅÈπÖÈ≥çÁöÑÈïøÂ∫¶‰∏é‰ΩìÈáçÂëàÊ≠£Áõ∏ÂÖ≥„ÄÇ ‰ºÅÈπÖÂò¥Â≥∞(culmen)ÁöÑÈïøÂ∫¶ÂíåÊ∑±Â∫¶‰πüÊòæÁé∞Âá∫‰∏Ä‰∫õÊúâË∂£ÁöÑÊ®°ÂºèÔºåÂÆÉ‰ª¨ÊòæÁÑ∂Â≠òÂú®ÁùÄÊüêÁßçË¥üÁõ∏ÂÖ≥„ÄÇ ÂÖ∑‰ΩìÊù•ËØ¥Ôºå\"Âò¥Â≥∞\"Â∞±ÊòØÈ∏üÁ±ªÁöÑ‰∏äËÑä„ÄÇ ÂàÜÂ∏ÉÈÄâÈ°πÂç°: ÊòæÁ§∫‰∏ÄÁªÑÂçïÂèòÈáèÂàÜÂ∏ÉÔºåÊåâÂÅèÂ∫¶‰ªéÂ§ßÂà∞Â∞èÊéíÂ∫è„ÄÇ Âá∫Áé∞ÁéáÈÄâÈ°πÂç°: ÊòæÁ§∫‰∫Ü‰∏ÄÁªÑ‰ªéÊï∞ÊçÆÈõÜ‰∏≠ÁîüÊàêÁöÑÊù°ÂΩ¢Âõæ„ÄÇ Ê≠§ÈÄâÈ°πÂç°Â±ïÁ§∫‰∫Ü‰∏âÁßç‰∏çÂêåÁöÑ‰ºÅÈπÖ - Adelie Ôºå Chinstrap Âíå Gentoo „ÄÇ ËøòÊúâ‰∏â‰∏™‰∏çÂêåÁöÑÂ≤õÂ±øÔºåÂàÜÂà´ÊòØ Torgersen Ôºå Biscoe Âíå Dream „ÄÇ Ë¢´ÂåÖÂê´Âú®Êï∞ÊçÆÈõÜ‰∏≠ÈõÑÊÄßÂíåÈõåÊÄßÂá∫Áé∞Áéá‰πüËÉΩÂú®ÂõæË°®‰∏≠Ê∏ÖÊ•öÁöÑÁúãÂà∞„ÄÇ Âü∫‰∫éÊÑèÂõæÁöÑÂª∫ËÆÆ Èô§‰∫ÜÂü∫Êú¨ÁöÑÊé®ËçêÂäüËÉΩÂ§ñÔºåÊàë‰ª¨ËøòÂèØ‰ª•ÊåáÂÆöÂàÜÊûêÊÑèÂõæ„ÄÇ ÊØîÊñπËØ¥ÔºåÊàë‰ª¨ÊÉ≥ÊâæÂá∫Âò¥Â≥∞ÈïøÂ∫¶Èöè‰ºÅÈπÖÁâ©ÁßçÂèòÂåñÁöÑÊ®°Âºè„ÄÇ Êàë‰ª¨ÂèØ‰ª•Âú®Ê≠§Â§ÑÂ∞ÜÊÑèÂõæËÆæÁΩÆ‰∏∫ ['culmen_length_mm'Ôºå'species'] „ÄÇÂÜçÊ¨°ÊâìÂç∞Êï∞ÊçÆÊ°ÜÊó∂ÔºåÂ∞±ÂèØ‰ª•ÁúãÂà∞Êé®ËçêÂ∑≤ÁªèÁºñÁ®ã‰∏éÊàë‰ª¨ÊåáÂÆöÁöÑÊÑèÂõæÁõ∏ÂÖ≥ÁöÑÂÜÖÂÆπ„ÄÇ df . intent = [ 'culmen_length_mm' , 'species' ] df Âú®‰∏ãÂõæÁöÑÂ∑¶‰æßÔºåÊàë‰ª¨ÁúãÂà∞ÁöÑÊòØ‰∏éÊâÄÈÄâÂ±ûÊÄßÁõ∏ÂØπÂ∫îÁöÑ Current Visualization „ÄÇ Âè≥‰æßÂàôÊòØ Enhace ÔºöÂç≥Âú®ÂêëÂΩìÂâçÈÄâÊã©‰∏≠Ê∑ªÂä†Â±ûÊÄßÊó∂‰ºöÂèëÁîü‰ªÄ‰πà„ÄÇ ËøòÊúâ Filter ÈÄâÈ°πÂç°ÔºåÂÖÅËÆ∏Âú®Âõ∫ÂÆöÈÄâÊã©ÁöÑÂèòÈáèÁöÑÂêåÊó∂Ê∑ªÂä†ËøáÊª§Âô®„ÄÇ Â¶ÇÊûúÊàë‰ª¨‰ªîÁªÜËßÇÂØüÁâ©ÁßçÂÜÖÈÉ®ÁöÑÁõ∏ÂÖ≥ÊÄßÔºåÂàô‰ºöÂèëÁé∞Âò¥Â≥∞ÈïøÂ∫¶ÂíåÊ∑±Â∫¶ÊòØÊ≠£Áõ∏ÂÖ≥ÁöÑÔºå‰∏é‰πãÂâçÁöÑÊé®ÊµãÊ≠£Áõ∏Âèç„ÄÇ ËøôÊòØ‰∏Ä‰∏™ÂÖ∏ÂûãÁöÑ ËæõÊôÆÊ£ÆÊÇñËÆ∫ ÁöÑ‰æãÂ≠ê„ÄÇ ÊúÄÂêéÔºåÈÄöËøáÊØîËæÉÈ≥çÁä∂ËÇ¢ÁöÑÈïøÂ∫¶‰∏éÂò¥Â≥∞ÁöÑÈïøÂ∫¶ÔºåÊàë‰ª¨ÂèØ‰ª•ÂæàÊ∏ÖÊ•öÂú∞Â∞ÜËøô‰∏â‰∏™Áâ©ÁßçÂàÜÂºÄ„ÄÇ Áî®Êèí‰ª∂ÂØºÂá∫ÂèØËßÜÂåñÁªìÊûú Lux‰ΩøÂæóÂØºÂá∫ÂíåÂàÜ‰∫´ÁîüÊàêÁöÑÂèØËßÜÂåñÁªìÊûúÂèòÂæóÂºÇÂ∏∏ÁÆÄÂçï„ÄÇËøô‰∫õÂèØËßÜÂåñÂõæË°®ÂèØ‰ª•‰ª•Â¶Ç‰∏ãÊñπÂºèË¢´ÂØºÂá∫ÊàêÈùôÊÄÅÁöÑHTMLÊñá‰ª∂Ôºö df.save_as_html('file.html') Êàë‰ª¨ËøòÂèØ‰ª•ÈÄöËøá recommendation Â±ûÊÄßËé∑Âæó‰∏∫dataframeÁîüÊàêÁöÑ Âª∫ËÆÆÈõÜ „ÄÇ ÂÆÉÁöÑËøîÂõûÊ†ºÂºè‰∏∫Â≠óÂÖ∏ÔºåÁî±Êé®ËçêÁ±ªÂà´ÁöÑÂêçÁß∞ÊûÑÊàêÂ≠óÂÖ∏ÁöÑÂÖ≥ÈîÆÂ≠ó„ÄÇ df . recommendation ‰ª•‰ª£Á†ÅÁöÑÊ†ºÂºèÂØºÂá∫ÂèØËßÜÂåñÁªìÊûú Êàë‰ª¨‰∏ç‰ªÖÂèØ‰ª•Â∞ÜÂèØËßÜÂåñÂØºÂá∫‰∏∫HTMLÔºåËøòÂèØ‰ª•Â∞ÜÂÖ∂ÂØºÂá∫‰∏∫‰ª£Á†Å„ÄÇ ‰∏ãÈù¢ÁöÑGIFÊòæÁ§∫‰∫ÜÂ¶Ç‰ΩïÂú® ÂèëÁîüÁéáÈÄâÈ°πÂç° ‰∏≠Êü•ÁúãÁ¨¨‰∏Ä‰∏™Êù°ÂΩ¢ÂõæÁöÑ‰ª£Á†Å„ÄÇ ‰πãÂêéÊàë‰ª¨ÂèØ‰ª•Â∞ÜÂèØËßÜÂåñÁªìÊûúÂØºÂá∫Êàê‰ª£Á†ÅËá≥ Altair ‰∏≠Ôºå‰ª•‰æøËøõË°åËøõ‰∏ÄÊ≠•ÁºñËæëÊàñ‰Ωú‰∏∫ Vega-Lite ËßÑËåÉ„ÄÇ ‰Ω†ÂèØ‰ª•Âú® Ëøô‰∏™ÊñáÊ°£‰∏≠ ÊâæÂà∞Êõ¥Â§öËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ Áõ∏ÂÖ≥ËµÑÊ∫êÂíåÁªÉ‰π† ‰∏äÈù¢ÁöÑ‰∏ÄÁ≥ªÂàóÊºîÁ§∫Âè™ÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂÖ•Èó®ÊïôÁ®ã„ÄÇ LuxÁöÑGithub ‰∏≠ÂåÖÂê´ËÆ∏Â§öËµÑÊ∫ê‰ª•ÂèäÊúâÂÖ≥Â¶Ç‰Ωï‰ΩøÁî®LuxÁöÑ‰∫§‰∫íÂºèBinder notebook„ÄÇ ÈÇ£ÈáåÂ∞Ü‰ºöÊòØ‰∏Ä‰∏™ÂæàÂ•ΩÁöÑËµ∑ÁÇπ„ÄÇ Ê≠§Â§ñÔºåËøôÈáåËøòÊúâËøòÊúâËØ¶ÁªÜÁöÑ ÊñáÊ°£ „ÄÇ lux-binder ÁªìËÆ∫‰∏é‰∏ã‰∏ÄÊ≠• Âú®‰ª•‰∏äÊñáÁ´†‰∏≠ÔºåÊàë‰ª¨ÁúãÂà∞‰∫ÜÂ¶Ç‰ΩïÈÄöËøá‰ΩøÁî®LuxÊù•ÂÆåÂÖ®ËΩ¨Êç¢Jupyter notebook‰∏≠ÁöÑÊï∞ÊçÆÂàÜÊûêÂ∑•‰ΩúÊµÅ„ÄÇ LuxÊèê‰æõ‰∫ÜÊõ¥Â§öÁöÑËßÜËßâ‰∏∞ÂØåÊÄß‰ª•ÈºìÂä±ÊúâÊÑè‰πâÁöÑÊï∞ÊçÆÊé¢Á¥¢„ÄÇ Lux‰ªçÂú® ÁßØÊûÅÂºÄÂèë ‰∏≠ÔºåÂÖ∂Áª¥Êä§ËÄÖÂ∏åÊúõ‰ªéÊ≠£Âú®‰ΩøÁî®ÊàñÂèØËÉΩÂØπ‰ΩøÁî®LuxÊÑüÂÖ¥Ë∂£ÁöÑÁî®Êà∑ÂæóÂà∞Êõ¥Â§öÂèçÈ¶à„ÄÇ Â¶ÇÊûúÊÇ®ÊúâÂÖ¥Ë∂£‰∏∫Ëøô‰∏™Â∫ìÂÅöË¥°ÁåÆÔºåËØ∑Â°´ÂÜô‰ª•‰∏ãË°®Ê†º„ÄÇ ËøôÂ∞ÜÂ∏ÆÂä©Âõ¢Èòü‰∫ÜËß£‰ªñ‰ª¨Â¶Ç‰Ωï‰∏∫ÊÇ®ÊîπËøõÂ∑•ÂÖ∑„ÄÇ","tags":"posts","title":"[Translate] PythonÂ∫ì‰ªãÁªçÔºö‰ΩøÁî®LuxËøõË°åÊô∫ËÉΩÂèØËßÜÊï∞ÊçÆÂèëÁé∞"},{"url":"translate-pythonzhong-ru-he-jiang-duo-ge-can-shu-chuan-ru-maphan-shu.html","text":"Êù•Ê∫êÔºö How to Pass Multiple Arguments to a map Function in Python ‰ΩúËÄÖÔºöMiguel Brito Âú®ËøôÁØáÊñáÁ´†‰∏≠ÔºåÊàë‰ºöÁªôÂ§ßÂÆ∂Â±ïÁ§∫ÂΩìÊúâÂ§ö‰∏™ÂèÇÊï∞ÈúÄË¶Å‰º†ÂÖ• map ÂáΩÊï∞Êó∂ÊàëÁöÑÂ§ÑÁêÜÊñπÂºè„ÄÇËøô‰∏™ÊñπÊ≥ï‰∏ç‰ªÖÈÄÇÁî®‰∫éÊôÆÈÄöÁöÑ map ÊñπÊ≥ïÔºåÂêåÊó∂‰Ω†‰πüËÉΩ‰ª•ÂêåÊ†∑ÁöÑÊäÄÂ∑ßÁªô concurrent.futures.Executor.map Âíå multiprocessing.Pool ‰º†ÂÖ•Â§çÊï∞‰∏™ÂèÇÊï∞„ÄÇ ÈóÆÈ¢ò ÂÅáËÆæÊàë‰ª¨Êúâ‰∏Ä‰∏™Âè´ÂÅö sum_four ÁöÑÂáΩÊï∞ÔºåÂÆÉÊé•Êî∂Âõõ‰∏™ÂèÇÊï∞Âπ∂‰∏îËøîÂõûÂÆÉ‰ª¨ÁöÑÊÄªÂíå„ÄÇ >>> def sum_four ( a , b , c , d ): return a + b + c + d ÂêåÊó∂Êàë‰ª¨ÂÅáËÆæ‰Ω†Âú®Ëß£ÂÜ≥‰∏Ä‰∏™ÈùûÂ∏∏ÁâπÊÆäÁöÑÈóÆÈ¢òÔºåËØ•ÈóÆÈ¢òË¶ÅÊ±ÇÂõ∫ÂÆö‰ª•‰∏äÂáΩÊï∞Ââç‰∏â‰∏™ÂèÇÊï∞„ÄÇÂú®‰ªÖÊîπÂèòÊúÄÂêé‰∏Ä‰∏™ÂèÇÊï∞ÁöÑÊù°‰ª∂‰∏ãÔºåËØïÂõæÊØîËæÉËØ•ÂáΩÊï∞ÁöÑ‰∏çÂêåË°å‰∏∫„ÄÇ >>> a , b , c = 1 , 2 , 3 >>> sum_four ( a = a , b = b , c = c , d = 1 ) 7 >>> sum_four ( a = a , b = b , c = c , d = 2 ) 8 >>> sum_four ( a = a , b = b , c = c , d = 3 ) 9 >>> sum_four ( a = a , b = b , c = c , d = 4 ) 10 Â¶ÇÊûúËØ¥Âõ†‰∏∫‰Ω†ÂñúÊ¨¢ÂáΩÊï∞ÂºèÁºñÁ®ãÊàñËÄÖ‰Ω†Êù•Ëá™‰∏ÄÈó®ÈºìÂä±Ëøô‰∏ÄËåÉÂºèÁöÑËØ≠Ë®ÄÔºà*ËØ¥ÁöÑÂ∞±ÊòØ‰Ω†ÔºåHaskellÔºâÔºåÊâÄ‰ª•‰Ω†Ê∏¥Êúõ‰ΩøÁî® map ÂáΩÊï∞Êù•Ëß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢òÔºå‰∏çÈöæÊÉ≥Âà∞ÔºåÊó¢ÁÑ∂Âè™Êúâ d Âú®ÂèòÂåñÔºåÊàë‰ª¨Â∞±ÂèØ‰ª•Â∞ÜË¶ÅÊµãËØïÁöÑÊâÄÊúâÂèØËÉΩÂÄºÂ≠òÂú®ÂàóË°®Èáå ds = [1, 2, 3, 4] „ÄÇÈÇ£‰πàÈóÆÈ¢òÊù•‰∫ÜÔºåÁªôÂÆö‰∏Ä‰∏™ÂáΩÊï∞Âíå‰∏Ä‰∏™ÂåÖÂê´Â§ö‰∏™ÂÖÉÁ¥†ÁöÑÂàóË°®ÔºåÂ¶ÇÊûú‰Ω†ÊÉ≥Â∞ÜËøô‰∏™ÂàóË°®‰º†ÂÖ•‰∏Ä‰∏™Âè™Êé•ÂèóÂçï‰∏™ÂÖÉÁ¥†ÁöÑ map ÊñπÊ≥ïÔºåËØ•ÊÄé‰πàÂÅöÔºü ÊñπÊ°à 1 Á¨¨‰∏Ä‰∏™ÊñπÊ°àÊòØÁî® itertools.starmap Êù•Êõø‰ª£ map ÂáΩÊï∞„ÄÇËØ•ÂáΩÊï∞Êé•Âèó‰∏Ä‰∏™ÂáΩÊï∞Âèä‰∏Ä‰∏™Áî±ÂÖÉÁªÑÁªÑÊàêÁöÑÂèØËø≠‰ª£( iterable )ÂØπË±°‰Ωú‰∏∫ÂèÇÊï∞„ÄÇ startmap ‰ºöÈÅçÂéÜÂêÑ‰∏™ÂÖÉÁªÑ t Ôºå‰πãÂêéÂ∞ÜÂÆÉ‰ª¨Ëß£ÂåÖÂπ∂‰Ωú‰∏∫ÂèÇÊï∞ÊâßË°åÂáΩÊï∞ÔºåÁ±ª‰ºº‰∫é for t in tuples: function(*t) „ÄÇ ‰∏∫‰∫ÜËÆ©‰∫ãÊÉÖÊõ¥Âä†Áõ¥ËßÇÔºåÁªô‰ª•‰∏ãÁ§∫‰æã‰æõÊÄùËÄÉÔºö >>> import itertools >>> ds = [ 1 , 2 , 3 , 4 ] >>> items = (( a , b , c , d ) for d in ds ) >>> list ( items ) [( 1 , 2 , 3 , 1 ), ( 1 , 2 , 3 , 2 ), ( 1 , 2 , 3 , 3 ), ( 1 , 2 , 3 , 4 )] >>> list ( itertools . starmap ( sum_four , items )) [ 7 , 8 , 9 , 10 ] Â¶Ç‰Ω†ÊâÄËßÅÔºåÂàóË°®‰∏≠ÊúâÂæàÂ§öÈáçÂ§çÁöÑÂÖÉÁ¥†ÔºåÂΩìÂàóË°®ËøáÈïøÊó∂ÂÆÉ‰ª¨‰ºö‰∏çÂèØÈÅøÂÖçÂú∞Ê∂àËÄóËÆ∏Â§öÂÜÖÂ≠ò„ÄÇ‰Ωú‰∏∫ÊîπËøõÔºåÊàëÂ∞Ü items ËÆæËÆ°ÊàêÁîüÊàêÂô®ÔºåËøôÊ†∑Êàë‰ª¨Â∞±ÂèØ‰ª•Âè™Â∞ÜÊ≠£Âú®Â§ÑÁêÜÁöÑÂÖÉÁ¥†Âä†ËΩΩËá≥ÂÜÖÂ≠ò‰∏≠‰∫Ü„ÄÇ ÊñπÊ°à 2 Á¨¨‰∫å‰∏™ÊñπÊ°àÊòØÈÄöËøá ÊüØÈáåÂåñ Âπ∂ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÂÅèÂáΩÊï∞„ÄÇÊ†πÊçÆÊñáÊ°£Ôºå partial() ‰ºö\"ÂÜªÁªì\"ÂáΩÊï∞ÁöÑÊüêÈÉ®ÂàÜÂèÇÊï∞Âíå(Êàñ)ÂÖ≥ÈîÆÂ≠óÔºå‰ªéËÄåÁîüÊàê‰∏Ä‰∏™ÂÖ∑ÊúâÁÆÄÂåñÁ≠æÂêçÁöÑÊñ∞ÂáΩÊï∞„ÄÇ In [ 29 ]: import functools In [ 30 ]: partial_sum_four = functools . partial ( sum_four , a , b , c ) In [ 31 ]: partial_sum_four ( 3 ) Out [ 31 ]: 9 In [ 32 ]: list ( map ( partial_sum_four , ds )) Out [ 32 ]: [ 7 , 8 , 9 , 10 ] ÊñπÊ°à 3 Á¨¨‰∏â‰∏™ÈÄâÊã©ÊòØ‰ΩøÁî® itertools.repeat „ÄÇËøô‰∏™ÂáΩÊï∞‰∫ßÁîü‰∏Ä‰∏™Ëø≠‰ª£Âô®ÔºåËØ•Ëø≠‰ª£Âô®‰ºö‰∏ÄÈÅçÂèà‰∏ÄÈÅçÁöÑËøîÂõûÂØπË±°„ÄÇÂ¶ÇÊûú‰Ω†Ê≤°ÊúâÊåáÂÆö_times_Ëøô‰∏ÄÂèÇÊï∞ÁöÑËØùÔºåÂ∞±ÂèØ‰ª•Êó†ÈôêÊ¨°Âú∞ÈÅçÂéÜÂÆÉ„ÄÇÊé•‰∏ãÊù•ËÆ©Êàë‰ª¨‰ªîÁªÜÁúã‰∏Ä‰∏ã map() ÁöÑ Á≠æÂêç ÔºåÂÆÉÊé•Êî∂‰∏Ä‰∏™ÂáΩÊï∞ÂèäÂ§ö‰∏™ÂèØËø≠‰ª£ÂØπË±°‰Ωú‰∏∫ÂèÇÊï∞Ôºå map(function, iterable, ...) „ÄÇ Ê†πÊçÆÊñáÊ°£‰∏≠ÁöÑÊèèËø∞Ôºå Â¶ÇÊûú‰º†ÈÄí‰∫ÜÈ¢ùÂ§ñÁöÑ iterable ‰Ωú‰∏∫ÂèÇÊï∞ÔºåÂàô function ÂøÖÈ°ªËÉΩÂ§üÊé•Êî∂ÂíåÊâÄÊúâÂèØËø≠‰ª£ÂØπË±°Êï∞ÈáèÁõ∏ÂêåÁöÑÂèÇÊï∞ÔºåÂπ∂‰∏îÊâÄÊúâÂèØËø≠‰ª£ÂØπË±°ÁöÑÂÖÉÁ¥†Â∞Ü‰ºöÂêåÊó∂Âπ∂Ë°åÂú∞‰ΩúÁî®‰∫éËØ•ÂáΩÊï∞„ÄÇÂΩìÊúâÂ§çÊï∞‰∏™ÂèØËø≠‰ª£ÂØπË±°Êó∂ÔºåÊúÄÁü≠ÁöÑÂèØËø≠‰ª£ÂØπË±°ËÄóÂ∞ΩÂàôÊï¥‰∏™Ëø≠‰ª£Â∞±Â∞ÜÁªìÊùü„ÄÇ Bingo ÔºÅÊàë‰ª¨ÂèØ‰ª•‰ΩøÁî® itertools.repeat() Êù•Âà∂‰Ωú a Ôºå b Ôºå c ÁöÑÊó†Á©∑Ëø≠‰ª£Âô®„ÄÇÂΩìÊúÄÁü≠ÁöÑÂèØËø≠‰ª£ÂØπË±°‚Äî‚Äî ds Ë¢´ËÄóÂ∞ΩÊó∂Ôºå map Â∞±‰ºöÂÅúÊ≠¢„ÄÇ >>> import itertools >>> list ( map ( sum_four , itertools . repeat ( a ), itertools . repeat ( b ), itertools . repeat ( c ), ds )) [ 7 , 8 , 9 , 10 ] Êç¢‰∏ÄÁßçÊñπÂºèÁöÑËØùÔºå‰ΩøÁî® repeat() Â§ßËá¥Á≠âÊïà‰∫éÔºö >>> list ( map ( sum_four , [ 1 , 1 , 1 , 1 ], [ 2 , 2 , 2 , 2 ], [ 3 , 3 , 3 , 3 ], ds )) [ 7 , 8 , 9 , 10 ] ‰Ω†Êó†ÈúÄÂ§™ÊãÖÂøÉÂÜÖÂ≠òÁöÑÈóÆÈ¢òÔºåÂõ†‰∏∫ÂÖÉÁ¥†Âè™ÊúâÂú®Ë¢´‰ΩøÁî®Êó∂Êâç‰ºöË¢´ÁîüÊàê„ÄÇ‰∫ãÂÆû‰∏äÔºå repeat ËøîÂõû‰∏Ä‰∏™ repeatobject ÂØπË±°ÔºåËÄå‰∏çÊòØ list [ ref ]„ÄÇ ÈóÆÈ¢ò 2ÔºöÂ¶Ç‰Ωï‰º†ÈÄíÂ§ö‰∏™ÂèÇÊï∞ multiprocessing.Pool.map ? ËøôÊòØ‰∏Ä‰∏™ÂíåÊôÆÈÄö map() ÂáΩÊï∞‰∏éÂ§ö‰∏™ÂèÇÊï∞‰∫§‰∫íÁ±ª‰ººÁöÑÈóÆÈ¢ò„ÄÇÂÅáËÆæÊàë‰ª¨ÁöÑË¶ÅÊèêÈ´ò‰ª£Á†ÅÊÄßËÉΩÔºåÂ∞Ü sum_four Âπ∂Ë°åËøêË°åÂú®‰∏çÂêåËøõÁ®ã‰∏≠„ÄÇÂ•ΩÊ∂àÊÅØÊòØ‰∏äËø∞ÁöÑÂ§ßÈÉ®ÂàÜÊñπÊ°àÂèØ‰ª•ÈÄÇÁî®‰∫éËøô‰∏ÄÊñ∞ÁöÑÂú∫ÊôØ‰∏≠ÔºåÈô§‰∫Ü‰∏Ä‰∏™‰æãÂ§ñÔºö Pool.map Âè™Êé•Êî∂Âçï‰∏ÄÁöÑÂèØËø≠‰ª£ÂØπË±°„ÄÇËøôÊÑèÂë≥ÁùÄÊàë‰ª¨‰∏çÂÜçËÉΩÂ§ü‰ΩøÁî® repeat() ÔºåÈÇ£ËÆ©Êàë‰ª¨ÁúãÁúãÂÖ∂‰ªñÊñπÊ°àÂêß„ÄÇ ‰ΩøÁî® starmap >>> from multiprocessing import Pool >>> import itertools >>> def sum_four ( a , b , c , d ): return a + b + c + d >>> a , b , c = 1 , 2 , 3 >>> ds = [ 1 , 2 , 3 , 4 ] >>> items = [( a , b , c , d ) for d in ds ] >>> items [( 1 , 2 , 3 , 1 ), ( 1 , 2 , 3 , 2 ), ( 1 , 2 , 3 , 3 ), ( 1 , 2 , 3 , 4 )] >>> with Pool ( processes = 4 ) as pool : res = pool . starmap ( sum_four , items ) >>> res [ 7 , 8 , 9 , 10 ] ‰ΩøÁî® partial() >>> import functools >>> partial_sum_four = functools . partial ( sum_four , a , b , c ) >>> with Pool ( processes = 4 ) as pool : res = pool . map ( partial_sum_four , ds ) >>> res [ 7 , 8 , 9 , 10 ] ÈóÆÈ¢ò 3Ôºö Â¶Ç‰Ωï‰º†ÈÄíÂ§ö‰∏™ÂèÇÊï∞Áªô concurrent.futures.Executor.map ? concurrent.futures Ê®°ÂùóÊèê‰æõ‰∫Ü‰∏ÄÁßçÂè´ Executor ÁöÑÈ´òÂ±ÇÊé•Âè£Êù•ËøêË°åÂºÇÊ≠•ËøêË°åÂèØË∞ÉÁî®ÂØπË±°( callable )„ÄÇ ÂΩìÂâçÁöÑÁâàÊú¨‰∏≠Ëøô‰∏ÄÊé•Âè£Â≠òÂú®‰∏§Áßç‰∏çÂêåÁöÑÂÆûÁé∞ÊñπÂºèÔºåÂç≥ ThreadPoolExecutor Âíå ProcessPoolExecutor „ÄÇ‰∏é multiprocessing.Pool Áõ∏ÂèçÁöÑÊòØÔºå Executor Ê≤°Êúâ startmap() ÊñπÊ≥ïÔºå‰ΩÜÊòØÂÆÉÁöÑ map() ÂÆûÁé∞ÊîØÊåÅÂ§ö‰∏™ÂèØËø≠‰ª£ÂØπË±°„ÄÇËøôÂÖÅËÆ∏Êàë‰ª¨‰ΩøÁî® repeat() ÂáΩÊï∞„ÄÇÂè¶Â§ñ‰∏Ä‰∏™Âå∫Âà´ÊòØ Executor.map ËøîÂõûÁöÑÊòØÁîüÊàêÂô®ËÄåÈùûÂàóË°®„ÄÇ ‰ΩøÁî® partial() >>> from concurrent.futures import ProcessPoolExecutor >>> import functools >>> def sum_four ( a , b , c , d ): return a + b + c + d >>> a , b , c = 1 , 2 , 3 >>> ds = [ 1 , 2 , 3 , 4 ] >>> partial_sum_four = functools . partial ( sum_four , a , b , c ) >>> with ProcessPoolExecutor ( max_workers = 4 ) as pool : res = list ( pool . map ( partial_sum_four , ds )) >>> res [ 7 , 8 , 9 , 10 ] ‰ΩøÁî® repeat() >>> from concurrent.futures import ProcessPoolExecutor >>> from itertools import repeat >>> def sum_four ( a , b , c , d ): return a + b + c + d >>> a , b , c = 1 , 2 , 3 >>> ds = [ 1 , 2 , 3 , 4 ] >>> with ProcessPoolExecutor ( max_workers = 4 ) as pool : res = list ( pool . map ( sum_four , repeat ( a ), repeat ( b ), repeat ( c ), ds )) >>> res [ 7 , 8 , 9 , 10 ] ÁªìËÆ∫ ‰ºôËÆ°‰ª¨ÔºÅËøôÂ∞±ÊòØ‰ªäÂ§©ÁöÑÂÖ®ÈÉ®ÂÜÖÂÆπ‰∫Ü„ÄÇÂ∏åÊúõ‰Ω†ËÉΩÂ≠¶Âà∞‰∏Ä‰∫õÊúâÁî®ÂíåÁâπÂà´ÁöÑ‰∏úË•ø„ÄÇ map() ÂáΩÊï∞‰ΩøÂæóPythonÊúâ‰∏™ÂáΩÊï∞ÂºèÁºñÁ®ãËØ≠Ë®ÄÁöÑÊÑüËßâ„ÄÇ map() ‰∏ç‰ªÖÊòØ‰∏Ä‰∏™ÁΩÆÂáΩÊï∞ÔºåËøòÂèØ‰ª•‰Ωú‰∏∫ multiprocessing Âíå concurrent.futures Ê®°ÂùóÁöÑÊñπÊ≥ï‰ΩøÁî®„ÄÇÂú®Êú¨Êñá‰∏≠ÔºåÊàëÂ±ïÁ§∫‰∫ÜÂ¶Ç‰ΩïÂú® map ÂáΩÊï∞ÈáåÂ§ÑÁêÜÂ§ö‰∏™ÂèÇÊï∞„ÄÇÂ¶ÇÊûú‰Ω†ÂñúÊ¨¢ËøôÁØáÊñáÁ´†ÔºåËØ∑ËÄÉËôë‰∏é‰Ω†ÁöÑÊúãÂèã‰ª¨ÂàÜ‰∫´ÔºÅ Âè¶Â§ñÔºåËØ∑ÈöèÊó∂ÂÖ≥Ê≥®ÊàëÔºö miguendes.me „ÄÇ ‰Ω†ÂèØËÉΩ‰ºöÂñúÊ¨¢ÊàëÁöÑÂÖ∂‰ªñÊñáÁ´†Ôºö How to Use datetime.timedelta in Python With Examples 73 Examples to Help You Master Python's f-strings How to Check if an Exception Is Raised (or Not) With pytest 3 Ways to Test API Client Applications in Python Everything You Need to Know About Python's Namedtuples The Best Way to Compare Two Dictionaries in Python 5 Hidden Python Features You Probably Never Heard Of","tags":"posts","title":"[Translate] Python‰∏≠Â¶Ç‰ΩïÂ∞ÜÂ§ö‰∏™ÂèÇÊï∞‰º†ÂÖ•mapÂáΩÊï∞"},{"url":"review-guess-word-and-hangman-game.html","text":"Guess max score word Ëøô‰∏™Ê∏∏ÊàèÊù•Ëá™ Pybites „ÄÇ Êï¥‰∏™Ê∏∏ÊàèÁöÑÊµÅÁ®ãÊòØËøôÊ†∑ÁöÑÔºö È¶ñÂÖàÈöèÊú∫ÁöÑÁªôÂá∫ÂçÅ‰∏™Ëã±ÊñáÂ≠óÊØçÔºåÂ¶Ç O, S, J, I, O, O, R, H, X, D , ‰πãÂêéÁé©ÂÆ∂‰ª•Ëøô‰∫õÂ≠óÊØçÊãºÂá∫ÂêàÁêÜÁöÑËã±ÊñáÂçïËØç„ÄÇ‰ª•ÁªôÂá∫Â≠óÊØç‰∏∫‰æãÔºåÂèØ‰ª•ÁªÑÊàê DOOR Ôºå‰ΩÜÊó†Ê≥ï‰ΩøÁî®Ë∂ÖËøáÁªôÂá∫Â≠óÊØçÊï∞ÈáèÁöÑÂçïËØçÊù•ÁªÑËØç„ÄÇ‰πãÂêé‰ºöÊ†πÊçÆÂ≠óÊØçÁöÑÁ®ÄÊúâÂ∫¶ÁªôÁé©ÂÆ∂ÊâÄÁªÑÂçïËØçÊù•ÊâìÂàÜÔºåÂ¶Ç E „ÄÅ A Á≠âÂ≠óÊØç‰∏∫‰∏ÄÂàÜÔºåËÄå Y , Z Á≠âÂ≠óÊØçÂàôÁÆó‰ΩúÂÖ´‰πùÂàÜ„ÄÇÁ≥ªÁªüÂêåÊó∂ËÆ°ÁÆóÂá∫Ëøô‰∫õÂ≠óÊØçÂÆûÈôÖËÉΩÁªÑÊàêÁöÑÊúÄÈ´òÂàÜÁöÑÂçïËØçÔºåÂπ∂ËÆ°ÁÆóÁé©ÂÆ∂ÁöÑÊâìÂàÜÊØî‰æã„ÄÇÂ¶ÇÊûúÊàë‰ª¨ÁåúÊµãÁöÑÂÄº‰∏∫ DOOR ÔºåÂàôÊàë‰ª¨Ëé∑ÂæóÁöÑÂ≠óÊØçÂàÜ‰∏∫‰∫îÂàÜÔºåËÄåÁªôÂá∫ÁöÑÂ≠óÊØçËÉΩÁªÑÊàêÁöÑÊúÄÈ´òÂàÜÂçïËØç‰∏∫ SHOJI (ÂïÜ‰ºö)ÂàÜÂÄº‰∏∫ÂçÅ‰∫îÂàÜÔºåÊàë‰ª¨ÁöÑÂæóÂàÜÊØî‰æãÂàô‰∏∫33%„ÄÇ ËØ•Ê∏∏ÊàèÁöÑÊ∫êÁ†ÅÂèØÂú®Ê≠§ Ëé∑Âæó „ÄÇ Âú®ÂØªÊâæÁªôÂá∫Â≠óÊØçËÉΩÁªÑÊàêÁöÑÊúÄÈ´òÂàÜÂçïËØçÊó∂ÔºåÊàë‰ª¨‰ΩøÁî®‰∫Ü‰ª•‰∏ã‰ª£Á†Å: def get_possible_dict_words ( draw ): \"\"\"Get all possible words from draw which are valid dictionary words. Use the _get_permutations_draw helper and DICTIONARY constant\"\"\" return set ( DICTIONARY ) & set ( map ( \"\" . join , _get_permutations_draw ( draw ))) def _get_permutations_draw ( draw ): \"\"\"Helper for get_possible_dict_words to get all permutations of draw letters. Hint: use itertools.permutations\"\"\" for length in range ( 1 , len ( draw ) + 1 ): yield from set ( itertools . permutations ( draw , length )) _get_permutations_draw ÁîüÊàêÂô®‰ΩøÁî®‰∫Ü itertools.permutations ÊñπÊ≥ïÁîüÊàê‰∫ÜÊâÄÁªôÂçïËØçÁªÑÁöÑÊâÄÊúâÈïøÂ∫¶ÁöÑÊéíÂàó„ÄÇËøôÈáå ab Âíå ba Ë¶ÅË¢´‰Ωú‰∏∫‰∏§‰∏™ÂçïËØçÂ≠òÂú®ÔºåÊâÄ‰ª•ÈúÄË¶Å‰ΩøÁî®ÊéíÂàó„ÄÇÊàëÂú®ÁîüÊàêÂô®ÈáåÂ∞±Êó©Êó©‰ΩøÁî®‰∫Ü set ÊñπÊ≥ïÂéªÈáçÔºå‰πãÂêéÂú® get_possible_dict_words ÊñπÊ≥ïÈáåÂèàÂ∞ÜÁªÑÊàêÁöÑÂ≠óÁ¨¶‰∏≤ÂÜçÊ¨°ÂéªÈáçÔºåÂÆûÈôÖ‰∏äÊòØÊ≤°ÊúâÂøÖË¶ÅÁöÑ„ÄÇÂèØ‰ª•Âè™‰øùÁïôÂêéÈù¢‰∏Ä‰∏™ÂéªÈáçÊ≠•È™§Êù•ÊèêÈ´òÊï¥‰ΩìÂáΩÊï∞ÁöÑËøêË°åÊïàÁéá„ÄÇ Âú® get_possible_dict_words ‰∏≠ÔºåÊàëËøêÁî®‰∫ÜpythonÈõÜÂêàÁöÑ‰∫§ÈõÜÊìç‰ΩúÊù•ÂèñÂæóÊâÄÊúâÂú®Â≠óÂÖ∏ÈáåÁöÑÊúâÊïàËØçÁªÑÁªÑÂêà„ÄÇÊúÄÁªàËøîÂõûÊâÄË¶ÅÊ±ÇÁöÑÂçïËØçÈõÜÂêà„ÄÇ ÈÇ£‰∫õÊúÄÈ´òÂàÜÁöÑÂçïËØç‰∏≠ÈÉΩÊòØ‰∏Ä‰∫õÂÜ∑Èó®ËØçÊ±áÔºåÊâÄ‰ª•ÊÄªÁöÑÊù•ËØ¥ÔºåËøôËøòÊòØ‰∏™ÊØîËæÉÊúâË∂£ÁöÑÊ∏∏Êàè„ÄÇ Hangman ËøôÈáåËøòÊúâÂè¶‰∏Ä‰∏™ÊúâÊÑèÊÄùÁöÑ Hangman Â∞èÊ∏∏Êàè„ÄÇ HangmanÊòØ‰∏ÄÁ≥ªÂàóÁåúËØçÊ∏∏ÊàèÁöÑÁÆÄÁß∞„ÄÇÂú®Êàë‰ª¨ÁöÑHangman‰∏≠ÔºåÊàë‰ª¨ÈúÄË¶ÅÁåúÁöÑÊòØÁîµÊ∫êÁöÑËã±ÊñáÂêçÁß∞„ÄÇÊØèÊ¨°Â§±Ë¥•Â∞ÜÈÉΩ‰ºöÂú®HangmanÊ∑ªÂä†‰∏ÄÁ¨îÔºåÊúÄÁªàÂΩ¢Êàê‰∏ÄÂâØÂÆåÊï¥ÁöÑHangmanÂõæÔºåÊ∏∏ÊàèÂ§±Ë¥•„ÄÇ ________ | | | 0 | /|\\ | / \\ |\"\"\" ËØ•Ê∏∏ÊàèÁöÑÊ∫êÁ†ÅÂèØÂú®Ê≠§ Ëé∑Âæó „ÄÇ È¶ñÂÖàÊàë‰ª¨ÂÖàÂ§ÑÁêÜ‰∏Ä‰∏ãË¶ÅÁåúÁöÑÂçïËØçÔºö def _construct_word ( self , word : str ) -> defaultdict : character_dict = defaultdict ( set ) for index , character in enumerate ( word ): if character . strip () and character in ASCII : character_dict [ character ] . add ( index ) return character_dict Âú®Ê≠§Êàë‰ª¨Â∞ÜÊâÄÊúâÁöÑÊúâÊïàÂ≠óÊØçÂèäÂÖ∂Â∫èÂè∑‰øùÂ≠òÂú®Â≠óÂÖ∏‰∏≠ÔºåÂ¶Ç tootsie ‰∏≠ÁöÑ o ÂàôË¢´‰øùÂ≠ò‰∏∫ o: (1, 2) „ÄÇÊ≠§Â§ñÔºåÂ∞ÜË∞úÈù¢‰Ωú‰∏∫‰∏Ä‰∏™ÂàóË°®ÂÇ®Â≠òÔºåËøòÊú™Êè≠ÊôìÁöÑÊï∞Â≠óÁî® PlACEHOLDER Êõø‰ª£ÔºåÂàôÁåúÂà∞ o ÂêéÁöÑË∞úÈù¢‰∏∫ ['_', 'o', 'o', '_', '_', '_', '_'] „ÄÇËøôÊ†∑Âú®‰πãÂêéÁé©ÂÆ∂ÁåúÂà∞Â≠óÂÖ∏‰∏≠ÁöÑÂ≠óÊØçÊó∂Êàë‰ª¨: 1.Â∞ÜËØ•Â≠óÊØç‰ªéÂ≠óÂÖ∏ÈáåÂºπÂá∫Ôºõ2.Â∞ÜË∞úÈù¢ÂàóË°®‰∏≠ÊâÄÊúâËØ•Â≠óÊØçÂÇ®Â≠òÁöÑÂ∫èÂè∑ÁöÑÂÖÉÁ¥†ÊõøÊç¢‰∏∫ËØ•Â≠óÊØç„ÄÇÂΩìÂ≠óÂÖ∏ÈáåÊ≤°ÊúâÂÖÉÁ¥†Êó∂ÂÄôÔºåÁî®Êà∑‰æøÁåúÂá∫‰∫ÜÁõ∏ÂÖ≥ÂçïËØç„ÄÇ Âè¶Â§ñÈúÄË¶ÅËÄÉËôëÁöÑÊòØÁî®Êà∑ÁåúÊµãÂ§±Ë¥•ÁöÑ‰æãÂ≠êÔºåÊúâ‰∏§ÁßçÊÉÖÂÜµ‰ºöÂØºËá¥‰∏ÄÊ¨°ÁåúÊµãÁöÑÂ§±Ë¥•„ÄÇ‰∏ÄÊòØÁî®Êà∑ÊâÄÁåúÂ≠óÊØç‰∏çÂú®Êàë‰ª¨ÊâÄÁªôÁöÑË∞úÂ∫ï‰πã‰∏≠ÔºåËøôÊó∂Êàë‰ª¨ËæìÂá∫‰∏ÄÂº†HangmanÁöÑÂõæÁâáÔºåÂ¶ÇÊûúÁî®Êà∑ÁöÑÈîôËØØÊ¨°Êï∞ËøáÂ§öÂ∞ÜÂØºËá¥Ê∏∏ÊàèÁöÑÂ§±Ë¥•„ÄÇ‰∫åÊòØÁî®Êà∑Áåú‰∫Ü‰∏Ä‰∏™‰πãÂâçÁåúËøáÁöÑÂ≠óÊØçÔºåÊàë‰ª¨ËøôÊó∂‰ªÅÊÖàÁöÑÂºπÂá∫ÊèêÁ§∫Âπ∂Áªô‰∫àÁî®Êà∑‰∏ÄÊ¨°È¢ùÂ§ñÁöÑÁåúÊµãÊú∫‰ºö„ÄÇËøôÈÉ®ÂàÜÂÆûÁé∞ÁöÑ‰ª£Á†ÅÂ¶Ç‰∏ã: @types . coroutine def _hangman_popper ( self ): \"\"\"print a hangman graph if guess is not right\"\"\" guessed_character = set () graphics = hang_graphics () graph = next ( graphics ) while True : guess = yield False if guess not in guessed_character : guessed_character . add ( guess ) if guess in self . _word : print ( f '{colored(len(self._word[guess]),\"green\")} of {colored(guess,\"green\")} in the word.' ) for index in self . _word . pop ( guess ): self . _guess [ index ] = guess if not self . _word : yield True else : print ( f '{colored(guess,\"green\")} is not in the word! \\n ' f ' {graph} \\n ' ) try : graph = next ( graphics ) except StopIteration : raise NoChance else : print ( f 'You have guessed {colored(guess,\"green\")} before, please choose another character. \\n ' ) ËæìÂá∫Ë∂äÊù•Ë∂äÂÆåÊï¥ÁöÑHangmanÂõæÁâáÊòØ‰ª•ÁîüÊàêÂô®ÁöÑÊñπÂºèÂÆûÁé∞ÁöÑÔºåËøôÂêØÂèë‰∫ÜÊàë‰ª•ÂçèÁ®ãÁöÑÊñπÂºèÂÆûÁé∞Ê∏∏Êàè‰∏éÁî®Êà∑ÁöÑ‰∫§‰∫íËøáÁ®ã„ÄÇÂçèÁ®ãÊúâ‰∏âÁßçËæìÂá∫ÔºåÂàÜÂà´ÊòØÁåúÊµãÂ§±Ë¥•Êó∂ÁöÑ yield False ÔºåÂÆåÊàêË∞úÂ∫ïÊó∂ÁöÑ yield True ÂíåÊú∫‰ºöÁî®ÂÆåÊó∂ÁöÑ raise NoChane „ÄÇ‰∏Ä‰∏™ËøòÈúÄË¶ÅÊ≥®ÊÑèÁöÑÂú∞ÊñπÊòØÔºåÊàë‰ª¨ÈúÄË¶ÅÂú®HangmanÁ±ªÁöÑÊûÑÈÄ†ÂáΩÊï∞‰∏≠È¢ÑÊøÄËØ•ÁîüÊàêÂô®„ÄÇ Ëøô‰πüÊòØ‰∏Ä‰∏™Áõ∏ÂΩìÈïøÁü•ËØÜÁöÑÊ∏∏ÊàèÔºå‰∏ç‰ªÖÂ¶ÇÊ≠§ÔºåÁî®ÂçèÁ®ãÂÆûÁé∞ÁöÑËøáÁ®ã‰πüÊòØÁõ∏ÂΩìÊúâË∂£ÁöÑÔºåÊòØ‰∏ÄÁßç‰∏ç‰∏ÄÊ†∑ÁöÑÁºñÁ®ã‰ΩìÈ™å„ÄÇ Additional","tags":"posts","title":"[Review] Guess word and hangman game"},{"url":"stackoverflow-list-generator-algorithms.html","text":"Faltten nested lists with indices Ëøô‰∏™ÈóÆÈ¢òÊù•Ëá™ StackOverflow „ÄÇ ÂØπ‰∫é‰∏Ä‰∏™ÂµåÂ•óÁöÑÂàóË°®L: L = [[[ 1 , 2 , 3 ], [ 4 , 5 ]], [ 6 ], [ 7 ,[ 8 , 9 ]], 10 ] Â∏åÊúõÊúâ‰∏Ä‰∏™ÂáΩÊï∞ËÉΩÂ§üyieldÂá∫ÊØè‰∏™ÂÖÉÁ¥†ÁöÑÂµåÂ•ó‰ΩçÁΩÆÂÖÉÁªÑÔºö ( 1 , ( 0 , 0 , 0 )) ( 2 , ( 0 , 0 , 1 )) ( 3 , ( 0 , 0 , 2 )) ( 4 , ( 0 , 1 , 0 )) ( 5 , ( 0 , 1 , 1 )) ( 6 , ( 1 , 0 )) ( 7 , ( 2 , 0 )) ( 8 , ( 2 , 1 , 0 )) ( 9 , ( 2 , 1 , 1 )) ( 10 , ( 3 ,)) ‰ª• 4 ‰∏∫‰æãÔºåÂÖÉÁªÑ (0,1,0) ‰ª£Ë°®ÂÆÉÂ§Ñ‰∫éÁ¨¨‰∏ÄÂ±ÇÁöÑ È¶ñ‰∏™ÂàóË°® ‰∏≠ÁöÑ Á¨¨‰∫å‰∏™ÂàóË°® ÁöÑ Á¨¨‰∏Ä‰∏™ÂÖÉÁ¥† ÁöÑÁöÑ‰ΩçÁΩÆ‰∏ä„ÄÇ ‰πãÂâçÊàë‰πüÈÅáÂà∞Ëøá‰∏Ä‰∏™ yield from ÁöÑÁ§∫‰æãÔºåÂú®Ê≠§‰∏çÂæó‰∏çÊèê‰∏Ä‰∏ã def flatten ( iter ): for item in iter : if isinstance ( item , list ): yield from flatten ( item ) else : yield item Ëøô‰∏™ÂáΩÊï∞Áî®ÈÄíÂΩíÁöÑÊñπÂºèËÆ≤ÂµåÂ•óÂàóË°®ÈáåÁöÑÂÖÉÁ¥†ÂèñÂá∫Ôºå yield Âá∫‰∏Ä‰∏™ flatten ÁâàÊú¨ÁöÑÂàóË°®Ôºö [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] „ÄÇ ÂõûÂΩíÂà∞Ëøô‰∏™ÈóÆÈ¢òÔºåÊèêÈóÆËÄÖÁªôÂá∫‰∫Ü‰∏Ä‰∏™Âü∫‰∫éÈÄíÂΩíÂíåÁîüÊàêÂô®ÁöÑËß£ÂÜ≥ÊñπÊ°àÔºö def flatten ( l ): for i , e in enumerate ( l ): try : for x , y in flatten ( e ): yield x , ( i ,) + y except : yield e , ( i ,) Ëøô‰∏™ÂáΩÊï∞ÁöÑÂÖ≥ÈîÆÂú®‰∫éÂà©Áî®‰∫ÜÂÖÉÁªÑÂä†Ê≥ïÁöÑÊÄßË¥® (1, 2) + (3,) = (1, 2, 3) Êù•ËøîÂõûÂá∫ÂµåÂ•ó‰ΩçÁΩÆÁöÑ‰ø°ÊÅØÔºåËÄåÂÖÉÁªÑÊú¨Ë∫´ÂàôÊòØÁî±ÂèòÈáè e Âíå x ‰º†ÈÄí„ÄÇ ËÄåÂ∫ï‰∏ãÁöÑÁ≠îÊ°àÂàôÊèê‰æõ‰∫Ü‰∏Ä‰∏™ÈùûÈÄíÂΩíÁöÑÊñπÊ°àÔºö def flatten ( l ): stack = [ enumerate ( l )] path = [ None ] while stack : for path [ - 1 ], x in stack [ - 1 ]: if isinstance ( x , list ): stack . append ( enumerate ( x )) path . append ( None ) else : yield x , tuple ( path ) break else : stack . pop () path . pop () Ëøô‰∏™ÁÆóÊ≥ïÂÆö‰πâ‰∫Ü‰∏§‰∏™Ê†à stack Âíå path „ÄÇ path Áî®Êù•Â≠òÂÇ®ÂΩìÂâçËøΩË∏™ÂÖÉÁ¥†ÁöÑÂµåÂ•ó‰ΩçÁΩÆ‰ø°ÊÅØÔºåËÄå stack ÂàôÊòØ‰ª•Â§ñÂ±ÇËá≥ÂÜÖÂ±ÇÁöÑÈ°∫Â∫èÂ∞ÜÂàóË°®ÁöÑ enumerate Ëø≠‰ª£Âô®ÂÖ•Ê†à„ÄÇÂπ∂ÊåâÂ±ÇÊ¨°ÈÅçÂéÜ„ÄÇÁÆóÊ≥ïÊú¨Ë∫´Â∑ßÂ¶ôÁöÑ‰∏ÄÁÇπÊòØÂ∞ÜÂÖ•Ê†àÁöÑÂàùÂßã‰ΩçÁΩÆÁΩÆ‰∏∫ None Ôºå‰πãÂêéÂÜçÈÄöËøáÂØπ enumerate ÁöÑÊãÜÂåÖÁî®ÂÖÉÁ¥†ÁöÑ‰ΩçÁΩÆ‰ø°ÊÅØÊõøÊç¢ path Ê†àÁöÑÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†„ÄÇËøô‰∏™ÊñπÊ≥ïÊ≤°Êúâ‰ΩøÁî®ÈÄíÂΩí„ÄÇ Iterate through array while finding the mean of the top k elements Êù•Ê∫ê‰∫éStack OverflowÁöÑÈóÆÈ¢ò: Python iterate through array while finding the mean of the top k elements „ÄÇ ÈóÆÈ¢òÁöÑÊèèËø∞ÊòØËøôÊ†∑ÁöÑÔºöÂØπ‰∫é‰∏Ä‰∏™ÂàóË°® a = [3, 5, 2, 7, 5, 3, 6, 8, 4] , Êàë‰ª¨Â∏åÊúõÊâæÂà∞ÊâÄÊúâËøûÁª≠‰∏â‰∏™ÂÖÉÁ¥†‰∏≠ÊúÄÂ§ß‰∏§‰∏™ÂÖÉÁ¥†ÁöÑÂùáÂÄº„ÄÇÂØπ‰∫é‰∏æ‰æãÁöÑÂàóË°® a Â∞ÜÁîüÊàêÂàóË°® [4, 6, 6, 6, 5.5, 7, 7] „ÄÇÈ¶ñ‰∏™ËøûÁª≠‰∏âÂÖÉÁ¥†ÁªÑÂêà [3, 5, 2] ÁöÑËÆ°ÁÆóÁªìÊûú‰∏∫ 4 „ÄÇ Êàë‰ª¨ÂèØÊääÊï¥‰∏™ÈóÆÈ¢òÂàÜËß£Êàê‰∏â‰∏™ÈÉ®ÂàÜÔºö 1. Ëé∑ÂæóÊØè‰∏™ËøûÁª≠‰∏âÂÖÉÁªÑ 2. ÂèñÂá∫Ââç‰∏§Â§ßÁöÑÂÖÉÁ¥† 3. ËÆ°ÁÆóÂπ≥ÂùáÂÄº„ÄÇÂØπ‰∫éÊâÄÊúâÈóÆÈ¢òÔºåÊàëÊØîËæÉÂñúÊ¨¢Ëøô‰∏™Ëß£Á≠îÔºö # Sliding window def windowed_iterator ( iterable , n = 2 ): iterators = itertools . tee ( iterable , n ) iterators = ( itertools . islice ( it , i , None ) for i , it in enumerate ( iterators )) yield from zip ( * iterators ) windows = windowed_iterator ( iterable = a , n = 3 ) # Top 2 elements from heapq import nlargest top_n = map ( lambda x : nlargest ( 2 , x ), windows ) # Mean from statistics import mean means = map ( mean , top_n ) ÊØîËæÉÊúâË∂£ÁöÑÊòØ Sliding window ÁöÑÈÉ®ÂàÜÔºåËøôÈáåÊàë‰ª¨Áî® itertools.tee ÁîüÊàê‰∏â‰∏™Áã¨Á´ãÁöÑËø≠‰ª£Âô®„ÄÇÂπ∂‰∏îÁî® islice Âíå zip ËøõË°åÈîô‰ΩçÂíåÁªÑÂêàÔºåÊúÄÁªàÁîüÊàêËøûÁª≠‰∏âÂÖÉÁªÑÂ∫èÂàó„ÄÇ Additional","tags":"posts","title":"StackOverflow list generator algorithms"},{"url":"build-a-circular-list-and-regex-trie.html","text":"Dancing programs Ëøô‰∏™ÈóÆÈ¢òÊù•Ëá™ Advent of code ÁöÑ Á¨¨ÂçÅÂÖ≠Êó• „ÄÇ Ëß£ÂÜ≥‰ª£Á†ÅÂ¶Ç‰∏ã: def solution ( lst , order ): # Âæ™ÁéØÊï∞ÁªÑÔºåstart‰∏∫Â§¥ÊåáÈíà result_list = list ( order ) # ÂáèÂ∞ëPartnerÊó∂Èó¥Â§çÊùÇÂ∫¶ÁöÑÂ≠óÂÖ∏ result_dict = { s : i for i , s in enumerate ( result_list )} length = len ( result_list ) start = 0 for action in lst : if action . startswith ( 's' ): start = ( start + length ) % length - int ( action [ 1 :]) continue if action . startswith ( 'x' ): x , y = action [ 1 :] . split ( '/' ) x_real = ( start + int ( x )) % length y_real = ( start + int ( y )) % length elif action . startswith ( 'p' ): x , y = action [ 1 :] . split ( '/' ) x_real = result_dict [ x ] y_real = result_dict [ y ] result_list [ x_real ], result_list [ y_real ] = result_list [ y_real ], result_list [ x_real ] result_dict [ result_list [ x_real ]], result_dict [ result_list [ y_real ]] = result_dict [ result_list [ y_real ]], \\ result_dict [ result_list [ x_real ]] return \"\" . join ( result_list [ i % length ] for i in range ( start , start + length )) def solution2 ( lst Ôºå order ): orders = [] while order not in orders : orders . append ( order ) order = solution ( lst , order ) return orders [ 1000000000 % len ( orders )] ÂØπ‰∫éÁ¨¨‰∏ÄÈÉ®ÂàÜÊ∂âÂèäÂà∞ÁöÑ‰∏â‰∏™Êìç‰Ωú„ÄÇÁ¨¨‰∏Ä‰∏™Êìç‰ΩúSpin sX ÔºåÂè™ÈúÄÂ∞ÜÂ§¥ÊåáÈíàÂêéÁßªX‰Ωç„ÄÇÂØπ‰∫éÁ¨¨‰∫å‰∏™Êìç‰ΩúExchangeÂíåÁ¨¨‰∏â‰∏™Êìç‰ΩúPartnerÔºåÁî±‰∫éÊ∂âÂèäÂà∞indexÂíåÂÄºÁöÑÊØîËæÉÔºåÂõ†Ê≠§Êàë‰ª¨ÈÄöËøáÂª∫Á´ã{ÂÄºÔºöindex}Â≠óÂÖ∏ÁöÑÂΩ¢ÂºèÊù•ÂáèÂ∞ëPartnerÊìç‰ΩúÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶„ÄÇ Á¨¨‰∫åÈÉ®ÂàÜÈóÆÈ¢òÁî±‰∫éË¶ÅÂæ™ÁéØ‰∏Ä‰∫øÊ¨°ÔºåÂÖ®ÈÉ®ÈÅçÂéÜÊó∂Èó¥Â§çÊùÇÂ∫¶ËøáÈ´ò„ÄÇÊµãËØïÂèëÁé∞ÂΩìËæìÂÖ•Áõ∏ÂêåÁöÑÊìç‰ΩúÂ∫èÂàóÊó∂ÔºåÂ§öÊ¨°ÈÅçÂéÜÂêé‰ºöÂá∫Áé∞Âæ™ÁéØÁöÑÊÉÖÂÜµÔºåÂõ†Ê≠§ÊúâËß£Ê≥ï‰∫å„ÄÇ Regex replacement Êù•Ê∫ê‰∫éStack OverflowÁöÑ‰∏Ä‰∏™ÈóÆÈ¢ò: Speed up millions of regex replacements in Python 3 „ÄÇ ËµûÂêåÊúÄÂ§öÁöÑ \"\\b(word1|word2|word3)\\b\" ÊñπÊ≥ïÂÖ∂ÂÆû‰∏çÊòØÊúÄÂ•ΩÁöÑÁÆóÊ≥ïÔºåÊ≠£ÂàôÂπ∂ÈõÜ‰ºöÂ∏¶Êù•O(1)ÁöÑÊúÄÂ•ΩÊó∂Èó¥Â§çÊùÇÂ∫¶ÔºåO(n)ÁöÑÂπ≥ÂùáÂèäÊúÄÂ∑ÆÊó∂Èó¥Â§çÊùÇÂ∫¶„ÄÇÈ™åËØÅ‰ª£Á†ÅÂ¶Ç‰∏ãÔºö import re import timeit import random with open ( '/usr/share/dict/american-english' ) as wordbook : english_words = [ word . strip () . lower () for word in wordbook ] random . shuffle ( english_words ) print ( \"First 10 words :\" ) print ( english_words [: 10 ]) test_words = [ ( \"Surely not a word\" , \"#surely_N√∂T√§WORD_so_regex_engine_can_return_fast\" ), ( \"First word\" , english_words [ 0 ]), ( \"Last word\" , english_words [ - 1 ]), ( \"Almost a word\" , \"couldbeaword\" ) ] def find ( word ): def fun (): return union . match ( word ) return fun for exp in range ( 1 , 6 ): print ( \" \\n Union of %d words\" % 10 ** exp ) union = re . compile ( r \"\\b( %s )\\b\" % '|' . join ( english_words [: 10 ** exp ])) for description , test_word in test_words : time = timeit . timeit ( find ( test_word ), number = 1000 ) * 1000 print ( \" %-17s : %.1f ms\" % ( description , time )) Output: First 10 words : [ \"geritol's\" , \"sunstroke's\" , 'fib' , 'fergus' , 'charms' , 'canning' , 'supervisor' , 'fallaciously' , \"heritage's\" , 'pastime' ] Union of 10 words Surely not a word : 0.7 ms First word : 0.8 ms Last word : 0.7 ms Almost a word : 0.7 ms Union of 100 words Surely not a word : 0.7 ms First word : 1.1 ms Last word : 1.2 ms Almost a word : 1.2 ms Union of 1000 words Surely not a word : 0.7 ms First word : 0.8 ms Last word : 9.6 ms Almost a word : 10.1 ms Union of 10000 words Surely not a word : 1.4 ms First word : 1.8 ms Last word : 96.3 ms Almost a word : 116.6 ms Union of 100000 words Surely not a word : 0.7 ms First word : 0.8 ms Last word : 1227.1 ms Almost a word : 1404.1 ms Ëøô‰ºöÂØºËá¥Êï¥‰ΩìÁÆóÊ≥ïÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶Âèò‰∏∫O(n&#94;2),Âõ†Ê≠§ÊúâÂ¶Ç‰∏ã‰∏§‰∏™Ëß£Ê≥ïÔºö import re with open ( '/usr/share/dict/american-english' ) as wordbook : banned_words = set ( word . strip () . lower () for word in wordbook ) def delete_banned_words ( matchobj ): word = matchobj . group ( 0 ) if word . lower () in banned_words : return \"\" else : return word sentences = [ \"I'm eric. Welcome here!\" , \"Another boring sentence.\" , \"GiraffeElephantBoat\" , \"sfgsdg sdwerha aswertwe\" ] * 250000 for sentence in sentences : sentence = re . sub ( '\\w+' , delete_banned_words , sentence ) Ëøô‰∏™Ëß£Ê≥ïÊó∂Èó¥ÂèëÂ§çÊùÇÂ∫¶‰∏∫O(n)Ôºå‰ΩÜÊòØ‰ºöÂú®ÂéªÊéâÂçïËØçÊó∂Áïô‰∏ãÁ©∫Ê†º„ÄÇÂõ†‰∏∫ÂÆÉÊòØÊâ´Êèè \\w+ ÁöÑÔºåÂõ†Ê≠§Êó†Ê≥ïÈÅøÂÖçËøô‰∏™ÈóÆÈ¢ò„ÄÇ ‰∏Ä‰∏™ÂØπ‰πãÂâçÊ≠£ÂàôÂπ∂ÈõÜÁöÑÊîπËøõÊòØÈÄöËøáÂ≠óÂÖ∏Ê†ëÁöÑÊñπÂºèÂàõÂª∫Ê≠£ÂàôÂπ∂ÈõÜÔºåËØ•ÁÆóÊ≥ïÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰πü‰∏∫O(n)„ÄÇ class Trie (): \"\"\"Regex::Trie in Python. Creates a Trie out of a list of words. The trie can be exported to a Regex pattern. The corresponding Regex should match much faster than a simple Regex union.\"\"\" def __init__ ( self ): self . data = {} def add ( self , word ): ref = self . data for char in word : ref [ char ] = char in ref and ref [ char ] or {} ref = ref [ char ] ref [ '' ] = 1 def dump ( self ): return self . data def quote ( self , char ): return re . escape ( char ) def _pattern ( self , pData ): data = pData if \"\" in data and len ( data . keys ()) == 1 : return None alt = [] cc = [] q = 0 for char in sorted ( data . keys ()): if isinstance ( data [ char ], dict ): recurse = self . _pattern ( data [ char ]) if recurse : alt . append ( self . quote ( char ) + recurse ) else : cc . append ( self . quote ( char )) else : q = 1 cconly = not len ( alt ) > 0 if len ( cc ) > 0 : if len ( cc ) == 1 : alt . append ( cc [ 0 ]) else : alt . append ( '[' + '' . join ( cc ) + ']' ) if len ( alt ) == 1 : result = alt [ 0 ] else : result = \"(?:\" + \"|\" . join ( alt ) + \")\" if q : if cconly : result += \"?\" else : result = \"(?: %s )?\" % result return result def pattern ( self ): return self . _pattern ( self . dump ()) ËøôÊÆµ‰ª£Á†ÅÈ¶ñÂÖà‰ºöÁîüÊàêÊâÄÊúâË¢´banÂçïËØçÁöÑÂ≠óÂÖ∏Ê†ëÔºåÁÑ∂ÂêéparseËØ•Ê†ëÁîüÊàêÂÉèÂ¶Ç‰∏ãËøôÊ†∑ÁöÑÊ≠£ÂàôË°®ËææÂºèÔºö ( ? : a ( ? : ( ? :\\ 's|a(?:\\' s | chen | liyah ( ? :\\ 's)?|r(?:dvark(?:(?:\\' s | s )) ? | on )) | b ( ? :\\ 's|a(?:c(?:us(?:(?:\\' s | es )) ? |[ ik ] ) | ft | lone ( ? : ( ? :\\ 's|s))?|ndon(?:(?:ed|ing|ment(?:\\' s ) ? | s )) ? | s ( ? : e ( ? : ( ? : ment ( ? :\\ 's)?|[ds]))?|h(?:(?:e[ds]|ing))?|ing)|t(?:e(?:(?:ment(?:\\' s ) ? |[ ds ] )) ? | ing | toir ( ? : ( ? :\\ 's|s))?))|b(?:as(?:id)?|e(?:ss(?:(?:\\' s | es )) ? | y ( ? : ( ? :\\ 's|s))?)|ot(?:(?:\\' s | t ( ? :\\ 's)?|s))?|reviat(?:e[ds]?|i(?:ng|on(?:(?:\\' s | s )) ? )) | y ( ? :\\ 's)?|\\√©(?:(?:\\' s | s )) ? ) | d ( ? : icat ( ? : e [ ds ] ? | i ( ? : ng | on ( ? : ( ? :\\ 's|s))?))|om(?:en(?:(?:\\' s | s )) ? | inal ) | u ( ? : ct ( ? : ( ? : ed | i ( ? : ng | on ( ? : ( ? :\\ 's|s))?)|or(?:(?:\\' s | s )) ? | s )) ? | l ( ? :\\ 's)?))|e(?:(?:\\' s | am | l ( ? : ( ? :\\ 's|ard|son(?:\\' s ) ? )) ? | r ( ? : deen ( ? :\\ 's)?|nathy(?:\\' s ) ? | ra ( ? : nt | tion ( ? : ( ? :\\ 's|s))?))|t(?:(?:t(?:e(?:r(?:(?:\\' s | s )) ? | d ) | ing | or ( ? : ( ? :\\ 's|s))?)|s))?|yance(?:\\' s ) ? | d )) ? | hor ( ? : ( ? : r ( ? : e ( ? : n ( ? : ce ( ? :\\ 's)?|t)|d)|ing)|s))?|i(?:d(?:e[ds]?|ing|jan(?:\\' s ) ? ) | gail | l ( ? : ene | it ( ? : ies | y ( ? :\\ 's)?)))|j(?:ect(?:ly)?|ur(?:ation(?:(?:\\' s | s )) ? | e [ ds ] ? | ing )) | l ( ? : a ( ? : tive ( ? : ( ? :\\ 's|s))?|ze)|e(?:(?:st|r))?|oom|ution(?:(?:\\' s | s )) ? | y ) | m \\ 's|n(?:e(?:gat(?:e[ds]?|i(?:ng|on(?:\\' s ) ? )) | r ( ? :\\ 's)?)|ormal(?:(?:it(?:ies|y(?:\\' s ) ? ) | ly )) ? ) | o ( ? : ard | de ( ? : ( ? :\\ 's|s))?|li(?:sh(?:(?:e[ds]|ing))?|tion(?:(?:\\' s | ist ( ? : ( ? :\\ 's|s))?))?)|mina(?:bl[ey]|t(?:e[ds]?|i(?:ng|on(?:(?:\\' s | s )) ? ))) | r ( ? : igin ( ? : al ( ? : ( ? :\\ 's|s))?|e(?:(?:\\' s | s )) ? ) | t ( ? : ( ? : ed | i ( ? : ng | on ( ? : ( ? :\\ 's|ist(?:(?:\\' s | s )) ? | s )) ? | ve ) | s )) ? ) | u ( ? : nd ( ? : ( ? : ed | ing | s )) ? | t ) | ve ( ? : ( ? :\\ 's|board))?)|r(?:a(?:cadabra(?:\\' s ) ? | d ( ? : e [ ds ] ? | ing ) | ham ( ? :\\ 's)?|m(?:(?:\\' s | s )) ? | si ( ? : on ( ? : ( ? :\\ 's|s))?|ve(?:(?:\\' s | ly | ness ( ? :\\ 's)?|s))?))|east|idg(?:e(?:(?:ment(?:(?:\\' s | s )) ? |[ ds ] )) ? | ing | ment ( ? : ( ? :\\ 's|s))?)|o(?:ad|gat(?:e[ds]?|i(?:ng|on(?:(?:\\' s | s )) ? ))) | upt ( ? : ( ? : e ( ? : st | r ) | ly | ness ( ? :\\ 's)?))?)|s(?:alom|c(?:ess(?:(?:\\' s | e [ ds ]| ing )) ? | issa ( ? : ( ? :\\ 's|[es]))?|ond(?:(?:ed|ing|s))?)|en(?:ce(?:(?:\\' s | s )) ? | t ( ? : ( ? : e ( ? : e ( ? : ( ? :\\ 's|ism(?:\\' s ) ? | s )) ? | d ) | ing | ly | s )) ? ) | inth ( ? : ( ? :\\ 's|e(?:\\' s ) ? )) ? | o ( ? : l ( ? : ut ( ? : e ( ? : ( ? :\\ 's|ly|st?))?|i(?:on(?:\\' s ) ? | sm ( ? :\\ 's)?))|v(?:e[ds]?|ing))|r(?:b(?:(?:e(?:n(?:cy(?:\\' s ) ? | t ( ? : ( ? :\\' s | s )) ? ) | d ) | ing | s )) ? | pti ... Additional","tags":"posts","title":"Build a circular list and regex trie"},{"url":"top-10-python-libraries-of-2017.html","text":"December is the time when you sit back and think about the accomplishments of the past year. For us programmers, this is often looking at the open source libraries that were either released this year (or close enough), or whose popularity has recently boomed because they are simply great tools to solve a particular problem. For the past two years , we have done this in the form of a blog post with what we consider to be some of the best work that has been done in the Python community. Now, as we are wrapping up 2017, we had to do the same. This time, the list comes with a Machine Learning (ML) flavor . Forgive us, authors of great non-ML libraries, but we are just too biased ;) Hopefully, people in the comments help us do some justice and mention other great pieces of software, some of which have surely have escaped our radar. So, without further ado, here it goes! 1. Pipenv We couldn't make this list without reserving the top spot for a tool that was only released early this year, but has the power to affect the workflow of every Python developer, especially more now since it has become the officially recommended tool on Python.org for managing dependencies! Pipenv, originally started as a weekend project by the awesome Kenneth Reitz , aims to bring ideas from other package managers (such as npm or yarn ) into the Python world. Forget about installing virtualenv , virtualenvwrapper , managing requirements.txt files and ensuring reproducibility with regards to versions of dependencies of the dependencies (read here for more info about this). With Pipenv, you specify all your dependencies in a Pipfile ‚Äî which is normally built by using commands for adding, removing, or updating dependencies. The tool can generate a Pipfile.lock file, enabling your builds to be deterministic , helping you avoid those difficult to catch bugs because of some obscure dependency that you didn't even think you needed. Of course, Pipenv comes with many other perks and has great documentation , so make sure to check it out and start using it for all your Python projects, as we do at Tryolabs :) 2. PyTorch If there is a library whose popularity has boomed this year, especially in the Deep Learning (DL) community, it's PyTorch, the DL framework introduced by Facebook this year. PyTorch builds on and improves the (once?) popular Torch framework, especially since it's Python based ‚Äî in contrast with Lua. Given how people have been switching to Python for doing data science in the last couple of years, this is an important step forward to make DL more accessible. Most notably, PyTorch has become one of the go-to frameworks for many researchers, because of its implementation of the novel Dynamic Computational Graph paradigm. When writing code using other frameworks like TensorFlow , CNTK or MXNet , one must first define something called a computational graph . This graph specifies all the operations that will be run by our code, which are later compiled and potentially optimized by the framework, in order to allow for it to be able to run even faster, and in parallel on a GPU. This paradigm is called Static Computational Graph , and is great since you can leverage all sorts of optimizations and the graph, once built, can potentially run in different devices (since execution is separate from building ). However, in many tasks such as Natural Language Processing, the amount of \"work\" to do is often variable: you can resize images to a fixed resolution before feeding them to an algorithm, but cannot do the same with sentences which come in variable length. This is where PyTorch and dynamic graphs shine, by letting you use standard Python control instructions in your code, the graph will be defined when it is executed, giving you a lot of freedom which is essential for several tasks. Of course, PyTorch also computes gradients for you (as you would expect from any modern DL framework), is very fast, and extensible , so why not give it a try? 3. Caffe2 It might sound crazy, but Facebook also released another great DL framework this year. The original Caffe framework has been widely used for years, and known for unparalleled performance and battle-tested codebase. However, recent trends in DL made the framework stagnate in some directions. Caffe2 is the attempt to bring Caffe to the modern world. It supports distributed training, deployment (even in mobile platforms), the newest CPUs and CUDA-capable hardware. While PyTorch may be better for research, Caffe2 is suitable for large scale deployments as seen on Facebook. Also, check out the recent ONNX effort . You can build and train your models in PyTorch, while using Caffe2 for deployment! Isn't that great? 4. Pendulum Last year, Arrow , a library that aims to make your life easier while working with datetimes in Python, made the list. This year, it is the turn of Pendulum. One of Pendulum's strength points is that it is a drop-in replacement for Python's standard datetime class, so you can easily integrate it with your existing code, and leverage its functionalities only when you actually need them. The authors have put special care to ensure timezones are handled correctly, making every instance timezone-aware and UTC by default. You will also get an extended timedelta to make datetime arithmetic easier. Unlike other existing libraries, it strives to have an API with predictable behavior, so you know what to expect. If you are doing any non trivial work involving datetimes, this will make you happier! Check out the docs for more. 5. Dash You are doing data science, for which you use the excellent available tools in the Python ecosystem like Pandas and scikit-learn . You use Jupyter Notebooks for your workflow, which is great for you and your colleagues. But how do you share the work with people who do not know how to use those tools? How do you build an interface so people can easily play around with the data, visualizing it in the process? It used to be the case that you needed a dedicated frontend team, knowledgeable in Javascript, for building these GUIs. Not anymore. Dash, announced this year , is an open source library for building web applications, especially those that make good use of data visualization, in pure Python. It is built on top of Flask , Plotly.js and React , and provides abstractions that free you from having to learn those frameworks and let you become productive quickly. The apps are rendered in the browser and will be responsive so they will be usable in mobile devices. If you would like to know more about what is possible with Dash, the Gallery is a great place for some eye-candy. 6. PyFlux There are many libraries in Python for doing data science and ML, but when your data points are metrics that evolve over time (such as stock prices, measurements obtained from instruments, etc), that is not the case. PyFlux is an open source library in Python built specifically for working with time series . The study of time series is a subfield of statistics and econometrics, and the goals can be describing how time series behave (in terms of latent components or features of interest), and also predicting how they will behave the future. PyFlux allows for a probabilistic approach to time series modeling, and has implementations for several modern time series models like GARCH . Neat stuff. 7. Fire It is often the case that you need to make a Command Line Interface (CLI) for your project. Beyond the traditional argparse , Python has some great tools like click or docopt . Fire, announced by Google this year , has a different take on solving this same problem. Fire is an open source library that can automatically generate a CLI for any Python project. The key here is automatically : you almost don't need to write any code or docstrings to build your CLI! To do the job, you only need to call a Fire method and pass it whatever you want turned into a CLI: a function, an object, a class, a dictionary, or even pass no arguments at all (which will turn your entire code into a CLI). Make sure to read the guide so you understand how it works with examples. Keep it under your radar, because this library can definitely save you a lot of time in the future. 8. imbalanced-learn In an ideal world, we would have perfectly balanced datasets and we would all train models and be happy. Unfortunately, the real world is not like that, and certain tasks favor very imbalanced data. For example, when predicting fraud in credit card transactions, you would expect that the vast majority of the transactions (+99.9%?) are actually legit. Training ML algorithms naively will lead to dismal performance, so extra care is needed when working with these types of datasets. Fortunately, this is a studied research problem and a variety of techniques exist. Imbalanced-learn is a Python package which offers implementations of some of those techniques, to make your life much easier. It is compatible with scikit-learn and is part of scikit-learn-contrib projects. Useful! 9. FlashText When you need to search for some text and replace it for something else, as is standard in most data-cleaning work, you usually turn to regular expressions. They will get the job done, but sometimes it happens that the number of terms you need to search for is in the thousands, and then, reg exp can become painfully slow to use. FlashText is a better alternative just for this purpose. In the author's initial benchmark , it improved the runtime of the entire operation by a huge margin: from 5 days to 15 minutes. The beauty of FlashText is that the runtime is the same no matter how many search terms you have, in contrast with regexp in which the runtime will increase almost linearly with the number of terms. FlashText is a testimony to the importance of the design of algorithms and data structures, showing that, even for simple problems, better algorithms can easily outdo even the fastest CPUs running naive implementations. 10. Luminoth Disclaimer: this library was built by Tryolabs' R&D area. Images are everywhere nowadays, and understanding their content can be critical for several applications. Thankfully, image processing techniques have advanced a lot, fueled by the advancements in DL. Luminoth is an open source Python toolkit for computer vision, built using TensorFlow and Sonnet . Currently, it out-of-the-box supports object detection in the form of a model called Faster R-CNN. But Luminoth is not only an implementation of a particular model. It is built to be modular and extensible, so customizing the existing pieces or extending it with new models to tackle different problems should be straightforward, with as much code reuse as there can be. It provides tools for easily doing the engineering work that are needed when building DL models: converting your data (in this case, images) to adequate format for feeding your data pipeline ( TensorFlow's tfrecords ), doing data augmentation, running the training in one or multiple GPUs (distributed training will be a must when working with large datasets), running evaluation metrics, easily visualizing stuff in TensorBoard and deploying your trained model with a simple API or browser interface, so people can play around with it. Moreover, Luminoth has straightforward integration with Google Cloud's ML Engine , so even if you don't own a powerful GPU, you can train in the cloud with a single command, just as you do in your own local machine. If you are interested in learning more about what's behind the scenes, you can read the announcement blog post and watch the video of our talk at ODSC. Bonus: watch out for these PyVips You may have never heard of the libvips library. In that case, you must know that it's an image processing library, like Pillow or ImageMagick , and supports a wide range of formats. However, when comparing to other libraries, libvips is faster and uses less memory . For example, some benchmarks show it to be about 3x faster and use less than 15x memory as ImageMagick. You can read more about why libvips is nice here . PyVips is a recently released Python binding for libvips, which is compatible with Python 2.7-3.6 (and even PyPy), easy to install with pip and drop-in compatible with the old binding, so if you are using that, you don't have to modify your code. If doing some sort of image processing in your app, definitely something to keep an eye on. Requestium Disclaimer: this library was built by Tryolabs. Sometimes, you need to automatize some actions in the web. Be it when scraping sites, doing application testing, or filling out web forms to perform actions in sites that do not expose an API, automation is always necessary. Python has the excellent Requests library which allows you perform some of this work, but unfortunately (or not?) many sites make heavy client side use of Javascript. This means that the HTML code that Requests fetches, in which you could be trying to find a form to fill for your automation task, may not even have the form itself! Instead, it will be something like an empty div of some sort that will be generated in the browser with a modern frontend library such as React or Vue . One way to solve this is to reverse-engineer the requests that Javascript code makes, which will mean many hours of debugging and fiddling around with (probably) uglified JS code. No thanks. Another option is to turn to libraries like Selenium , which allow you to programmatically interact with a web browser and run the Javascript code. With this, the problems are no more, but it is still slower than using plain Requests which adds very little overhead. Wouldn't it be cool if there was a library that let you start out with Requests and seamlessly switch to Selenium, only adding the overhead of a web browser when actually needing it? Meet Requestium, which acts as a drop-in replacement for Requests and does just that. It also integrates Parsel , so writing all those selectors for finding the elements in the page is much cleaner than it would otherwise be, and has helpers around common operations like clicking elements and making sure stuff is actually rendered in the DOM. Another time saver for your web automation projects! skorch You like the awesome API of scikit-learn, but need to do work using PyTorch? Worry not, skorch is a wrapper which will give PyTorch an interface like sklearn. If you are familiar with those libraries, the syntax should be straightforward and easy to understand. With skorch, you will get some code abstracted away, so you can focus more on the things that really matter, like doing your data science. Conclusion What an exciting year! If you know of a library that deserves to be on this list, make sure you mention it in the comments below. There are so many good developments that it's hard to keep up. As usual, thanks to everybody in the community for such great work! Finally, don't forget to subscribe to our newsletter so that you don't miss out future editions of this post or our ML related content.","tags":"Python","title":"Top 10 Python libraries of 2017"},{"url":"find-longest-word-in-dictionary-that-is-a-subsequence-of-a-given-string.html","text":"Description Given a string S and a set of words D , find the longest word in D that is a subsequence of S . Word W is a subsequence of S if some number of characters, possibly zero, can be deleted from S to form W , without reordering the remaining characters. Note: D can appear in any format (list, hash table, prefix tree, etc. For example, given the input of S = \"abppplee\" and D = {\"able\", \"ale\", \"apple\", \"bale\", \"kangaroo\"} the correct output would be \"apple\" . The words \"able\" and \"ale\" are both subsequences of S, but they are shorter than \"apple\". The word \"bale\" is not a subsequence of S because even though S has all the right letters, they are not in the right order. The word \"kangaroo\" is the longest word in D, but it isn't a subsequence of S. Solution Check each dictionary word using a greedy algorithm ‰∏Ä‰∏™ÊØîËæÉÂÆπÊòìÊÉ≥Âà∞ÁöÑÊñπÊ≥ïÂ∞±ÊòØÂ∞ÜÂ≠óÂÖ∏‰∏≠ÁöÑÂçïËØç‰∏é S ÈÄê‰∏™ÊØîËæÉÔºåËøôÊ†∑ÊúÄÂ∑ÆÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫O(N W M)„ÄÇ W ‰ΩçÂ≠óÂÖ∏‰∏≠ÁöÑÂçïËØçÊï∞ÈáèÔºå M ‰∏∫ÂçïËØçÁöÑÂπ≥ÂùáÈïøÂ∫¶„ÄÇËôΩÁÑ∂ÂèØ‰ª•Â∞ÜÂ≠óÂÖ∏‰∏≠ÁöÑÂçïËØçÊåâÈïøÂ∫¶ÈôçÂ∫èÊéíÂàóÊù•ÂáèÂ∞ë‰∏ÄËà¨Áä∂ÊÄÅ‰∏ãÁöÑËøêË°åÊó∂Èó¥Ôºå‰ΩÜ‰∏ç‰ºöÂáèÂ∞ëÊúÄÂ∑ÆÊó∂Èó¥Â§çÊùÇÂ∫¶„ÄÇÂ∞Ü L ËÆæ‰∏∫Â≠óÂÖ∏‰∏≠ÊâÄÊúâÂçïËØçÂ≠óÊØçÈïøÂ∫¶‰πãÂíåÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰πüÂèØ‰ª•Ë°®Á§∫‰∏∫O(N*L)„ÄÇ ‰ª£Á†ÅÂ¶Ç‰∏ãÔºö s = 'abppplee' d = [ 'able' , 'ale' , 'apple' , 'bale' , 'kangaroo' ] def compare ( s , w ): i = 0 for character in w : while i < len ( s ): if character == s [ i ]: i += 1 break i += 1 else : break else : return True return False def solution ( s , d ): for w in sorted ( d , key = len , reverse = True ): if compare ( s , w ): return w print ( solution ( s , d )) Improving the greedy approach Êàë‰ª¨‰πüÂèØ‰ª•ÂØπ S ÂÅö‰∏Ä‰∫õÈ¢ÑÂ§ÑÁêÜÊìç‰ΩúÔºåËÆ∞ÂΩïÂÖ∂‰∏≠Â≠óÊØçÁöÑÂá∫Áé∞Ôºö S = \"abppplee\" a -> [ 0 ] b -> [ 1 ] p -> [ 2 , 3 , 4 ] l -> [ 5 ] e -> [ 6 , 7 ] Ëøô‰∏ÄÊìç‰ΩúÁöÑÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫O(n)„ÄÇÂú®Êàë‰ª¨Êü•ÊâæÊó∂ÔºåÂØπ‰∫é‰∏Ä‰∏™Â≠óÂÖ∏‰∏≠ÁöÑÂçïËØç w ÔºåÈ¶ñÂÖàÂà§Êñ≠ÂÆÉÁöÑÂ≠óÊØç X ÊòØÂê¶Âú®‰∏äËø∞Êï∞ÊçÆÁªìÊûÑ‰∏≠Ôºå‰πãÂêéÂÜçÂéª‰∫åÂàÜÊü•ÊâæÂà∞Êï∞ÊçÆÁªìÊûÑ‰∏≠ÁöÑÊª°Ë∂≥ÔºöÊúÄÂ∞èÁöÑindexÂ§ß‰∫é X ÁöÑ Y Â≠óÊØçÔºåÂÖ∂‰∏≠ Y ‰∏∫ X ÁöÑ‰∏ã‰∏Ä‰∏™Â≠óÊØç„ÄÇËøôÊ†∑Â§ÑÁêÜÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫O(N + L * logN)„ÄÇ GoogleÊèê‰æõÁöÑ‰ª£Á†ÅÂ¶Ç‰∏ãÔºö import collections import sys def find_longest_word_in_string ( letters , words ): letter_positions = collections . defaultdict ( list ) # For each letter in 'letters', collect all the indices at which it appears. # O(#letters) space and speed. for index , letter in enumerate ( letters ): letter_positions [ letter ] . append ( index ) # For words, in descending order by length... # Bails out early on first matched word, and within word on # impossible letter/position combinations, but worst case is # O(#words # avg-len) * O(#letters / 26) time; constant space. # With some work, could be O(#W * avg-len) * log2(#letters/26) # But since binary search has more overhead # than simple iteration, log2(#letters) is about as # expensive as simple iterations as long as # the length of the arrays for each letter is # \"small\". If letters are randomly present in the # search string, the log2 is about equal in speed to simple traversal # up to lengths of a few hundred characters. for word in sorted ( words , key = lambda w : len ( w ), reverse = True ): pos = 0 for letter in word : if letter not in letter_positions : break # Find any remaining valid positions in search string where this # letter appears. It would be better to do this with binary search, # but this is very Python-ic. possible_positions = [ p for p in letter_positions [ letter ] if p >= pos ] if not possible_positions : break pos = possible_positions [ 0 ] + 1 else : # We didn't break out of the loop, so all letters have valid positions return word if __name__ == '__main__' : print subdict ( sys . argv [ 1 ], sys . argv [ 2 :]) An optimal O(N + L) approach for any alphabet È¶ñÂÖàÊòØ‰∏Ä‰∏™Âü∫‰∫é‰∏äËø∞ÁÆóÊ≥ïÁöÑÔºåÈÄÇÁî®‰∫é S ÁöÑÈïøÂ∫¶‰∏çÈïøÁöÑÊÉÖÂÜµÁöÑ‰ºòÂåñÊñπÊ°à„ÄÇÊàë‰ª¨Â∞Ü p -> [2, 3, 4] ÊãìÂ±ïÊàê p -> [2, 2, 3, 4, -1, -1, -1, -1] ÔºåÂÖ∂‰∏≠ÂàóË°®ÁöÑÊØè‰∏™ÂÖÉÁ¥†ÂØπÂ∫î S ‰∏≠ËØ•‰ΩçÁΩÆÂêéÂá∫Áé∞ËØ•ÂàóË°®keyÁöÑÂ≠óÊØçÁöÑÂ∫èÂè∑ÔºàÂåÖÊã¨ËØ•‰ΩçÁΩÆÁöÑÂ∫èÂè∑Ôºâ„ÄÇÂ¶ÇÊûú‰∏çÂ≠òÂú®Â∞±‰ª• -1 Ë°®Á§∫„ÄÇËøôÊ†∑Êàë‰ª¨Â∞±‰∏çÁî®‰∫åÂàÜÊ≥ïÊù•Êü•ÊâæÂàóË°®Ôºå‰ΩÜÈöè‰πãÂ∏¶Êù•ÁöÑÈóÆÈ¢òÊòØÔºöÁÆóÊ≥ïÁöÑÂÆûÈôÖÂ§çÊùÇÂ∫¶Âèò‰∏∫O(N*A + L)Ôºå A ‰∏∫ S ÁöÑÂ≠óÊØçÈõÜÂêàÁöÑÈïøÂ∫¶ÔºåÂπ∂‰∏îÊ∂àËÄóOÔºàNAÔºâÁöÑÁ©∫Èó¥„ÄÇÂõ†Ê≠§ÂΩì S ËøáÈïøÊó∂Âπ∂Èùû‰∏Ä‰∏™ÂæàÂ•ΩÁöÑ‰ºòÂåñ„ÄÇ Èô§Ê≠§‰πãÂ§ñÔºåÊàë‰ª¨ËøòÂèØ‰ª•ÈÄöËøáÂêåÊó∂ÈÅçÂéÜÊâÄÊúâ D ‰∏≠ÁöÑÂçïËØçÊù•ÂéãÊ¶®Êàë‰ª¨ÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶„ÄÇÂ≠óÂÖ∏‰∏≠ÁöÑÊØè‰∏™ÂçïËØçÊîæÂÖ•(w,i)ÂÖÉÁªÑ„ÄÇÂÖ∂‰∏≠w‰∏∫ÂçïËØçÊú¨Ë∫´ÔºåiËÆ∞ÂΩï‰∫ÜÂ∫èÂè∑‰∏∫iÁöÑÂ≠óÊØçÂ∑≤ÁªèËææÊàêÂåπÈÖç„ÄÇËøôÊ†∑Êàë‰ª¨Â∞±ÂèØ‰ª•ÂΩ¢ÊàêÁ±ª‰ººËøôÊ†∑ÁöÑÊï∞ÊçÆÁªìÊûÑÔºö D = { \"able\" , \"ale\" , \"apple\" , \"bale\" , \"kangaroo\" } a -> [( \"able\" , 0 ), ( \"ale\" , 0 ), ( \"apple\" , 0 )] b -> [( \"bale\" , 0 )] k -> [( \"kangaroo\" , 0 )] Êàë‰ª¨ÈÅçÂéÜ S ‰∏≠ÁöÑÊØè‰∏™ÂÖÉÁ¥†Êó∂ÔºåÂ∞ÜÊâÄÊúâËØ•Â≠óÊØçkeyÂØπÂ∫îÂàóË°®ÈáåÁöÑÂÖÉÁªÑ t ÁöÑiÂ¢ûÂä†1ÔºåÂ∞ÜËøô‰∫õÂÖÉÁ¥†ÁßªÂà∞ t.w[t.i] ÂØπÂ∫îÁöÑÈîÆ‰∏ã„ÄÇÂΩìÊüê‰∏™ t ÁöÑiÁ≠â‰∫éwÁöÑÈïøÂ∫¶Êó∂ÂÆÉÂ∞±ÊòØ‰∏Ä‰∏™Á¨¶ÂêàÊù°‰ª∂ÁöÑÂçïËØçÔºåÂ∞ÜÂÆÉÁßªËá≥‰∏Ä‰∏™ÁªìÊûúÂàóË°®„ÄÇÊúÄÁªàÊàë‰ª¨ÊâæÂá∫Ëøô‰∏™ÂàóË°®‰∏≠ÁöÑÊúÄÈïøÂçïËØç„ÄÇËøô‰πàÂÅöÁöÑÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫O(W + N + W' * logW')ÔºåÂÖ∂‰∏≠ W' ‰∏∫ÁªìÊûúÈõÜ‰∏≠ÁöÑÂçïËØçÊï∞ÈáèÔºåÊúÄÂ∑ÆÁ≠â‰∫é W Ôºå‰ΩøÂæóÂÖ∂Â§çÊùÇÂ∫¶ÈùûÂ∏∏Êé•ËøëÁêÜËÆ∫ÊúÄ‰ºòÁöÑO(N + L)„ÄÇ‰ª£Á†ÅÂ¶Ç‰∏ãÔºö s = 'abppplee' d = [ 'able' , 'ale' , 'apple' , 'bale' , 'kangaroo' ] from collections import defaultdict Alphabets = defaultdict ( list ) for word in d : Alphabets [ word [ 0 ]] . append ([ word , 0 ]) def solution ( s , d ): result = '' for character in s : alphabet_list = Alphabets [ character ] for i in reversed ( range ( len ( alphabet_list ))): temp = alphabet_list . pop ( i ) temp [ 1 ] += 1 if len ( temp [ 0 ]) == temp [ 1 ]: if temp [ 1 ] >= len ( result ): result = temp [ 0 ] else : Alphabets [ temp [ 0 ][ temp [ 1 ]]] . append ( temp ) return result print ( solution ( s , d )) Additional","tags":"Python","title":"Find longest word in dictionary that is a subsequence of a given string"},{"url":"pyjion-python-debug-pandasyou-hua-bi-ji.html","text":"Description Brett CannonÂíåDino ViehlandÂú® Pycon2016 ÁöÑ Pyjion: who doesn't want faster for free? ÊºîËÆ≤‰∏≠‰ªãÁªç‰∫ÜMicrosoft‰∏∫cpythonÊèê‰æõJITÁöÑc++È°πÁõÆ Pyjion „ÄÇ‰πãÂêéÊàë‰πüÂú®talkpythonÁöÑÂæÄÊúüËÆøË∞à‰∏≠ÊâæÂà∞‰∏éBrett CannonÁöÑ Pyjion Áõ∏ÂÖ≥ÁöÑËÆøË∞àÔºåÂÖ∂‰∏≠ÁöÑÂæàÂ§öÁúãÊ≥ïËÆ©ÊàëÂ§ßÂèóËÑæÁõä„ÄÇ Elizaveta ShashkovaÂú® Pycon2017 ÁöÑ Debugging in Python 3 6 Better, Faster, Stronger ÊºîËÆ≤ÈùûÂ∏∏‰ª§‰∫∫Âç∞Ë±°Ê∑±Âàª„ÄÇÂ•πÂú®ÂºÄÂèëpycharmÁöÑJetBrainsÂÖ¨Âè∏Â∑•‰ΩúÔºåËÄåpycharmÂõ†‰∏∫ÂÆÉ‰ºòÁßÄÁöÑdebugÂäüËÉΩÊàê‰∏∫‰∫ÜÊàëÊúÄÂñúÊ¨¢ÁöÑIDEÔºåÊ≤°Êúâ‰πã‰∏Ä„ÄÇËôΩÁÑ∂‰øÑÁΩóÊñØËÄÅÂßêÊúâ‰∏ÄÁÇπÂè£Èü≥Ôºå‰ΩÜÂπ∂‰∏çÂΩ±ÂìçËøôÊòØ‰∏ÄÊ¨°ËÆ©‰∫∫ÊÑüÂà∞BingoÁöÑÊºîËÆ≤„ÄÇ ÂêåÊ†∑Âú® Pycon2017 ‰∏äÔºåÁæé‰∏ΩÁöÑSofia HeislerÂëäËØâ‰∫ÜÊàë‰ª¨ No More Sad Pandas Optimizing Pandas Code for Speed and Efficiency „ÄÇËøôÂêåÊ†∑‰πüÊòØ‰∏ÄÊ¨°Êó¢ÂÆûÁî®ËÄåÂèàËÆ©‰∫∫ËÉΩÂ≠¶Âà∞ÂæàÂ§öÊñ∞Áü•ÁöÑËÆ≤Ëß£ÔºåÈùûÂ∏∏È´òÂÖ¥ËÉΩÊúâÂæàÂ§ö‰ºòÁßÄÁöÑÂ•≥ÊÄßÂºÄÂèëËÄÖÂèÇ‰∏éÂà∞pycon‰∏≠Êù•„ÄÇ Pyjion Brett Cannon‰ªãÁªç‰∫ÜÂêÑÁßçpythonÂÆûÁé∞„ÄÇ IronPython Âíå Jython ÂàÜÂà´ÊòØpythonÂü∫‰∫éC#ÂíåJavaÁöÑÂÆûÁé∞ÔºåËøôÊ†∑ÂÆÉ‰ª¨Â∞±ÂèØ‰ª•ÂÖºÂÆπ.NetÂíåJavaÁöÑÂ∫îÁî®‰∫Ü„ÄÇ PyPy ÊòØÊàë‰πãÂâçÊØîËæÉÂÖ≥Ê≥®ÁöÑ‰∏Ä‰∏™ÂÆûÁé∞„ÄÇÂÆÉ‰∏ªË¶ÅÊúâ‰∏§ÈÉ®ÂàÜÁªÑÊàêÔºå‰∏ÄÊòØÂÆÉÊúâ‰∏ÄÁªÑ‰∏∫ÁºñÁ®ãËØ≠Ë®ÄÂÆöÂà∂JITÁöÑÂ∑•ÂÖ∑Ôºå‰Ω†‰∏ç‰ªÖÂèØ‰ª•‰∏∫pythonÊù•ÂÆûÁé∞JITÔºå‰πüÂèØ‰ª•Áî®Rpython‰∏∫ÂÖ∂‰ªñËØ≠Ë®ÄÂÜô‰∏Ä‰∏™JITÁöÑÂÆûÁé∞„ÄÇ‰∫åÊòØÂàöÂàöÊèêÂà∞ÁöÑRpythonÔºåËôΩÁÑ∂ PyPy ÊòØÁî±pythonÁºñÂÜôÁöÑÔºå‰ΩÜËøôÈáåÁöÑpythonÂÆûÈôÖ‰∏äÊòØpythonÁöÑË∂ÖÈõÜRpython„ÄÇRpythonÊòØÈùôÊÄÅÁ±ªÂûãÁâàÁöÑpythonÔºåÂõ†Ê≠§ËÉΩÁºñËØëÊàêc‰ª£Á†ÅÊèêÈ´òËøêË°åÁöÑÊïàÁéá„ÄÇ IronPython „ÄÅ Jython Âíå PyPy Êúâ‰∏Ä‰∏™ÂÖ±ÂêåÁöÑÈóÆÈ¢òÂ∞±ÊòØÊó†Ê≥ïÊúâÊïàÁöÑÂÖºÂÆπpythonÁöÑc apiÔºåËá¥‰Ωø‰ΩøÁî®ËÄÖÊó†Ê≥ïÂà©Áî®ÂæàÂ§ö‰ºòÁßÄÁöÑcÂ∫ì„ÄÇ IronPython Âíå Jython Áî±‰∫éÂÆÉ‰ª¨Âπ∂ÈùûÊòØcËØ≠Ë®ÄÂÆûÁé∞ÂÖ∑ÊúâÂ¶Ç‰∏äÂÖºÂÆπÊÄßÈóÆÈ¢òÈùûÂ∏∏ÂÆπÊòìÁêÜËß£Ôºå PyPy ÂàôÊòØÁî±‰∫é‰ΩøÁî®CFFIÊ®°ÂùóÁöÑÂéüÂõ†ÂØπc apiÂè™ÊúâÈÉ®ÂàÜÁöÑÊîØÊåÅ„ÄÇÂÉè NumPy ËøôÁßçÊ®°Âùó PyPy Âè™ËÉΩÂºÄ‰∏™Êñ∞ÁöÑÈ°πÁõÆÈáçÂÜôÔºåËøô‰πüÊòØ PyPy ‰Ωú‰∏∫ÊúÄÂø´ÁöÑPythonÂÆûÁé∞ËÄåÂæó‰∏çÂà∞ÁßëÂ≠¶ËÆ°ÁÆóÁ§æÂå∫ÂπøÊ≥õÂ∫îÁî®ÁöÑÂéüÂõ†ÊâÄÂú®„ÄÇ Pyston ÊòØDropboxËµûÂä©ÁöÑÈ°πÁõÆÔºåÂÆÉÁöÑÁõÆÊ†áÊòØÁî®JITÔºàLLVM JITÔºâÊèêÈ´òpythonËøêË°åÈÄüÂ∫¶ÁöÑÂêåÊó∂Â∞ΩÂèØËÉΩÂú∞ÂÖºÂÆπpythonÁöÑc extensionÔºåÂõ†Ê≠§ÂÆÉÂÜ≤Áî®‰∫ÜÂ§ßÈÉ®ÂàÜ CPython ÁöÑ‰ª£Á†Å„ÄÇ‰ΩÜÊØîËæÉÈÅóÊÜæÁöÑÊòØ Pyston Áé∞Âú®Âè™ÊîØÊåÅpython2.7ÁâàÊú¨„ÄÇ ËÄå Pyjion Â≠òÂú®ÁöÑÊÑè‰πâÂàôÊòØÁõ¥Êé•‰∏∫ Cpython Êèê‰æõJITÁöÑÂêåÊó∂ÂÖºÂÆπÊõ¥Â§öÁöÑc extension„ÄÇÂÆÉÁî±DinoÂèëËµ∑Ôºå‰ΩøÁî®c++ÁºñÂÜôÔºåÂçïÂêëÊîØÊåÅpython3ÁâàÊú¨„ÄÇÁé∞Âú®JITÊòØÂü∫‰∫écoreclrÂÆûÁé∞ÁöÑÔºå‰ΩÜÂú®ÊºîËÆ≤‰∏≠‰ªñ‰ª¨‰πüÊèêÂà∞ËøôÁßçÂÆûÁé∞‰πüÊòØÂèØ‰ª•‰Ωú‰∏∫‰∏Ä‰∏™ÂêéÂè∞Á≥ªÁªüÊõ¥Êç¢ÁöÑ„ÄÇ Brett Cannon‰πüÊèêÂà∞ÔºåpythonÁ§æÂå∫Êé®Âπøpython3ÁöÑÂÖ≥ÈîÆÊòØÊèêÈ´òpython3ÁöÑÈÄüÂ∫¶ÔºåÂõ†Ê≠§ÊúâÂæàÂ§öÊ†∏ÂøÉÂºÄÂèëËÄÖÂú®‰ªé‰∫ãËøôÊñπÈù¢ÁöÑÂ∑•‰ΩúÔºå Pyjion ‰πüÊòØÂÖ∂‰∏≠‰πã‰∏Ä„ÄÇÁ§æÂå∫Âú®Âª∫Á´ã‰∏Ä‰∏™ÂØπË±°ÁöÑÁºìÂ≠òÁ≥ªÁªüÔºöÈÄöËøáÂà§Êñ≠ÂØπË±°ÁöÑÁâàÊú¨Êù•Ëá™ÁúÅÂØπË±°ÊòØÂê¶Ë¢´ÊîπÂèòÔºåÂΩìÊú™ÊîπÂèòÂØπË±°Âú®ÁºìÂ≠ò‰∏≠Êó∂Êàë‰ª¨Â∞±‰∏çÁî®ÂØπÂëΩÂêçÁ©∫Èó¥ËøõË°åÂ±ÇÂ±ÇÁ≠õÈÄâÊù•Ëé∑ÂèñÂØπË±°‰∫Ü„ÄÇ Âè¶‰∏Ä‰∏™Ëá≥ÂÖ≥ÈáçË¶ÅÁöÑ‰ºòÂåñÂ∞±ÊòØ‰πãÂâç‰∏ÄÁØáÁ¨îËÆ∞‰∏≠ÊèêÂà∞ÁöÑÂèØËÉΩ‰ºöÂú®python3.7‰∏≠ÂÆûË£ÖÁöÑË∞ÉÁî®ÂáΩÊï∞ÈÄüÂ∫¶ÁöÑ‰ºòÂåñ„ÄÇË∞ÉÁî®ÂáΩÊï∞Áì∂È¢àÁöÑ‰∫ßÁîüÊòØÁî±‰∫épythonÁöÑÂ§öÁßçÂÖ•ÂèÇÂΩ¢ÂºèÔºà‰ΩçÁΩÆÂèÇÊï∞ÔºåÂÖ≥ÈîÆÂ≠óÂèÇÊï∞Ôºå argsÔºå * kwargsÔºåpython3‰∏≠Êñ∞Ê∑ªÂä†ÁöÑÂè™ÂÖÅËÆ∏ÂÖ≥ÈîÆÂ≠óÁöÑÂèÇÊï∞ÔºåÂáΩÊï∞Èó≠ÂåÖÔºâ„ÄÇËøô‰∫õÂÖ•ÂèÇÂΩ¢ÂºèÊòØÁöÑ‰∫ÜpythonÂú®ÂÖ∑Â§áÂä®ÊÄÅÊÄßÁöÑÂêåÊó∂‰∏ç‰∏ßÂ§±Â§™Â§öÂäüËÉΩÔºå‰ΩÜÂú®ÊûÑÂª∫ÂèÇÊï∞ÂàóË°®Êó∂Âàô‰ºöÂØπÁ≥ªÁªü‰∫ßÁîüÊûÅÂ§ßÂú∞Á¨¶Âêà„ÄÇYuriÈíàÂØπËøôÁßçÊÉÖÂÜµÂºÄÂºÄÂèë‰∫ÜÊñ∞ÁöÑÂä†ËΩΩÂÆû‰æãÊñπÊ≥ïÂíåË∞ÉÁî®ÂáΩÊï∞ÁöÑÂ≠óËäÇÁ†Å„ÄÇ Debug Pycharm‰∏≠ÁöÑdebugÂäüËÉΩÊòØÂü∫‰∫é sys.settrace ÂáΩÊï∞ÂÆåÊàêÁöÑ„ÄÇËÄåËÆæÁΩÆÊñ≠ÁÇπÁöÑÂäüËÉΩÂàôÊòØÂú®Êñ≠ÁÇπÂâçÊèíÂÖ•‰∏Ä‰∏™Â≠óËäÇÁ†ÅÁ∫ßÂà´ÁöÑÁõëÂê¨Áî®Êà∑ËæìÂÖ•ÁöÑÊ≠ªÂæ™ÁéØ„ÄÇÂú®Âä†ÂÖ•Êñ∞ÁöÑÂ≠óËäÇÁ†Å‰πãÂêéÔºåËøòÈúÄË¶ÅÊõ¥Êñ∞ÂéüÊúâÁöÑÂèòÈáèÂíåÂ≠óËäÇÁ†ÅÁöÑÂÅèÁßªÈáè„ÄÇÂΩìÊàë‰ª¨ dis Â¶Ç‰∏ãÂáΩÊï∞Êó∂Ôºö def maximun ( a , b ): if a > b : return a else : return b Â∞ÜÂæóÂà∞Ëøô‰∫õÂ≠óËäÇÁ†ÅÔºö 2 0 LOAD_FAST 0 ( a ) 2 LOAD_FAST 1 ( b ) 4 COMPARE_OP 4 ( > ) 6 POP_JUMP_IF_FALSE 12 3 8 LOAD_FAST 0 ( a ) 10 RETURN_VALUE 5 >> 12 LOAD_FAST 1 ( b ) 14 RETURN_VALUE 16 LOAD_CONST 0 ( None ) 18 RETURN_VALUE Êàë‰ª¨ÊÉ≥Ë¶ÅÂú® return a ËØ≠Âè•Ëøô‰∏ÄË°åÊâì‰∏äÊñ≠ÁÇπÊó∂ÔºåÊèíÂÖ•‰∫ÜÁ±ª‰ººËøôÊ†∑ÁöÑÂáΩÊï∞Ôºö def _stop_at_break (): # a lot of code here def breakpoint (): _stop_at_break () Â≠óËäÇÁ†Å‰∏∫Ôºö 0 LOAD_GLOBAL 0 (_stop_at_break) 2 CALL_FUNCTION 0 4 POP_TOP 6 LOAD_CONST 0 (None) 8 RETURN_VALUE Âú®python3.6‰πãÂâçÔºåÁî±‰∫éPycharm‰ΩøÁî®ÁöÑÊòØ sys.settrace ÔºåËøêË°åÁ®ãÂ∫èÊó∂ÊØè‰∏ÄË°åÈÉΩ‰ºöËß¶Âèë‰∏ÄÊ¨°traceÂáΩÊï∞ÔºåÂõ†Ê≠§Ë∞ÉËØïÊó∂ÁöÑËøêË°åÊó∂Èó¥Â∞Ü‰ºöÂ¢ûÂä†25ÂÄç„ÄÇDebug‰ΩøÂæóÊó∂Èó¥ÊïèÊÑüÁöÑÁ®ãÂ∫èÂ§±ÂéªÂáÜÁ°ÆÊÄß„ÄÇÂ•ΩÂú®python3.6‰∏≠ÈÉ®ÁΩ≤‰∫ÜPEP523‰∏≠ÁöÑframe evaluation api„ÄÇPEP523‰∏≠Êúâ‰∏§‰∏™‰∏ªË¶ÅÁöÑÂÜÖÂÆπ: Handle evaluation of frames Add a new field to code objects ‰∏∫‰∫ÜÊõ¥Â•ΩÁöÑËÆ©Êàë‰ª¨ÁêÜËß£ÔºåElizaveta ShashkovaÁªô‰∫ÜÊàë‰ª¨c codeÁöÑpythonÁâàÁ§∫‰æãÔºö def frame_eval ( frame , exc ): func_name = frame . f_code . co_name line_number = frame . f_lineno print ( line_number , func_name ) return _PyEval_EvalFrameDefault ( frame , exc ) def set_frame_eval (): state = PyThreadState_Get () state . interp . eval_frame = frame_eval ËøôÊ†∑Êàë‰ª¨Â∞±ÂèØ‰ª•Ë∞ÉÁî® set_frame_eval Êù•ÊúÄÁªàframe‰∫Ü„ÄÇÂÆÉÂè™Âú®ÊØèÊ¨°ËøõÂÖ•frameÊó∂ÂÄôËß¶ÂèëÔºåËÉΩÂ§ßÂ§ßÂáèÂ∞ëdebugËøêË°åÊó∂ÂÄôÁöÑÊïàÁéá„ÄÇ‰ΩÜÊòØÂΩìÂá∫Áé∞È¢ëÁπÅË∞ÉÁî®ÂáΩÊï∞Ëá¥‰ΩøËøõÂÖ•frameÁöÑÊ¨°Êï∞ËøáÂ§öÁöÑÊó∂ÂÄôÔºåÊàë‰ª¨ÁöÑdebugËøêË°åÊïàÁéáÂ∞Ü‰ºöÈÄÄÂåñÂà∞ sys.settrace ÁöÑÊ∞¥Âπ≥„ÄÇ ËøôÊó∂ÂÄôPEP523‰∏≠ÁöÑÁ¨¨‰∫åÁÇπÂ∞±ÂèØ‰ª•‰∏∫Êàë‰ª¨ÊâÄÁî®‰∫Ü„ÄÇËøô‰∏™ÁâπÊÄßÊãìÂ±ï‰∫Ü PyCodeObject ÁöÑÁªìÊûÑÔºåÂ¢ûÂä†‰∫Ü co_extra Â±ûÊÄß„ÄÇÂà©Áî®Ëøô‰∏™Â±ûÊÄßÊàë‰ª¨ÂèØ‰ª•‰ª•‰∏çÊèíÂÖ• breakpoint ÂáΩÊï∞ÁöÑÊñπÂºèÊù•Ê†áËÆ∞‰ª£Á†Å„ÄÇÁ§∫‰æã‰ª£Á†ÅÂ¶Ç‰∏ãÔºö def frame_eval ( frame , exc ): flag = _PyCode_GetExtra ( frame . f_code , index ) if flag == NO_BREAKS_IN_FRAME : return _PyEval_EvalFrameDefault ( frame , exc ) # check for breakpoints ÊúÄÁªàÁöÑÊïàÁéáÊèêÂçáÊÉÖÂÜµÂ§ßËá¥Â¶Ç‰∏ãÔºö Pandas Sofia HeislerÊµãËØïÁöÑÂáΩÊï∞Â¶Ç‰∏ã,ÊµãËØïÊï∞ÊçÆÊñá‰ª∂ Âú®Ê≠§ Ôºö def haversine ( lat1 , lon1 , lat2 , lon2 ): miles_constant = 3959 lat1 , lon1 , lat2 , lon2 = map ( np . deg2rad , [ lat1 , lon1 , lat2 , lon2 ]) dlat = lat2 - lat1 dlon = lon2 - lon1 a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * np . sin ( dlon / 2 ) ** 2 c = 2 * np . arcsin ( np . sqrt ( a )) mi = miles_constant * c return mi Êàë‰ª¨Âà©Áî®Âà©Áî®Jupyter notebookÁöÑ %%timeit È≠îÊúØÊñπÊ≥ïÂèä line_profiler Êù•Ë∑ëÂàÜ„ÄÇÈ¶ñÂÖàÊàë‰ª¨Áî®Âæ™ÁéØÁöÑÊñπÂºèÊù•ÈÅçÂéÜÊï¥‰∏™df: %% timeit ### Haversine applied on rows via iteration haversine_series = [] for index , row in df . iterrows (): haversine_series . append ( haversine ( 40.671 , - 73.985 , \\ row [ 'latitude' ], row [ 'longitude' ])) df [ 'distance' ] = haversine_series ÂæóÂà∞ÁöÑÁªìÊûúÊòØ 197 ms ¬± 6.65 ms per loop (mean ¬± std. dev. of 7 runs, 1 loop each) „ÄÇ ‰πãÂêéÊòØapplyÊñπÊ≥ïÔºö % timeit df [ 'distance' ] = \\ df . apply ( lambda row : haversine ( 40.671 , - 73.985 , \\ row [ 'latitude' ], row [ 'longitude' ]), axis = 1 ) ÂæóÂà∞ÁöÑÁªìÊûúÊòØ 78.1 ms ¬± 6.65 ms per loop (mean ¬± std. dev. of 7 runs, 10 loop each) „ÄÇÂ¶ÇÊûúÁî® line_profiler Êù•ËøõË°åÂàÜÊûêÔºåÂ∞±‰ºöÂèëÁé∞ÊÄßËÉΩÁì∂È¢àÊù•Ëá™‰∫éÈ¢ëÁπÅË∞ÉÁî®ÂáΩÊï∞ÁöÑÁ¨¨‰∏âË°åÂíåÁ¨¨ÂÖ≠Ë°å„ÄÇ Êé•‰∏ãÊù•Êàë‰ª¨Â∞ÜÊï∞ÊçÆÂêëÈáèÂåñ„ÄÇÂú®Pandas‰∏≠ÁöÑÂêëÈáèÂåñÊòØÂ¶ÇÊ≠§ÁöÑÁÆÄÂçïÔºö ### Vectorized implementation of Haversine applied on Pandas series % timeit df [ 'distance' ] = haversine ( 40.671 , - 73.985 , \\ df [ 'latitude' ], df [ 'longitude' ]) Ë∑ëÂàÜÁöÑÁªìÊûúÊòØ 2.21 ms ¬± 230 ¬µs per loop (mean ¬± std. dev. of 7 runs, 100 loops each) „ÄÇË∞ÉÁî® line_profiler ÂêéÂèëÁé∞ÂáΩÊï∞Á¨¨‰∏âË°åÁöÑÊâßË°åÈ¢ëÁéá‰∏ãÈôçÂà∞‰∫ÜÂíåÂÖ∂‰ªñËØ≠Âè•Âêå‰∏ÄÊï∞ÈáèÁ∫ßÔºà529)ÔºåÁ¨¨ÂÖ≠Ë°å‰πü‰ªé‰∏Ä‰∏áÂÖ≠ÂçÉÂ§öÊ¨°‰∏ãÈôçÂà∞‰∫Ü‰∏âÂçÉ‰∫îÁôæÂ§öÊ¨°„ÄÇ‰ΩÜËøôËøò‰∏çÊòØÊúÄ‰ºòÁöÑÁªìÊûú„ÄÇ ‰πãÂêéÊàë‰ª¨Â∞ÜËæìÂÖ•Áî±pd.SeriesÂèò‰∏∫np.ndarrayÔºåÂáèÂ∞ë‰∫ÜPandas SeriesÁ¥¢ÂºïÂèäÊ£ÄÊü•Êï∞ÊçÆÁ±ªÂûãÁ≠âÂºÄÈîÄ: ### Vectorized implementation of Haversine applied on NumPy arrays % timeit df [ 'distance' ] = haversine ( 40.671 , - 73.985 , \\ df [ 'latitude' ] . values , df [ 'longitude' ] . values ) ÂæóÂà∞ÁöÑÁªìÊûúÊòØ 370 ¬µs ¬± 18 ¬µs per loop (mean ¬± std. dev. of 7 runs, 1000 loops each) „ÄÇ Sofia HeislerÊúÄÂêéÁöÑÂÆûÈ™åÊòØÁî®CythonÊù•‰ºòÂåñÂáΩÊï∞Êú¨Ë∫´ÁöÑËøêÁÆóÈÄüÂ∫¶„ÄÇÂõ†‰∏∫Â¶ÇÊûúÊúâ‰∫õÂéüÂõ†Êàë‰ª¨‰∏çËÉΩÂ∞ÜÊï∞ÊçÆÂêëÈáèÂåñ‰∫¶ÊàñËÄÖÂêëÈáèÂåñÊó†Ê≥ïË°®ËææÂá∫ÂéüÊúâÁöÑ‰∏öÂä°ÈÄªËæëÔºåÈÇ£‰πàÊàë‰ª¨Â∞±ÂøÖÈ°ªËø≠‰ª£Êàë‰ª¨ÁöÑÊï∞ÊçÆÈõÜ‰∫Ü„ÄÇ‰∏∫‰∫ÜÊèêÈ´òÊïàÁéáÊàë‰ª¨Â∞ÜÂéüÂáΩÊï∞ÂÜôÊàêËøôÊ†∑ÁÑ∂ÂêéÁî® apply Ëø≠‰ª£Ôºö %% cython - a ### Haversine cythonized from libc.math cimport sin , cos , acos , asin , sqrt cdef deg2rad_cy ( float deg ): cdef float rad rad = 0.01745329252 * deg return rad cpdef haversine_cy_dtyped ( float lat1 , float lon1 , float lat2 , float lon2 ): cdef : float dlon float dlat float a float c float mi lat1 , lon1 , lat2 , lon2 = map ( deg2rad_cy , [ lat1 , lon1 , lat2 , lon2 ]) dlat = lat2 - lat1 dlon = lon2 - lon1 a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2 c = 2 * asin ( sqrt ( a )) mi = 3959 * c return mi % timeit df [ 'distance' ] = \\ df . apply ( lambda row : haversine_cy_dtyped ( 40.671 , - 73.985 , \\ row [ 'latitude' ], row [ 'longitude' ]), axis = 1 ) Â∞ΩÁÆ°Â¶ÇÊ≠§ÔºåË∑ëÂàÜÁöÑÁªìÊûúËøòÊòØ‰∏çÂ¶ÇÊàë‰ª¨ÁöÑÂêëÈáèÂåñ 51.1 ms ¬± 2.74 ms per loop (mean ¬± std. dev. of 7 runs, 10 loops each) „ÄÇ ÊúÄÁªàÁöÑÂÆûÈ™åÁªìÊûúÂ¶Ç‰∏ãÔºö Additional","tags":"Python","title":"Pyjion„ÄÅpython debug„ÄÅpandas‰ºòÂåñÁ¨îËÆ∞"},{"url":"instagram-python-migrationbi-ji.html","text":"Description Lisa GuoÂíåHui DingÂú® Pycon2017 ÁöÑ keynote ÂàÜ‰∫´‰∫ÜInstagramÊàêÂäü‰ªépython2.7„ÄÅDjango1.3ÂçáÁ∫ßÂà∞python3.6„ÄÅDjango1.8ÁöÑÁªèÂéÜ„ÄÇ Âú®Talk Python fm‰πãÂâçÁöÑepisode‰∏≠ÔºåÊàëÊÉäÂñúÂú∞ÂèëÁé∞‰∫ÜÊúâ‰∏ÄÊúüMichael KennedyÈÇÄËØ∑Âà∞‰∫Ü David Beazley „ÄÇÂú®Âì™‰∏ÄÊúüËäÇÁõÆ‰∏≠‰ªñ‰ª¨ÁïÖË∞à‰∫Üpython concurrencyÁõ∏ÂÖ≥ÂèäDavidÂú®Github‰∏äÁöÑasyncÈ°πÁõÆ Curio „ÄÇ Instagram ÂæàÈöæÊÉ≥Ë±°InstagramËÉΩÂú®‰øùÊåÅ‰∫ßÂìÅÂäüËÉΩÈ´òÈÄüËø≠‰ª£ÁöÑÂêåÊó∂ÂÆåÊàê‰ªépython2.7ÁâàÊú¨Âà∞3.5ÁâàÊú¨ÁöÑË∑®Ë∂ä„ÄÇ‰ªñ‰ª¨Âú®ÁâàÊú¨Êõ¥Êñ∞ÈÄî‰∏≠Âú®‰ª£Á†ÅÂ±ÇÈù¢ÈÅáÂà∞ÁöÑ‰∏ªË¶ÅÊúâ‰ª•‰∏ãÂá†Á±ªÈóÆÈ¢ò„ÄÇ Unicode Python3ÊúÄÊòæËëóÁöÑÊîπÂä®Â∞±ÊòØ‰∏•Ê†ºÂåñ‰∫ÜUNICODE/STR/BYTEÁöÑËΩ¨Êç¢„ÄÇInstagramÁºñÂÜô‰∫Ü‰∏Ä‰∫õÂäüËÉΩÂáΩÊï∞Ôºà ensure_binary , ensure_str , ensure_text ÔºâÊù•Á°Æ‰øù‰πãÂâç‰ª£Á†ÅÈáåÁöÑËæìÂÖ•ÂíåËæìÂá∫Á¨¶Âêàpython3ÁöÑÊ†áÂáÜ„ÄÇ Data format incompatible Âú®Instagram‰∏≠ÁªèÂ∏∏Áî®Âà∞‰∫Ü pickle Ê®°Âùó„ÄÇËØ•Ê®°ÂùóÂú®python2Âíå3‰∏≠ÁöÑÂå∫Âà´ÊòØÔºöpython3ÁöÑpickleÁöÑÂçèËÆÆÊúÄÈ´òÁâàÊú¨ÊèêÂçáÂà∞‰∫Ü4„ÄÇ‰ªñ‰ª¨ÂèëÁé∞Âç≥‰ΩøÂ∞ÜÂçèËÆÆÁâàÊú¨hardcodeÂà∞python2ÈáåÁöÑ2ÔºåÁî±‰∫éÁâàÊú¨2Âíå3ÁöÑÂêåÊó∂Â≠òÂú®Ôºå‰ªñ‰ª¨‰πãÈó¥ÁöÑÁõ∏‰∫íÂ∫èÂàóÂåñÁöÑËΩ¨Âåñ‰πü‰ºöÂ≠òÂú®ÈóÆÈ¢ò„ÄÇÂõ†Ê≠§‰ªñ‰ª¨Â∞Ü‰∏çÂêåÁâàÊú¨ÁöÑpickleÁªìÊûúÈöîÁ¶ªÔºåÂÅöÂà∞Ëá™ÂèñËá™Êãø„ÄÇ Iterator Python3‰∏≠ÁöÑËÆ∏Â§öÂáΩÊï∞ÁöÑËøîÂõûÂÄºË¢´‰øÆÊîπÊàê‰∫ÜËø≠‰ª£Âô®Ôºà map , filter , dict.item ÔºâÔºåËø≠‰ª£Âô®‰ΩøÂæóInstagram‰∏≠ÈÇ£‰∫õ‰ºöÈÅçÂéÜ‰∏§ÈÅçËøô‰∫õÂáΩÊï∞ËøîÂõûÁªìÊûúÁöÑ‰ª£Á†ÅÂÖ®ÈÉ®Â§±Êïà„ÄÇËøôÂÖ∂ÂÆûÈùûÂ∏∏Èöæ‰ª•Ë∞ÉËØïÔºåÂõ†Ê≠§‰ªñ‰ª¨È¶ñÂÖàÂ∞ÜÊâÄÊúâËØ•Á±ªÂáΩÊï∞ÁöÑËøîÂõûÂÄºÁî® list ÊñπÊ≥ïËøòÂéüÊàêÂàóË°®ÔºåÁÑ∂ÂêéÂ∞Ü‰ºòÂåñÂè™Ëø≠‰ª£‰∏ÄÈÅçÁöÑÂÆû‰æã„ÄÇ Dictionary ordering ‰πãÂâçÁöÑ‰∏ÄÁØánote ‰πüËÆ≤ËøáÔºåÁî±‰∫épythonÂ≠óÂÖ∏ÁöÑÁâàÊú¨ÊîπÂä®ÔºåÂ≠óÂÖ∏‰∏≠ÁöÑËøîÂõûÂÄºÂ∞ÜÂ§ßÂ§ß‰∏çÂêå„ÄÇ testdict = { 'a' : 1 , 'b' : 2 , 'c' : 3 } json . dumps ( testdict ) ÂêÑÁâàÊú¨ÁöÑËøîÂõûÁªìÊûúÂ§ßËá¥‰∏∫Ôºö python2 : { 'a' : 1 , 'c' : 2 , 'b' : 3 } ( hardcode hashcode ) python3 . 5 . 1 : ( random ) python3 . 6 Ôºö{ 'a' : 1 , 'b' : 2 , 'c' : 3 } ( keep order ) ‰∏∫‰∫ÜËøΩÊ±ÇÂÖºÂÆπÊÄßÔºå‰ªñ‰ª¨ÂØπ json.dumps ÂáΩÊï∞Âä†‰∫ÜÂèÇÊï∞Ôºö json . dumps ( testdict , sort_keys = True ) Âè¶Â§ñ‰ªñ‰ª¨‰πüÊèêÂà∞‰∫Ü‰ª•‰∏ãÁöÑ‰∏Ä‰∏™Â∞èÁöÑUnicodeÁöÑÊîπÂä®Â∞ÜInstagramÁöÑÊÄßËÉΩÊèêÂçá‰∫Ü12%Ôºö if uwsgi . opt . get ( 'optimize_men' , None ) == 'True' optimize_men () to if uwsgi . opt . get ( 'optimize_men' , None ) == b 'True' optimize_men () Êú™Êù•‰ªñ‰ª¨ËÆ°Âàí‰ΩøÁî®‰∫Üpython3ÂÆåÂñÑÂ•ΩÁöÑÁâπÊÄßtype hintsÂíåmypyÊù•ÊèêÈ´ò‰ªñ‰ª¨codebaseÁöÑÂÅ•Â£ÆÊÄßÔºå‰ΩøÁî®asyncioÂ∫ìÁî®ÂºÇÊ≠•Êù•Â§ÑÁêÜ‰πãÂâçÁöÑ‰∏Ä‰∫õÁ∫øÁ®ãÊìç‰Ωú„ÄÇ Curio David Beazley‰∏ÄÁõ¥ÊòØ‰∏Ä‰ΩçÊàëÈùûÂ∏∏ÂñúÊ¨¢ÁöÑpythonÊéà‰∏öËÄÖÔºåÂêåÊó∂‰πüÊòØpython cookbookÁöÑ‰ΩúËÄÖ„ÄÇ‰ªñÂú®ËøôÊ¨°ËÆøË∞à‰∏≠ÊèêÂà∞‰∫ÜÂú®python‰∏≠ÂÆûÁé∞asyncÁöÑÂè¶‰∏ÄÁßçÊÄùË∑ØÔºå‰πüÂ∞±ÊòØ‰ªñÂÜô Curio Â∫ìÁöÑÁõÆÁöÑ„ÄÇ Âú®‰ª•ÊïôÊéàpython‰∏∫‰∏ö‰πãÂâçÔºå‰ªñÊòØÊïôËÆ°ÁÆóÊú∫ÁßëÂ≠¶Á≥ªÊìç‰ΩúÁ≥ªÁªüËØæÁ®ãÁöÑÊïôÊéà„ÄÇÂú®ËØæ‰∏ä‰ªñ‰ºöÂëäËØâÂ≠¶Áîü‰ª¨Â¶Ç‰ΩïÁî®CËØ≠Ë®ÄÊù•ÂÜôÊìç‰ΩúÁ≥ªÁªüÁöÑÂÜÖÊ†∏ÔºåÂÜÖÊ†∏ÂÅöÁöÑ‰∫ãÊÉÖ‰∏ªË¶ÅÂ∞±ÊòØÂ§ö‰ªªÂä°ÁÆ°ÁêÜÂíåIOÔºåËøôÂíå asyncio Â∫ìÊâÄÂÅöÁöÑÈùûÂ∏∏Áõ∏‰ºº„ÄÇÊó¢ÁÑ∂ asyncio Â∫ìËÉΩÂ∞Ü callback , futures , coroutine Á•ûÂ•áÂú∞ÁªÑÂêàÊàê‰∏Ä‰∏™Â•áÂ¶ôÁöÑ‰ªªÂä°ÁÆ°ÁêÜÁ≥ªÁªüÔºå‰∏∫‰ªÄ‰πàÊàë‰ª¨‰∏çËÉΩÊ®°‰ªøÁ≥ªÁªüÂÜÖÊ†∏‰πüÂéªÂÆûÁé∞‰∏Ä‰∏™‰ªªÂä°ÁÆ°ÁêÜÁ≥ªÁªüÂë¢ÔºüÊú¨Ë∫´asyncÁºñÁ®ã‰πüÊòØ‰∏Ä‰∏™ÁÑïÂèëÁ¨¨‰∫åÊò•ÁöÑÊóßÊÉ≥Ê≥ï„ÄÇ David‰πüÊèêÂà∞ÔºåÁî±‰∫épython3.5‰∏≠ async/await ÂÖ≥ÈîÆÂ≠óÁöÑÂä†ÂÖ•Ôºå‰ªñ‰πãÂâçÁöÑËÆ∏Â§öÊºîËÆ≤ÂíåÊïôÁ®ãÈÉΩÊúâ‰∫õËøáÊó∂‰∫Ü„ÄÇËøô‰Ωø‰ªñËßâÂæóÔºåÊàë‰ª¨ÊàñËÆ∏‰∏çËØ•ÂÖ≥Ê≥®ayncÂ∫ïÂ±ÇÂà∞Â∫ïÊòØÂ¶Ç‰ΩïÂÆûÁé∞ÁöÑÔºöÊó†ËÆ∫ÊòØÁî® callback ËøòÊòØÁî®ÂÖ∂‰ªñÊäÄÊúØÔºåËÄåÊòØÂÖ≥Ê≥®Êàë‰ª¨ËØ•Â¶Ç‰ΩïÂà©Áî®asyncÁºñÁ®ãÊàñËÄÖËØ¥ÊòØasyncÂ∫îËØ•Âú®ÁöÑÁöÑÈ¢ÜÂüü„ÄÇ ÂèØËÉΩÁé∞Âú®asyncÊúÄÂ§ßÁöÑÈóÆÈ¢òÂ∞±ÊòØÂÆÉÁöÑ‰º†ÊüìÊÄßÔºå‰∏ÄÊó¶‰Ω†‰ª£Á†Å‰∏≠ÁöÑ‰∏ÄÈÉ®ÂàÜÂèòÊàêasyncÔºåÊãøÂÆÉÊâÄÂØπÂ∫îÁöÑÊï¥‰∏™‰ª£Á†ÅÁîüÊÄÅÈìæ‰πüÂøÖÈ°ªÊòØasyncÁöÑÔºåÂê¶ÂàôÂ∞èÂ∞èÁöÑ‰∏ÄÊÆµÂêåÊ≠•‰ª£Á†ÅÂ∞±‰ºöÈòªÂ°ûÊï¥‰∏™Á®ãÂ∫è„ÄÇËôΩÁÑ∂Ê≤°ÊúâÁâπÂà´Â§∏Âº†Ôºå‰ΩÜÊòØÂØπ‰∫éÁ∫øÁ®ãÁºñÁ®ãÊù•ËØ¥ÔºåËøô‰∏ÄÁÇπÁ°ÆÂÆûÊòØÂÄºÂæóËÄÉËôëÁöÑ„ÄÇËôΩÁÑ∂asyncioÂ∫ìÊèê‰æõ‰∫Ü‰∏Ä‰∏™ÂáΩÊï∞‰Ωú‰∏∫ÂØπasync‰∏≠Á∫øÁ®ãÁöÑÊîØÊåÅÔºå‰ΩÜÊòØÂπ∂Ê≤°ÊúâÂ∞ÜÁ∫øÁ®ãÁ∫≥ÂÖ• eventloop Â§ÑÁêÜÁöÑËåÉÁï¥‰πã‰∏≠Ôºå coroutine ‰πü‰∏çÊòØÁ∫øÁ®ãÂÆâÂÖ®ÁöÑ„ÄÇDavidÁöÑËÆæÊÉ≥Â∞±ÊòØÂú®‰∏çËøúÁöÑÂ∞ÜÊù•ËÉΩÂ∞ÜÁ∫øÁ®ãÂíåasyncÁªü‰∏ÄÁªìÂêàËµ∑Êù•Ôºå‰ΩøÂæó eventloop ËÉΩÂêåÊó∂ÂÖº‰ªªÂú∞Â§ÑÁêÜÂçèÁ®ãÂíåÁ∫øÁ®ãÔºåËøôÊ†∑ÂØπasyncÁöÑÊú™Êù•ÂÆöÊòØÂ§ßÊúâË£®Áõä„ÄÇ‰∫ãÂÆû‰∏äDavidÂú® Curio ‰∏≠Â∑≤ÁªèÂÆåÊàê‰∫Ü‰∏Ä‰∏™Áªü‰∏ÄÈòüÂàóÁöÑÁªÑ‰ª∂Ôºàuniversal queue objectÔºâ‰Ωú‰∏∫Á∫øÁ®ãÂíåÂçèÁ®ãÁöÑ‰∫§ÊµÅÂ™í‰ªã„ÄÇ Additional","tags":"Python","title":"Instagram python migrationÁ¨îËÆ∞"},{"url":"python-asyncdictionarymachine-learning-moudlesbi-ji.html","text":"Description Jesse Jiryu DavisÂú® Pycon2014 ÁöÑÊºîËÆ≤ A. Jesse Jiryu Davis: What Is Async, How Does It Work, And When Should I Use It? ÂàÜÊûê‰∫Ü‰∏∫‰ªÄ‰πà‰ª•ÂèäÂú®‰ªÄ‰πàÊÉÖÂÜµ‰∏ãË¶ÅÁî®ÂºÇÊ≠•ÁöÑÊñπÂºèÂ§ÑÁêÜio„ÄÇ‰πãÂâçÂú® 300line ÈáåÔºå‰ªñÂíåGuidoÂêàËëóÁöÑasync crawlerÈÉ®ÂàÜÈáåÂ∞±‰ªãÁªç‰∫Ü‰ΩøÁî®ÂçèÁ®ãÁõ∏ÂØπÁ∫øÁ®ãÁöÑ‰ºòÂäøÔºöÂú®pythonÈáåÁ∫øÁ®ãÈúÄË¶Å50KÁöÑÂÜÖÂ≠òÔºåËÄåÂçèÁ®ãÂè™ÈúÄË¶Å3K„ÄÇÂú®ËØ•ÊºîËÆ≤‰∏≠Ôºå‰ªñËøõ‰∏ÄÊ≠•ÈòêËø∞‰∫ÜÂçèÁ®ãÁöÑ‰ºòÂäøÂèäÂ∫îÁî®Âú∫ÊôØ„ÄÇ Raymond HettingerÂú® Pycon2017 ÁöÑÊºîËÆ≤ Modern Python Dictionaries A confluence of a dozen great ideas ÂíåBrandon RhodesÁöÑ The Dictionary Even Mightier ÁöÑ‰∏ªÈ¢òÊòØpythonÂ≠óÂÖ∏Âú®3.6ÁâàÊú¨ÁöÑÊûÅÂ§ßÊîπËøõÔºöÂáèÂ∞ë20%-30%ÁöÑÂÜÖÂ≠òÂç†Áî®Âèä‰øùÊåÅÂÖÉÁ¥†ÁöÑÊèíÂÖ•È°∫Â∫è„ÄÇ TalkPython ‰∏≠Pete GarcinÁöÑËÆøË∞à Top 10 machine learning libraries ‰ªãÁªç‰∫ÜÁõÆÂâçÊúÄÊµÅË°åÁöÑÂçÅ‰∏™Êú∫Âô®Â≠¶‰π†Â∫ìÔºåË∞àËÆ∫‰∫ÜÂÆÉ‰ª¨ÁöÑÂºÇÂêå‰ª•ÂèäÂàùÂ≠¶ËÄÖÁöÑÂ≠¶‰π†Ë∑ØÂæÑ„ÄÇ Async Jesse‰∏æ‰∫ÜÁ∫ΩÁ∫¶‰∏âÁßçÈ§êÂéÖÁöÑ‰æãÂ≠ê‰Ωú‰∏∫‰∏âÁßç‰∏çÂêåÂú∫ÊôØ„ÄÇ Á¨¨‰∏Ä‰∏™ÊòØ‰∏âÊòéÊ≤ªÂïÜÂ∫ó„ÄÇÈ°æÂÆ¢Âà∞ÊüúÂè∞ÊéíÈòüÔºåÂé®Â∏àÊé•Âà∞ËÆ¢ÂçïÂ∞±ÂºÄÂßãÂà∂‰Ωú‰∏âÊòéÊ≤ªÁõ¥Âà∞ÂÆåÊàê‰∏âÊòéÊ≤ª„ÄÇËøô‰∏™‰æãÂ≠êÊèèËø∞ÁöÑÊòØcpuÂØÜÈõÜÂûãÊúçÂä°ÁöÑÊú∫Âà∂ÔºåËøôÈáåÊ≤°Êúâ‰πüÊó†Ê≥ï‰ΩøÁî®ÂºÇÊ≠•Êú∫Âà∂ÔºåÊï¥‰∏™ÊúçÂä°ÁöÑÂêûÂêêÈáèÂèóÂà∞ËÆ°ÁÆóËÉΩÂäõÁöÑÈôêÂà∂„ÄÇ Á¨¨‰∫å‰∏™ÊòØÊä´Ëê®Â∫ó„ÄÇÈ°æÂÆ¢ÁÇπÂçïÂêéÔºåÂé®Â∏àÈúÄË¶ÅÂ∞ÜÂà∂‰ΩúÂ•ΩÁöÑÊä´Ëê®Áî®ÂæÆÊ≥¢ÁÇâÂä†ÁÉ≠Âêé‰∫§ÁªôÈ°æÂÆ¢„ÄÇÁî±‰∫éÈúÄË¶ÅÁ≠âÂæÖÊä´Ëê®ÁöÑÂä†ÁÉ≠ÔºåÂõ†Ê≠§Â∞±Êúâ‰∫ÜÂºÇÊ≠•Êìç‰ΩúÁöÑÂøÖË¶ÅÊÄß„ÄÇËøôÁßçÊúçÂä°ÁöÑÂêûÂêêÈáèÂèóÂà∞ÂÜÖÂ≠òÁöÑÈôêÂà∂ÔºåÊúçÂä°Âô®‰πüÈúÄË¶ÅÂêéÂè∞Êù•Â§ÑÁêÜpendingÁöÑËØ∑Ê±Ç„ÄÇ Á¨¨‰∏â‰∏™ÊòØ‰∏ÄÁßçÂØøÂè∏Â∫ó„ÄÇÂú®ËøôÈáåÈ°æÂÆ¢ÁöÑÈúÄÊ±ÇÁî±ÊúçÂä°ÂëòÂëäÁü•Âé®ÊàøÔºåÂêåÊó∂Âé®ÊàøÂÆåÊàêÁöÑÂØøÂè∏‰πüÈúÄË¶ÅÊúçÂä°Âô®ÈÄÅÂà∞ÂÆ¢Êà∑Èù¢Ââç„ÄÇÁé∞ÂÆû‰∏≠ËøôÊ†∑ÊúçÂä°ÁöÑ‰æãÂ≠êÂ∞±ÊòØË∞∑Ê≠åÈÇÆÁÆ±ÊúçÂä°ÔºöÂΩìÂÆ¢Êà∑ÁôªÂΩïË∞∑Ê≠åÈÇÆÁÆ±‰πãÂêéÂπ∂‰∏ç‰ºöÂÅöÂ§™Â§öÂä®‰ΩúÔºåÂΩìÂÆ¢Êà∑Êî∂Âà∞ÈÇÆ‰ª∂ÁöÑËøô‰∏Ä‰∫ã‰ª∂ÂèëÁîüÁöÑÊó∂ÂÄôÊúçÂä°Âô®Êâç‰ºöÂ∞ÜÊï∞ÊçÆÊé®Âà∞ÂÆ¢Êà∑ÁöÑÈù¢Ââç„ÄÇËøôÂ∞±Ëá¥‰Ωø‰∫ÜÂ§ßÈáèÈïøËøûÊé•ÁöÑ‰∫ßÁîü„ÄÇËøô‰∫õÈìæÊé•Â§ßÈÉ®ÂàÜÁöÑÊó∂Èó¥Â§Ñ‰∫éÁ©∫Èó≤Áä∂ÊÄÅÔºåÂ¶ÇÊûúÂØπÊØè‰∏™ÈìæÊé•ÈÉΩÂàõÂª∫‰∏Ä‰∏™Á∫øÁ®ãÁöÑËØùÂæàÂø´Â∞±‰ºöÊ∂àËÄóÂÆåÁ≥ªÁªüÁöÑÂÜÖÂ≠ò„ÄÇËÄåÂºÇÊ≠•Ê≠£ÊòØ‰∏∫‰∫ÜÊúÄÂ∞èÂåñÊØè‰∏™ÈìæÊé•Ê∂àËÄóÁöÑËµÑÊ∫êËÄåËØûÁîüÁöÑ„ÄÇ ÂçèÁ®ãÁõ∏ÂØπÁ∫øÁ®ãÂè¶‰∏Ä‰∏™Âå∫Âà´‰∏é‰ºòÁÇπÂ∞±ÊòØÔºåÂΩìÊàë‰ª¨ËøõË°åÂ§öÁ∫øÁ®ãÁºñÁ®ãÊó∂Ë¶ÅÊó∂Êó∂Ê≥®ÊÑèÁ´ûÊÄÅÔºåÂØºËá¥Êàë‰ª¨‰∏çÂæó‰∏çÁî®ÈîÅÊù•ÊéßÂà∂ÂÖ±‰∫´ËµÑÊ∫ê„ÄÇËøôÊòØÁî±‰∫éÁ∫øÁ®ãÊòØÁ®ãÂ∫èÂëòÂπ∂Ê≤°ÊúâÂØπÁ∫øÁ®ãÁöÑÂÆåÂÖ®ÊéßÂà∂ÊùÉÂØºËá¥ÁöÑÔºåÊàë‰ª¨Âπ∂‰∏çËÉΩÁü•ÈÅìÁ∫øÁ®ã‰ªÄ‰πàÊó∂ÂÄôÂàáÊç¢Ôºå‰ªÄ‰πàÊó∂ÂÄôËøêË°åÂíåÈòªÂ°û‚Äî‚ÄîÊàë‰ª¨Â∞ÜËøô‰∫õÈÉΩ‰∫§ÁªôÊìç‰ΩúÁ≥ªÁªüÊù•ÂÆåÊàê‰∫Ü„ÄÇËÄåÂçèÁ®ãÂàôÂè™‰ºöÂú®yieldÂ§ÑÊöÇÂÅúÂíåÊé•ÂèóËæìÂÖ•ÔºåÊàë‰ª¨ÂÆåÂÖ®ÂèØ‰ª•ÊéßÂà∂Êï¥‰∏™ÂºÇÊ≠•ËøáÁ®ã„ÄÇ Âú®ÊºîËÆ≤ÁöÑÊúÄÂêéÔºåJesseÂëäËØâ‰∫ÜÊàë‰ª¨Âì™Á±ªÊúçÂä°ÈÄÇÂêàasyncËÄåÂì™Á±ª‰∏çÈÄÇÂêàÔºö ‰ªñËÆ§‰∏∫Á¨¨‰∫åÂíåÁ¨¨‰∏âÁßçÁ±ªÂûãÁöÑÊúçÂä°ÊòØÈÄÇÂêàasyncÁöÑÊúçÂä°„ÄÇËøôÈáå‰πü‰πüÊåáÂá∫‰∫ÜasyncÁöÑ‰∏çË∂≥‰πãÂ§ÑÔºåasyncË¶ÅÊ±ÇÊúçÂä°Â§ÑÁêÜÊó∂Ëá≥‰∏äËÄå‰∏ãÊØè‰∏ÄÈÉ®ÂàÜÈÉΩÊòØÂºÇÊ≠•ÁöÑ„ÄÇÂõ†Ê≠§Êàë‰ª¨ÁöÑDB driver‰πüÈúÄË¶ÅÊîØÊåÅÂºÇÊ≠•ÔºåÂê¶ÂàôÂÆÉÂ∞Ü‰ºöÈòªÂ°ûÊï¥‰∏™Á®ãÂ∫è„ÄÇËøòÊúâ‰∏ÄÁÇπÔºåasyncÁ®ãÂ∫è‰∏éÁ∫øÁ®ãÁºñÁ®ãÂ∞Ü‰ºöÈùûÂ∏∏‰∏çÂêåÔºåÂõ†Ê≠§ÂΩì‰Ω†Ë¶ÅÂÆûÁé∞‰∏Ä‰∏™ÂºÇÊ≠•ÊúçÂä°Êó∂Ôºå‰∏Ä‰∏™async‰∏ìÂÆ∂ÊòØÂøÖ‰∏çÂèØÂ∞ëÁöÑ„ÄÇ Dictionary in 3.6 Brandon RhodesÂú®‰ªñÁöÑÊºîËÆ≤‰∏≠ÊèêÂà∞‰∫ÜÂçÅÂá†Âπ¥Êù•pythonÂºÄÂèëËÄÖ‰∏∫‰∫Ü‰ΩøÂ≠óÂÖ∏Ë∂äÊù•Ë∂ä‰∫∫ÊÄßÂåñÊâÄÂÅöÁöÑÂä™ÂäõÔºö - Âú®python2.6‰πãÂâçÂ≠óÂÖ∏Ê≤°ÊúâÁ±ª‰ººÂàóË°®Êé®ÂØºÂºèÁöÑÂäüËÉΩÔºåpythonÂú®3‰∏≠Âä†ÂÖ•‰∫ÜÂ≠óÂÖ∏Êé®ÂØºÂºèÂπ∂‰∏îÂõûÊé®Áªô‰∫Ü2.7Ôºå‰ΩøÂæóÂ≠óÂÖ∏‰∏çÂÜçÊòØ‰∏Ä‰∏™Êé®ÂØºÂºèÁöÑÁâπ‰æã - Â≠óÂÖ∏ÁöÑ keys() Á≠âÂáΩÊï∞ÂèòÊàê‰∫ÜÁîüÊàêÂô®„ÄÇ‰∏∫‰∫ÜÂíå‰ª•ÂâçÁöÑÂÄüÂè£ÔºåËøòÂÆûÁé∞‰∫Ü __contains__ , __sub__ , __and__ , __xor__ , isdisjoint , __iter__ ÊñπÊ≥ï„ÄÇËøôÁÇπ‰πüÂæóÁõä‰∫épythonÂçèËÆÆÂºèÁöÑËÆæËÆ°„ÄÇ - ÂÜÖÂ≠òÂÖ±‰∫´„ÄÇÂêå‰∏Ä‰∏™Á±ªÁöÑÂ§ö‰∏™ÂÆû‰æãÂú®ÂÜÖÂ≠ò‰∏≠ÂÖ±‰∫´Áõ∏ÂêåÁöÑ hashcode Âíå key ÁöÑÂÇ®Â≠òÔºå‰ΩøÂæópythonËøêË°åÊó∂ÂàªÁöÑÂ≠óÂÖ∏ÂÜÖÂ≠òÂç†Áî®ÂáèÂ∞ë‰∫Ü10%-20%„ÄÇÂ≠óÂÖ∏ÂàõÂª∫Âú®‰∏Ä‰∏™Á±ªÁöÑÁ¨¨‰∏Ä‰∏™ÂÆû‰æã __init__ Êó∂ÔºåÂõ†Ê≠§Êàë‰ª¨Âª∫ËÆÆÂú®Á±ªÁöÑ __init__ ‰∏≠ÂàùÂßãÂåñÂÖ®ÈÉ®ÂèØËÉΩÂ∞ÜË¶ÅÁî®Âà∞ÁöÑÂÆû‰æãÂèòÈáèÔºåÂê¶ÂàôÊñ∞ÁöÑÂèòÈáèË¢´Ê∑ªÂä†Êó∂ÂÄôÂ∞Ü‰ºöÁî®‰πãÂâçÊú∫Âà∂ÁöÑÂèòÈáèÂ≠óÂÖ∏Ôºå‰ªéËÄåÂØºËá¥Êó†Ê≥ï‰∫´ÂèóÂÜÖÂ≠òÂÖ±‰∫´ÁöÑ‰ºòÂäø„ÄÇ - python‰∏∫‰∫ÜÈò≤Ê≠¢Âõ†‰∏∫hash conflictËÄåÂºïËµ∑ÁöÑDOSÊîªÂáªÔºåÂú®3.3ÁâàÊú¨‰∏≠Â∞ÜhashÊñπÊ≥ïÁöÑÂõ†Â≠êËÆæÁΩÆ‰∏∫‰∏Ä‰∏™ÈöèÊú∫ÂÄºÔºåÂõ†Ê≠§Êàë‰ª¨ÊØèÊ¨°‰ªéresizeÂêéÁöÑÂ≠óÂÖ∏‰∏≠ÂèñÂÄºÊó∂Â∞Ü‰ºöÁöÑÂà∞‰∏çÂêåÈ°∫Â∫èÁöÑÊï∞ÂÄº„ÄÇ - SipHashÊòØpython3.4-3.6ÁâàÊú¨‰∏≠ÂØπÈöèÊú∫hashÁöÑÊõø‰ª£„ÄÇ - ÂèóÊï∞ÊçÆÂ∫ìÂèäÁ¥¢ÂºïÁöÑÂêØÂèëÔºåRaymond HettingerÂú®python3.6ÁâàÊú¨‰∏≠ÈÉ®ÁΩ≤‰∫ÜÊñ∞ÁöÑÂ≠óÂÖ∏Êú∫Âà∂„ÄÇÂéüÂÖàÁöÑÂ≠óÂÖ∏Êú∫Âà∂Â∞Ü‰ºö‰ΩøÂ≠óÂÖ∏ÂìàÂ∏åË°®‰øùÊåÅ1/3ÁöÑÁ©∫Èó¥Êù•ÂáèÂ∞ëhash conflitÁöÑ‰∫ßÁîü„ÄÇËøôÊ†∑ÊØè‰∏™Á©∫Èó≤ÈîÆÂÄºÂØπÂ∞Ü‰ºö‰∫ßÁîü24ÊØîÁâπÁöÑÂÜÖÂ≠òÊµ™Ë¥π„ÄÇÊñ∞ÁöÑÊú∫Âà∂Áî®‰∏Ä‰∏™Á¥¢ÂºïÊï∞ÁªÑÊú∫Âà∂ÂéªÈô§‰∫ÜËøô‰∫õÁ©∫Èó¥ÁöÑÊµ™Ë¥πÂπ∂‰∏î‰ΩøÂæóÂ≠óÂÖ∏‰∏≠ÁöÑÈîÆÂÄºÂØπÂú®Â≠óÂÖ∏resizeÂêé‰πüËÉΩ‰øùÊåÅÈîÆÂÄºÂØπÁöÑÂéüÊú¨ËæìÂÖ•È°∫Â∫è„ÄÇËøô‰∏™Êú∫Âà∂Áõ∏ËæÉ‰∫é3.5ÁâàÊú¨ËÉΩÂáèÂ∞ëÂ≠óÂÖ∏20%Ëá≥25%ÁöÑÂÜÖÂ≠ò‰ΩøÁî®„ÄÇ - Áé∞Âú®ÊØè‰∏™Â≠óÂÖ∏‰ºöÊúâ‰∏™ÁâàÊú¨ÔºåËøôÊ†∑Êàë‰ª¨Â§ÑÁêÜÂΩìÁõ∏ÂêåÁâàÊú¨ÁöÑÂ≠óÂÖ∏Êó∂Â∞±‰∏çÁî®‰ªéÂ§¥ÈÅçÂéÜÊØè‰∏Ä‰∏™Â≠óÂÖ∏‰∫Ü„ÄÇ dit = { - 1 : 'a' } for i in range ( 27 , 20 , - 1 ): dit [ i ] = i print ( list ( dit . keys ())) for i in range ( 6 , 20 ): dit [ i ] = i print ( list ( dit . keys ())) ‰ª•‰∏äËøôÊÆµ‰ª£Á†ÅÂú®python2.7‰∏≠Áî±‰∫éresizeÂèØËÉΩ‰ºöÂæóÂà∞‰ª•‰∏ãÁöÑÁªìÊûúÔºö [ 21 , 22 , 23 , 24 , 25 , 26 , 27 , - 1 ] [ 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , - 1 ] ËÄåÂú®pytho3.6‰∏≠ÂàôËÉΩ‰øùÊåÅÂÖÉÁ¥†ÂΩïÂÖ•ÁöÑÈ°∫Â∫èÔºö [ - 1 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ] [ - 1 , 27 , 26 , 25 , 24 , 23 , 22 , 21 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 ] Machine learning libraries Âú®Ëøô‰∏™Ë∞àËØù‰∏≠ÔºåMichael KennedyÂíåPete GarcinË∞àËÆ∫‰∫Ü‰ªñ‰ª¨ËÆ§‰∏∫ÁöÑpythonÊúÄÂ•ΩÁöÑÂçÅ‰∏™Â∫ì„ÄÇ - Numpy Âíå Scipy ÊòØ‰∏ÄÂàáÊ®°ÂùóÁöÑÂü∫Á°Ä„ÄÇ - Scikit-learn ÊòØ‰∏Ä‰∏™ËæÉÊó©ÁöÑÊ®°ÂùóÔºåÊòØ Scipy ÂÆ∂ÊóèÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇÂÆÉÊèê‰æõÁªô‰∫ÜÊàë‰ª¨‰∏Ä‰∫õÂ∏∏Áî®ÁöÑÊú∫Âô®Â≠¶‰π†ÁÆóÊ≥ïÂíåÂàÜÁ±ªÔºåËÅöÁ±ªÔºåÂõûÂΩíÔºåÊ®°ÂûãÂ∑•ÂÖ∑„ÄÇÂÆÉÈùûÂ∏∏ÁÆÄÊòéÁõ¥Êé•Ôºå‰ΩÜÁº∫Â∞ëÂØπGPUËøêÁÆóÁöÑÊîØÊåÅ„ÄÇ - Keras ÊòØ‰∏Ä‰∏™ÊØîËæÉÊñ∞ÁöÑhigh-levelÊ®°ÂùóÔºåÂèØ‰ª• Theano , Tensorflow , CNTK ‰∏≠ÁöÑ‰ªªÊÑè‰∏Ä‰∏™Ê®°Âùó‰Ωú‰∏∫ÂêéÂè∞„ÄÇÂÆÉÁöÑËÆæËÆ°ÁõÆÊ†áÊòØÊú∫Âô®Â≠¶ÊúüÁ®ãÂ∫èÁöÑÂø´ÈÄüÂºÄÂèëÔºåÂõ†Ê≠§ÂÖ∑ÊúâÊûÅÈ´òÁöÑÊòìÁî®ÊÄß„ÄÇ - Tensorflow ÊòØÁé∞Âú®ÁÉ≠Â∫¶ÊúÄÈ´òÁöÑÊú∫Âô®Â≠¶‰π†Ê®°ÂùóÔºåÂÆÉËÉΩÂÖÖÂàÜÂà©Áî®GPUÁöÑÁü©ÈòµÂèäÂπ∂Ë°åËÆ°ÁÆó‰ºòÂäø„ÄÇËÄå‰ªéGoogleË¶ÅÊé®Âá∫TPUËøô‰∏Ä‰∏æÊé™Êù•ÁúãÔºåGoogle‰πüÊ≠£Âú®Â§ßÂäõÊé®ÂπøËøô‰∏ÄÊ®°Âùó„ÄÇ - Theano ÊØîËæÉËÄÅËøàÔºå‰πüÊòØÂêå Tensorflow ‰∏ÄÊ†∑ÁöÑlow-levelÁöÑÊú∫Âô®Â≠¶‰π†Ê®°Âùó„ÄÇÁî±‰∫éÂÆÉÁöÑÊ†∏ÂøÉÂºÄÂèëÈÉΩË∑ëÂéªË∞∑Ê≠å‰∫ÜÔºåÊâÄ‰ª•ÂÆÉÂíå Tensorflow ÂÖ∂ÂÆûÈùûÂ∏∏Áõ∏ÂÉè„ÄÇ - Èô§‰∫ÜÊú∫Âô®Â≠¶‰π†ÁÆóÊ≥ïÔºå‰∏∫‰∫ÜËé∑ÂæóÂπ≤ÂáÄÁöÑÊï∞ÊçÆÔºåÊàë‰ª¨‰πüÈúÄË¶Å Pandas Êù•Â∏ÆÂä©Êàë‰ª¨Â§ÑÁêÜÁü©ÈòµÊï∞ÊçÆ„ÄÇÂÆÉ‰πüÊòØ Scipy ÂÆ∂ÊóèÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇ - Caffe Âíå Caffe2 ÊòØÁî±FacebookÂú®ËÉåÂêéÊîØÊåÅÁöÑÊú∫Âô®ËßÜËßâÈ°πÁõÆ„ÄÇÂÆÉ‰ª¨ÈíàÂØπ‰∫íËÅîÁΩëÂèäÁßªÂä®ÈÉ®ÁΩ≤ÂÅö‰∫ÜÁõ∏ÂØπÁöÑ‰ºòÂåñ„ÄÇ - Jupyter ÊîπÂèò‰∫ÜÊï∞ÊçÆÁßëÂ≠¶ÂÆ∂‰ª¨‰∫§ÊµÅÂíåÂèëË°®Á†îÁ©∂ÊàêÊûúÁöÑÊñπÂºè„ÄÇ - CNTK ÊòØÂæÆËΩØÊúÄÊñ∞ÁöÑÊú∫Âô®Â≠¶‰π†Ê®°ÂùóÔºåÊìÖÈïølow-levelÁöÑËÆ°ÁÆóÔºåÂ¶ÇÊúâÂêëÂõæ„ÄÇ - NLTK ÊòØ‰∏Ä‰∏™Áõ∏ÂØπÊàêÁÜüËá™ÁÑ∂ËØ≠Ë®ÄÂ§ÑÁêÜÊ®°ÂùóÔºåÊìÖÈïøÊñáÊú¨ÂàÜÊûêÂíåÂ§ÑÁêÜ„ÄÇ Pete GarcinÊúÄÂêéÂêëÂàùÂ≠¶ËÄÖÊé®Ëçê‰∫Ü Keras ‰Ωú‰∏∫‰∫ÜËß£Êú∫Âô®Â≠¶‰π†ÁöÑÂÖ•Âè£„ÄÇ Additional","tags":"Python","title":"Python asyncÔºådictionaryÔºåmachine learning moudlesÁ¨îËÆ∞"},{"url":"python-yield-tutorial-markdown.html","text":"Description Êú¨ÊñáÊòØÊàëÁöÑ jupyter notebook ÁöÑmarkdownÁâàÊú¨„ÄÇ An introduction to Python yield WHAT A function and a generater def fun (): return 'fun' def gen (): yield 'gen' fun () 'fun' gen () <generator object gen at 0x0000000007503780> A range() like example for ... in range() loop is used quite often when iterating objects in python . In below example, we made a generator to mock range() function. def counter ( top ): n = 0 while n < top : yield n n += 1 for i in counter ( 10 ): print ( i ) 0 1 2 3 4 5 6 7 8 9 Under the covers Generator object runs in response to next() or send() def counter_sample ( top ): n = 0 while n < top : print ( '-> before yield' ) yield n print ( '-> after yield' ) n += 1 c = counter_sample ( 5 ) print ( next ( c )) -> before yield 0 StopIteration raised when function returns print ( c . send ( None )) -> after yield -> before yield 1 Create coroutine with yield You can send data to a coroutine. def generator (): item = yield print ( 'item = {} ' . format ( item )) yield 10 Prime the coroutine g = generator () g . send ( None ) Send data value = g . send ( 20 ) item = 20 print ( 'value = {} ' . format ( value )) value = 10 A coroutine which receives data as well as produces data def averager (): total , count , average = 0.0 , 0 , None while True : term = yield average total += term count += 1 average = total / count avg = averager () avg . send ( None ) avg . send ( 10 ) 10.0 avg . send ( 20 ) 15.0 avg . send ( 30 ) 20.0 Three features of coroutines: - When a coroutine run into yield , it will suspend - A caller should schedule the coroutine when it suspended - When a coroutine suspended, it will return control to the caller WHY A tornado example import time import tornado.ioloop import tornado.web import tornado.gen class BadStupidHandler ( tornado . web . RequestHandler ): def get ( self ): for i in range ( 20 ): self . write ( ' {} <br>' . format ( i )) self . flush () time . sleep ( 0.5 ) class GoodStupidHandler ( tornado . web . RequestHandler ): @tornado . gen . coroutine def get ( self ): for i in range ( 20 ): self . write ( ' {} <br>' . format ( i )) self . flush () yield tornado . gen . sleep ( 0.5 ) app = tornado . web . Application ([ ( r '/bad' , BadStupidHandler ), ( r '/good' , GoodStupidHandler ) ]) Refer to documentation Frequently Asked Questions . HOW Use coroutine to simplfy your context manager A context manager is to change: try : f = open ( 'some.txt' ) print ( f . readline ()) # do something with f finally : f . close () coroutine To: with open ( 'some.txt' ) as f : print ( f . readline ()) # do something with f coroutine You can define your own context manager with a class implements __enter__ and __exit__ method class Mirror : def __init__ ( self , num ): self . num = num def __enter__ ( self ): import sys def reverse_write ( text ): self . original_write ( text [:: - 1 ]) self . original_write = sys . stdout . write sys . stdout . write = reverse_write return 'This is mirror {} ' . format ( self . num ) def __exit__ ( self , exc_type , exc_value , traceback ): import sys sys . stdout . write = self . original_write with Mirror ( 1000 ) as first_string : print ( first_string ) print ( 123456789 ) print ( 'Out there' ) 0001 rorrim si sihT 987654321 Out there Use decorator contextlib.contextmanager and generator to simplfy your own context manager import contextlib @contextlib . contextmanager def Mirror_new ( num ): import sys def reverse_write ( text ): original_write ( text [:: - 1 ]) original_write = sys . stdout . write sys . stdout . write = reverse_write yield 'This is mirror {} ' . format ( num ) sys . stdout . write = original_write with Mirror_new ( 1000 ) as first_string : print ( first_string ) print ( 123456789 ) print ( 'Out there' ) 0001 rorrim si sihT 987654321 Out there How does it work? We define a warpper class to proxy our generator: class GeneratorCM : def __init__ ( self , func ): self . _func = func def __call__ ( self , * args , ** kwargs ): self . _gen = self . _func ( * args , ** kwargs ) return self def __enter__ ( self ): return self . _gen . send ( None ) def __exit__ ( self , exc_type , exc_value , traceback ): try : self . _gen . send ( None ) except StopIteration : return True @GeneratorCM def Mirror_custom ( num ): import sys original_write = sys . stdout . write def reverse_write ( text ): original_write ( text [:: - 1 ]) sys . stdout . write = reverse_write yield 'This is mirror {} ' . format ( num ) sys . stdout . write = original_write with Mirror_custom ( 1000 ) as first_string : print ( first_string ) print ( 123456789 ) print ( 'Out there' ) 0001 rorrim si sihT 987654321 Out there GeneratorCM with full try catch is listed below: class GeneratorCM : def __init__ ( self , func ): self . _func = func def __call__ ( self , * args , ** kwargs ): self . _gen = self . _func ( * args , ** kwargs ) return self def __enter__ ( self ): return self . _gen . send ( None ) def __exit__ ( self , exc_type , exc_value , traceback ): try : if exc_type is None : next ( self . _gen ) else : self . _gen . throw ( exc_type , exc_value , traceback ) raise RuntimeError ( \"Generator didn't stop\" ) except StopIteration : return True except : if sys . exc_info ()[ 1 ] is not exc_value : raise Inlined yield Following statement is very common in tornado framwork from tornado import gen @gen . coroutine def fetch_coroutine ( url ): http_client = AsyncHTTPClient () response = yield http_client . fetch ( url ) raise gen . Return ( response . body ) How does it work? First,define a slow function to mock http.fetch : import time import random def func ( x , y ): sleep_time = random . random () * 3 time . sleep ( sleep_time ) print ( 'sleep for {} seconds' . format ( sleep_time )) return x + y We need to our function work like this: from concurrent.futures import ThreadPoolExecutor , Future pool = ThreadPoolExecutor ( max_workers = 8 ) @inlined_future def do_func(x, y): result = yield pool.submit(func, x, y) print('Got:', result) Inspired by @contextmanagerÔºö import wrapt class Task : def __init__ ( self , gen ): self . _gen = gen initive = Future () initive . set_result ( None ) self . step ( initive ) def step ( self , future ): try : next_future = self . _gen . send ( future . result ()) except StopIteration as exc : if exc . value is not None : raise exc else : next_future . add_done_callback ( self . step ) @wrapt . decorator def inlined_future ( wrapped , instance , args , kwargs ): Task ( wrapped ( * args , ** kwargs )) @inlined_future def do_func ( x , y ): result = yield pool . submit ( func , x , y ) print ( 'Got:' , result ) def do_func_slow ( x , y ): result = func ( x , y ) print ( 'Got:' , result ) for i in range ( 5 ): do_func_slow ( i , i ) sleep for 2.4873064812324777 seconds Got: 0 sleep for 1.4432468827933995 seconds Got: 2 sleep for 1.9532320529696823 seconds Got: 4 sleep for 0.584825861467138 seconds Got: 6 sleep for 1.8091265383050155 seconds Got: 8 for i in range ( 5 ): do_func ( i , i ) Additional: How coroutine work import dis import inspect def gen_fn (): result = yield 1 print ( 'result of yield: {} ' . format ( result )) result2 = yield 2 print ( 'result of 2nd yield: {} ' . format ( result2 )) return 'done' def normal_fn (): return 1 a = gen_fn () a . send ( None ) 1 gen_fn <function __main__.gen_fn> normal_fn <function __main__.normal_fn> bool ( gen_fn . __code__ . co_flags & inspect . CO_GENERATOR ) True bin ( inspect . CO_GENERATOR ) '0b100000' bool ( normal_fn . __code__ . co_flags & inspect . CO_GENERATOR ) False gen1 = gen_fn () type ( gen1 ) generator gen1 . gi_code . co_name 'gen_fn' All generators from calls to gen_fn point to this same code. But each has its own stack frame. This stack frame is not on any actual stack, it sits in heap memory. gen2 = gen_fn () gen1 . gi_code is gen2 . gi_code True gen1 . gi_frame is gen2 . gi_frame False gen1 . send ( None ) gen1 . gi_frame . f_lasti 2 dis . dis ( gen1 ) 5 0 LOAD_CONST 1 ( 1 ) 2 YIELD_VALUE 4 STORE_FAST 0 ( result ) 6 6 LOAD_GLOBAL 0 ( print ) 8 LOAD_CONST 2 ( 'result of yield: {}' ) 10 LOAD_ATTR 1 ( format ) 12 LOAD_FAST 0 ( result ) 14 CALL_FUNCTION 1 16 CALL_FUNCTION 1 18 POP_TOP 7 20 LOAD_CONST 3 ( 2 ) 22 YIELD_VALUE 24 STORE_FAST 1 ( result2 ) 8 26 LOAD_GLOBAL 0 ( print ) 28 LOAD_CONST 4 ( 'result of 2nd yield: {}' ) 30 LOAD_ATTR 1 ( format ) 32 LOAD_FAST 1 ( result2 ) 34 CALL_FUNCTION 1 36 CALL_FUNCTION 1 38 POP_TOP 9 40 LOAD_CONST 5 ( 'done' ) 42 RETURN_VALUE gen1 . send ( 'hello' ) gen1 . gi_frame . f_lasti result of yield : hello 22 gen1 . gi_frame . f_locals {'result': 'hello'} gen1 . send ( 'world' ) result of 2 nd yield : world --------------------------------------------------------------------------- StopIteration Traceback ( most recent call last ) < ipython - input - 124 - b432c08ca417 > in < module > () ----> 1 gen1.send('world') StopIteration : done sleep for 0 . 9637312558255126 seconds Got : 8 sleep for 1 . 0164703671835906 seconds Got : 2 sleep for 1 . 0941822049442602 seconds Got : 4 sleep for 2 . 2731928774129755 seconds Got : 0 sleep for 2 . 4067928659249773 seconds Got : 6 Reference Generators: The Final Frontier Effective PythonÔºöConsider Coroutines to Run Many Functions Concurrently Python Cookbook 3: ‰∏çÁî®ÈÄíÂΩíÂÆûÁé∞ËÆøÈóÆËÄÖÊ®°Âºè 500 line or less:A Web Crawler With asyncio Coroutines ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊñáÊú¨Ëß£ÊûêËÆ°ÁÆóÂô®","tags":"Python","title":"Python yield tutorial markdown"},{"url":"pythonla-ji-chu-li-ji-zhi.html","text":"Description Êú¨ÊñáÁéØÂ¢É‰∏∫python3.6„ÄÇ‰∏éc‰∏≠Êã•ÊúâÁöÑmallocÂíåfree‰∏çÂêåÔºåpython‰∏≠ÁöÑÂÜÖÂ≠òÊòØÁºñËØëÂô®Ëá™Âä®ÂÆåÊàêÔºåÂõ†Ê≠§Êàë‰ª¨Âπ∂‰∏çÈúÄË¶ÅÊó∂ÂàªÂÖ≥ÂøÉÂÜÖÂ≠òÁöÑ‰ΩøÁî®ÊÉÖÂÜµ„ÄÇÂú® Things you need to know about garbage collection in Python ‰∏ÄÊñá‰∏≠ÁªôÊàë‰ª¨ËØ¶ÁªÜ‰ªãÁªç‰∫Üpython gcÁöÑÂÖ∑‰ΩìÂÆûÁé∞ÂèäÁªÜËäÇÔºåÊú¨Êñá‰∏ªË¶ÅÂèÇËÄÉËØ•ÂçöÂÆ¢Êù•ÂØπpythonÂûÉÂúæÂ§ÑÁêÜÊú∫Âà∂ÂÅö‰∏Ä‰∫õÊÄªÁªì„ÄÇ ÂÜÖÂ≠òÁÆ°ÁêÜ Âú®python‰∏≠Â∞è‰∫é512kÁöÑÂØπË±°ÊòØ‰ºöÂú®ÂÜÖÂ≠ò‰∏≠ÁºìÂ≠òÁöÑÔºåËøôÂ∞±ÂØºËá¥Â∞è‰∫é256ÁöÑÊï¥ÂΩ¢Âèä‰∏Ä‰∫õÁü≠Â≠óÁ¨¶‰∏≤Âú®Á®ãÂ∫è‰∏≠ÂÆûÈôÖÂÖ±‰∫´‰∫ÜÂêå‰∏Ä‰∏™ÂÜÖÂ≠òÂú∞ÂùÄ„ÄÇÂÉèËøôÊ†∑Ôºåpython‰∏∫‰∫ÜÊèêÈ´òÂØπÂÜÖÂ≠òÊìç‰ΩúÁöÑÊïàÁéáÂèäÂáèÂ∞ëÁ¢éÁâáÔºåÂú®ÈÄöÁî®ÂÜÖÂ≠òÂàÜÈÖçÂô®‰∏äÂÅáËÆæ‰∫Ü‰∏Ä‰∏™ÁâπÊÆäÁöÑÁÆ°ÁêÜÂô®‚Äî‚Äî‚Äî‚Äî PyMalloc „ÄÇÂú® cpython ‰∏≠ÔºåÂÜÖÂ≠òÊ®°ÂûãË¢´ÂΩ¢ÂÆπ‰∏∫Â§ßËá¥Â¶Ç‰∏ãÔºö _____ ______ ______ ________ [ int ] [ dict ] [ list ] ... [ string ] Python core | +3 | <----- Object-specific memory -----> | <-- Non-object memory --> | _______________________________ | | [ Python's object allocator ] | | +2 | ####### Object memory ####### | <------ Internal buffers ------> | ______________________________________________________________ | [ Python's raw memory allocator (PyMem_ API) ] | +1 | <----- Python memory (under PyMem manager's control) ------> | | __________________________________________________________________ [ Underlying general-purpose allocator (ex: C library malloc) ] 0 | <------ Virtual memory allocated for the python process -------> | ========================================================================= _______________________________________________________________________ [ OS-specific Virtual Memory Manager (VMM) ] -1 | <--- Kernel dynamic storage allocation & management (page-based) ---> | __________________________________ __________________________________ [ ] [ ] -2 | <-- Physical memory: ROM/RAM --> | | <-- Secondary storage (swap) --> | python‰∏≠Âç†Áî®ÂÜÖÂ≠òËæÉÂ§ßÁöÑÂØπË±°‰ºöË¢´ÂàÜÈÖçÂà∞Ê†áÂáÜÁöÑcÂÜÖÂ≠òÂàÜÈÖçÂô®ÔºåÂ∞èÂØπË±°ÂàÜÈÖçÂô®ÂàôÁî±‰∏â‰∏™Á∫ßÂà´ÁöÑÊäΩË±°ÊûÑÊàê Arena „ÄÅ Pool „ÄÅ Block „ÄÇ Block BlockÔºàÂùóÔºâÊòØÂõ∫ÂÆöÂ§ßÂ∞èÔºà8-512kÔºâÁöÑÂÜÖÂ≠òÂùó„ÄÇ‰∏∫‰∫ÜÊñπ‰æøËµ∑ËßÅÔºåËøô‰∫õÂùóË¢´ÂàÜ‰∏∫64Á±ªÔºö Request in bytes Size of allocated block size class idx 1-8 8 0 9-16 16 1 17-24 24 2 25-32 32 3 33-40 40 4 41-48 48 5 ... ... ... 505-512 512 63 Pool PoolÔºàÊ±†ÔºâÊòØÁõ∏ÂêåÂ§ßÂ∞èBlockÔºàÂùóÔºâÁöÑÈõÜÂêà„ÄÇÈÄöÂ∏∏Êù•ËØ¥ÔºåÊ±†ÁöÑÂ§ßÂ∞èÁ≠â‰∫éÂÜÖÂ≠òÈ°µÁöÑÂ§ßÂ∞è„ÄÇÂõ∫ÂÆöÂùóÁöÑÂ§ßÂ∞èËÉΩÂáèÂ∞ëÂÜÖÂ≠òÁ¢éÁâáÁöÑ‰∫ßÁîü‚Äî‚Äî‚Äî‚ÄîÂΩì‰∏Ä‰∏™ÂØπË±°Ë¢´ÈîÄÊØÅÁöÑÊó∂ÂÄôÔºåÂÜÖÂ≠òÁÆ°ÁêÜÂô®ËÉΩËΩªÊùæÂú∞Â∞ÜÁõ∏ÂêåÂ§ßÂ∞èÁöÑÂØπË±°Ë£ÖËΩΩÂÖ•Âùó‰∏≠„ÄÇ Âú®cpython‰∏≠ÔºåÊ±†Ë¢´ÂÆö‰πâ‰∏∫Â¶Ç‰∏ãÁªìÊûÑÔºö /* Pool for small blocks. */ struct pool_header { union { block * _padding ; uint count ; } ref ; /* number of allocated blocks */ block * freeblock ; /* pool's free list head */ struct pool_header * nextpool ; /* next pool of this size class */ struct pool_header * prevpool ; /* previous pool \"\" */ uint arenaindex ; /* index into arenas of base adr */ uint szidx ; /* block size class index */ uint nextoffset ; /* bytes to virgin block */ uint maxnextoffset ; /* largest valid nextoffset */ }; Ê±†‰ΩøÁî®ÁöÑÊòØÂèåÂêëÈìæË°®ÁöÑÁªìÊûÑÔºå nextpool Âíå prevpool Â≠óÊÆµÊåáÂêëÈìæË°®ËäÇÁÇπ„ÄÇ szidx Â≠óÊÆµ‰øùÂ≠ò‰∫Ü‰∏äÊñáÊèêÂà∞ÁöÑËØ•Ê±†ÁöÑÂ§ßÂ∞èÁ±ªÂà´ÁöÑÂ∫èÂè∑Ôºàsize class indexÔºâÔºåËÄå ref.count Â≠óÊÆµÂàôÂÇ®Â≠ò‰∫ÜË¢´Âç†Áî®‰∫ÜÁöÑÂùóÁöÑÊï∞Èáè„ÄÇ arenaindex ÂÇ®Â≠ò‰∫ÜËØ•Ê±†Âú®ÊâÄÂú®ÁöÑÂÜÖÂ≠òÁ©∫Èó¥ÁöÑÂ∫èÂè∑„ÄÇÂØπ‰∫é freeblock ÂàôÊòØËøô‰πàËß£ÈáäÁöÑÔºö pool -> freeblock points to the start of a singly - linked list of free blocks within the pool . When a block is freed , it 's inserted at the front of its pool' s freeblock list . Note that the available blocks in a pool are * not * linked all together when a pool is initialized . Instead only \"the first two\" ( lowest addresses ) blocks are set up , returning the first such block , and setting pool -> freeblock to a one - block list holding the second such block . This is consistent with that pymalloc strives at all levels ( arena , pool , and block ) never to touch a piece of memory until it 's actually needed. So long as a pool is in the used state, we' re certain there * is * a block available for allocating , and pool -> freeblock is not NULL . If pool -> freeblock points to the end of the free list before we 've carved the entire pool into blocks, that means we simply haven' t yet gotten to one of the higher - address blocks . The offset from the pool_header to the start of \"the next\" virgin block is stored in the pool_header nextoffset member , and the largest value of nextoffset that makes sense is stored in the maxnextoffset member when a pool is initialized . All the blocks in a pool have been passed out at least once when and only when nextoffset > maxnextoffset . Â§ßÊ¶ÇÂ∞±ÊòØËØ¥Ôºå freeblock Â≠óÊÆµÊåáÂêë‰∫Ü‰∏Ä‰∏™ÂçïÈ°πÈìæË°®ÔºåËøô‰∏™ÈìæË°®ËøûÊé•‰∫ÜËØ•Ê±†‰∏≠ÁöÑ‰∏ÄÈÉ®ÂàÜÂèØÁî®ÁöÑÂùó„ÄÇ‰πãÊâÄ‰ª•ËØ¥ÊòØ‚Äò‰∏ÄÈÉ®ÂàÜ'ÊòØÂõ†‰∏∫Âú®ÂàùÂßãÂåñÊ±†ÁöÑÊó∂ÂÄôÁ≥ªÁªüÂè™‰ºöÁªôÂâç‰∏§ÁªôÂÜÖÂ≠òÂùóÂàÜÈÖçÂÜÖÂ≠òÔºåËøôÊ†∑‰ΩøÂæóÂè™ÊúâÂΩìÈúÄË¶ÅÂàÜÈÖçÊñ∞ÂÜÖÂ≠òÁöÑÊó∂ÂÄôÊâç‰ºöËÆ©Ê±†Âç†Áî®Êñ∞ÁöÑÂùóÁ©∫Èó¥ÔºåËäÇÁúÅ‰∫ÜÂÜÖÂ≠òÁöÑÊ∂àËÄó„ÄÇÂàùÂßãÂåñÊ±†ÁöÑÊó∂‰ºöËøõË°åÁöÑÂè¶‰∏Ä‰∏™Êìç‰ΩúÊòØËÆæÁΩÆ maxnextoffset Â≠óÊÆµÔºåÂç≥ÂÜÖÂ≠òÊåáÈíàÊúÄÂ§ßÂÅèÁßªÈáè„ÄÇÂΩìÈúÄË¶ÅÊãìÂ±ïÊñ∞ÁöÑÂùóÁ©∫Èó¥Êó∂ÔºåÈÄöËøá szidx Âèä nextoffset Â≠óÊÆµËÆ°ÁÆóÂá∫Êñ∞ÂùóÊâÄÂç†Áî®ÁöÑÂÜÖÂ≠òÂú∞ÂùÄÂå∫ÂüüÂπ∂ÂàÜÈÖçÂÜÖÂ≠ò„ÄÇÊúÄÂêéÔºåÂΩì nextoffset Â§ß‰∫é maxnextoffset Êó∂ÔºåÊï¥‰∏™Ê±†ÁöÑÂ∞±Êª°‰∫Ü„ÄÇ ‰∏∫‰∫ÜÊõ¥ÊúâÊïàÂú∞ËøõË°åÊ±†ÁöÑÁÆ°ÁêÜÔºåpythonÂºïÂÖ•‰∫Ü usedpools Êï∞ÁªÑÊù•ÂÇ®Â≠òÂêÑ‰∏™ size class ÁöÑÂùóÔºö ÂÄºÂæóÊ≥®ÊÑèÁöÑÊòØÔºåÂùóÂíåÊ±†Âπ∂‰∏çÊòØÁõ¥Êé•ÂàÜÈÖçÂÜÖÂ≠òÔºåÂÆÉ‰ª¨ÊâÄÂàÜÈÖçÁöÑÂÜÖÂ≠òÊù•Ëá™‰∫éÂÖ∂ÊâÄÂú®ÁöÑArenaÔºàÂÜÖÂ≠òÁ©∫Èó¥Ôºâ„ÄÇ Arena ArenaÔºàÂÜÖÂ≠òÁ©∫Èó¥ÔºâÊòØÁî±64‰∏™Ê±†ÁªÑÊàêÁöÑÂú®Â†Ü‰∏äÁöÑ256kÁöÑÁ©∫Èó¥ÔºåÂêåÊ†∑‰πüÊòØÂèåÂêëÈìæË°®„ÄÇÂÆÉÁöÑÁªìÊûÑÂ¶Ç‰∏ãÔºö struct arena_object { uintptr_t address ; block * pool_address ; uint nfreepools ; uint ntotalpools ; struct pool_header * freepools ; struct arena_object * nextarena ; struct arena_object * prevarena ; }; ÂÖ∂‰∏≠ ntotalpools Âíå nfreepools ÂÇ®Â≠ò‰∫ÜÂÜÖÂ≠òÁ©∫Èó¥‰∏äÂèØÁî®Ê±†ÁöÑ‰ø°ÊÅØ„ÄÇ freepools ÊåáÂêë‰∏Ä‰∏™ÂèØÁî®Ê±†ÁöÑÈìæË°®„ÄÇ python‰∏≠ÁöÑÂûÉÂúæÂ§ÑÁêÜ python‰∏≠ÁöÑÂûÉÂúæÂ§ÑÁêÜÊú∫Âà∂Áî±‰∏§ÈÉ®ÂàÜÁªÑÊàêÔºö ÂºïÁî®ËÆ°Êï∞Ôºà reference counting Ôºâ ÂàÜ‰ª£ÂûÉÂúæÊî∂ÈõÜÂô®Ôºà generational garbage collector Ôºâ ÂºïÁî®ËÆ°Êï∞ÊòØÊàë‰ª¨Êó†Ê≥ïÊüìÊåáÂè™ËÉΩ‰∫ÜËß£ÁöÑ‰∏ÄÈÉ®ÂàÜÔºå‰ΩÜÂÆÉÁöÑÊú∫Âà∂‰πüÂæàÁÆÄÂçïÔºåÂ∞±ÊòØ‰∏∫ÊØè‰∏™ÂØπË±°Áª¥Êä§‰∏Ä‰∏™ÂºïÁî®ËÆ°Êï∞ÔºåÂΩìËøô‰∏™ÂºïÁî®ËÆ°Êï∞ËêΩ‰∏∫0ÁöÑÊó∂ÂÄôÁ´ãÂàªÈáäÊîæÂØπË±°ÊâÄÂç†ÂÜÖÂ≠ò„ÄÇÂÆÉÊó†Ê≥ïÂ§ÑÁêÜÂæ™ÁéØÂºïÁî®ÁöÑÊÉÖÂÜµÔºåÂàÜ‰ª£ÂûÉÂúæÊî∂ÈõÜÂô®Âç≥ gc Ê®°ÂùóÂàôÊòØ‰∏∫‰∫ÜÂ∫îÂØπËøôÁßçÊÉÖÂÜµËÄå‰∫ßÁîü„ÄÇËøô‰∏§ÁßçÊäÄÊúØÁõ∏ËæÖÁõ∏ÊàêÁªÑÊàê‰∫Üpython‰∏≠ÁöÑÂûÉÂúæÂ§ÑÁêÜÊú∫Âà∂„ÄÇ Âü∫‰∫éÂºïÁî®ËÆ°Êï∞ÁöÑÂûÉÂúæÊî∂ÈõÜÊú∫Âà∂ÊòØ‰∏ÄÁßçÁõ∏ÂØπÁÆÄÂçïÁöÑÊú∫Âà∂„ÄÇÂú®‰∏Ä‰∫õÂÖ∂‰ªñËØ≠Ë®Ä‰∏≠ÔºåÊúâ‰∏Ä‰∫õÊõ¥Áé∞‰ª£ÁöÑÊú∫Âà∂ÔºåÂ¶Çjava‰∏≠ÁöÑÂèØËææÊÄßÁÆóÊ≥ï„ÄÇËøô‰∏™ÁÆóÊ≥ïÁöÑÂü∫Êú¨ÊÄùË∑ØÂ∞±ÊòØÈÄöËøá‰∏ÄÁ≥ªÂàóÁöÑÁß∞‰∏∫ GC Roots ÁöÑÂØπË±°‰Ωú‰∏∫Ëµ∑ÂßãÁÇπÔºå‰ªéËøô‰∫õËäÇÁÇπÂºÄÂßãÂêë‰∏ãÊêúÁ¥¢ÊâÄÊúâËµ∞ËøáÁöÑË∑ØÂæÑ‰Ωú‰∏∫ÂºïÁî®ÈìæÔºåÂΩì‰∏Ä‰∏™ÂØπË±°Âà∞ GC Roots Ê≤°Êúâ‰ªª‰ΩïÂºïÁî®ÈìæÁõ∏ËøûÊó∂ÂÄôÔºåÂàôËØÅÊòéÊ≠§ÂØπË±°‰∏çÂèØÁî®„ÄÇËøô‰∏ÄÁßçÁÆóÊ≥ï‰πüËÉΩÂ§üÈÅøÂÖçÂæ™ÁéØÂºïÁî®ÁöÑ‰∫ßÁîü„ÄÇ ÂºïÁî®ËÆ°Êï∞ Âú®pythonÁöÑ c apiÊñáÊ°£‰∏≠ ÊèèËø∞‰∫Ücpython‰∏≠ÂºïÁî®ËÆ°Êï∞ÁöÑÂ∫ïÂ±ÇÂÆûÁé∞„ÄÇ cpython‰∏≠ÈÄöËøá Py_INCREF Âíå Py_DECREF ‰∏§‰∏™ÂÆèÊù•ÊéßÂà∂ÂºïÁî®ËÆ°Êï∞ÁöÑÂ¢ûÂä†ÂíåÂáèÂ∞ë„ÄÇÂØπË±°ÊûêÊûÑÂô®‰ºöËß¶Âèë Py_DECREF ÂÆèÔºåËØ•ÂÆè‰ºöÊ£ÄÊü•ÂØπË±°ÁöÑÂºïÁî®ËÆ°Êï∞ÊòØÂê¶‰ºöË¢´Èôç‰∏∫0‚Äî‚Äî‚Äî‚Äî‰∏∫0Êó∂ÂàôÁ´ãÂàªÈáäÊîæËØ•ÂØπË±°ÁöÑÂÜÖÂ≠òÔºåËøôÂ∞±‰ΩøÂæóÂºïÁî®ËÆ°Êï∞ÈáäÊîæÂÜÖÂ≠òÂÖ∑ÊúâÂç≥Êó∂ÊÄß„ÄÇ ‰Ω†ÂèØ‰ª•‰ΩøÁî® sys.getrefcount ÊñπÊ≥ïÊù•ÂèñÂæóÊüê‰∏™ÂØπË±°ÁöÑÂºïÁî®ËÆ°Êï∞Ôºö import sys foo = [] ### 2 references, 1 from the foo var and 1 from getrefcount print ( sys . getrefcount ( foo )) def bar ( a ): # 4 references # from the foo var, function argument, getrefcount and Python's function stack print ( sys . getrefcount ( a )) bar ( foo ) ### 2 references, the function scope is destroyed print ( sys . getrefcount ( foo )) ÂàÜ‰ª£ÂûÉÂúæÊî∂ÈõÜÂô® ÂºïÁî®ËÆ°Êï∞Ëøô‰∏™ÁÆÄÂçïÁöÑÊú∫Âà∂‰ºöÂ∏¶Êù•ËÆ∏Â§öÈóÆÈ¢òÔºåÂ¶ÇÊó†Ê≥ïËß£ÂÜ≥Âæ™ÁéØÂºïÁî®„ÄÅÈúÄË¶ÅÁ∫øÁ®ãÈîÅÂèäÊïàÁéá‰Ωé‰∏ã„ÄÇ‰∏∫‰∫ÜËß£ÂÜ≥Âæ™ÁéØÂºïÁî®ÁöÑÈóÆÈ¢òÔºå gcÊ®°Âùó Âú®python 1.5ÁâàÊú¨‰∏≠Ë¢´Âä†ÂÖ•„ÄÇ Áî±‰∫éÂæ™ÁéØÂºïÁî®Âè™‰ºöÂú®containerÂÆπÂô®Á±ªÂûã‰∏≠ÂèëÁîüÔºåÊâÄ‰ª• gc Ê®°ÂùóÂπ∂‰∏ç‰ºöËøΩË∏™python‰∏≠ÊâÄÊúâÁöÑÂØπË±°„ÄÇÊàë‰ª¨ÂèØ‰ª•‰ΩøÁî® gc.is_tracked ÂáΩÊï∞Êù•Âà§Êñ≠Êüê‰∏™ÂØπË±°ÊòØÂê¶Ë¢´ËøΩË∏™Ôºö >>> gc . is_tracked ( 0 ) False >>> gc . is_tracked ( \"a\" ) False >>> gc . is_tracked ([]) True >>> gc . is_tracked ({}) #Ëøô‰∏™Â≠óÂÖ∏‰∏∫Á©∫ÔºåÂõ†Ê≠§Êú™Ë¢´ËøΩË∏™ False >>> gc . is_tracked ({ \"a\" : 1 }) #Ëøô‰∏™Â≠óÂÖ∏ÊâÄÊúâÂÖÉÁ¥†ÈÉΩ‰∏∫ÂéüÂ≠êÁ±ªÂûãÔºåÂõ†Ê≠§Êú™Ë¢´ËøΩË∏™ False >>> gc . is_tracked ({ \"a\" : []}) True ‰∏éÂºïÁî®ËÆ°Êï∞Êú∫Âà∂ÁöÑÂç≥Êó∂Ëß¶Âèë‰∏çÂêåÁöÑÊòØÔºå‰∏∫‰∫Ü‰øùËØÅÊÄßËÉΩ gc Âπ∂‰∏çÊòØÂÆûÊó∂Ëß¶ÂèëÁöÑ„ÄÇ È¶ñÂÖàË¶ÅÊèêÂà∞ÁöÑÊòØ gc ÁöÑ ÂàÜ‰ª£Êú∫Âà∂ „ÄÇ‰Ωú‰∏∫‰∏Ä‰∏™ÂàÜ‰ª£ÂûÉÂúæÊî∂ÈõÜÂô®ÔºåÊâÄÊúâË¢´ gc ËøΩË∏™ÁöÑÂØπË±°Ë¢´ÂàÜ‰∏∫‰∏â‰ª£ÔºöÊñ∞Áîü‰ª£„ÄÅ‰∏≠Âπ¥‰ª£ÂíåËÄÅÂπ¥‰ª£ÔºåËæÉÊñ∞‰ª£ÁöÑÂØπË±°Â∞Ü‰ºöË¢´Êõ¥È¢ëÁπÅÁöÑÂ§ÑÁêÜ„ÄÇÊâÄÊúâÊñ∞ÂØπË±°‰ºöË¢´ÁïåÂÆö‰∏∫Êñ∞Áîü‰ª£ÔºåÂè™ÊúâÂΩìÊüê‰∏™ÂØπË±°Âú®‰∏ÄÊ¨° gc ‰∏≠Â≠òÊ¥ª‰∏ãÊù•Êó∂ÂÆÉÊâç‰ºö‰Ωú‰∏∫‰∏Ä‰∏™Âπ¥ËøàÁöÑÂØπË±°Ë¢´Ê†áËÆ∞‰∏∫Êõ¥ËÄÅÁöÑ‰∏Ä‰ª£„ÄÇÂàÜ‰ª£Êú∫Âà∂Âú®‰∏ÄÂÆöÁ®ãÂ∫¶‰∏ä‰ºòÂåñ‰∫Ü gc ÁöÑÊÄßËÉΩ„ÄÇ ÂΩìÊüê‰∏Ä‰ª£Âä†ÂÖ•ÁöÑÂØπË±°Êï∞ÈáèË∂ÖËøá‰∏Ä‰∏™ÈòàÂÄºÊó∂ÔºåÂ∞±‰ºöËß¶Âèë gc Â§ÑÁêÜËøô‰∏Ä‰ª£ÂèäÊõ¥Êñ∞‰ª£ÁöÑÂØπË±°„ÄÇËøô‰∏ÄÈòàÂÄºÂèØ‰ª•‰ΩøÁî® gc.get_threshold ÊñπÊ≥ïËé∑ÂæóÔºåÂ¶ÇÊ†áÂáÜÁöÑÈòàÂÄº‰∏∫(700,10,10)ÂàÜÂà´ÂØπÂ∫îÊñ∞‰∏≠ËÄÅ‰∏â‰ª£ÁöÑÈòàÂÄº„ÄÇÂÄºÂæó‰∏ÄÊèêÁöÑÊòØÔºå‰∏∫‰∫ÜÊèêÂçáÊÄßËÉΩÔºåÂØπÁ¨¨‰∏â‰ª£ÁöÑ‚ÄòÈïøÂØø'ÂØπË±°ÁöÑÊî∂ÈõÜÔºàÂç≥ÂÖ®Â±ÄÂûÉÂúæÊî∂ÈõÜÔºâÈúÄË¶ÅËææÂà∞ ‰∏Ä‰∏™ÁâπÊÄßÁöÑÊ†áÂáÜ ‚Äî‚Äî‚Äî‚Äî long_lived_pending / long_lived_total ÁöÑÊØî‰æãÂ§ß‰∫é25%„ÄÇ long_lived_total ‰∏∫Âú®ÊúÄËøë‰∏ÄÊ¨°ÂÖ®Â±Ä gc ‰∏≠Â≠òÊ¥ª‰∏ãÊù•ÁöÑÂØπË±°ÁöÑÊï∞ÈáèÔºå long_lived_pending ‰∏∫Âú®ÊâÄÊúâÈùûÂÖ®Â±Ä gc ‰∏≠Â≠òÊ¥ª‰∏ãÊù•ÁöÑÔºåÁé∞Âú®Â§ÑÂú®ËÄÅÂπ¥‰ª£ÁöÑÂØπË±°ÁöÑÊï∞Èáè„ÄÇ ÂÖ∂Ê¨°Êàë‰ª¨Ë¶ÅÊé¢ËÆ®ÁöÑÊòØpython‰∏≠ ÊâæÂá∫ÂºïÁî®Âæ™ÁéØÁöÑÁÆóÊ≥ï „ÄÇÊàë‰ª¨ÁªèÂ∏∏ÁúãÂà∞ÂØπËØ•ÁÆóÊ≥ïÁöÑÊèèËø∞‰∏∫ÔºöÊâæÂà∞Á≥ªÁªüÁöÑ Ê†π ÂØπË±°Ôºå‰ªéËØ•ÂØπË±°ÂºÄÂßãÈÅçÂéÜÊâÄÊúâË¢´ËøΩË∏™ÁöÑÂÆπÂô®ÂØπË±°ÔºåËøô‰∫õÂèØÂà∞ËææÁöÑÂØπË±°ÊòØÊ¥ªÁùÄÁöÑÔºõÈáäÊîæÊâÄÊúâÂÖ∂‰ªñÂØπË±°„ÄÇÁÑ∂ËÄåÂõ†‰∏∫Êàë‰ª¨Êó†Ê≥ïÂÆåÂÖ®ÊâæÂà∞ÊãìÂ±ïÊ®°ÂùóÁöÑ Ê†π ÂØπË±°ÔºåËøôÁßç‰º†ÁªüÁöÑÊñπÂºèÂ∑≤Áªè‰∏çËÉΩÂÜçÂΩì‰ªäÁâàÊú¨ÁöÑpython‰∏≠‰ΩøÁî®‰∫ÜÔºåÂõ†Ê≠§Êàë‰ª¨ÂæóÈááÂèñ‰∏ÄÁßçÊñ∞ÁöÑÂ§ÑÁêÜÂºïÁî®Âæ™ÁéØÁöÑÁÆóÊ≥ï„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÂ§ÑÁêÜË¢´ËøΩË∏™ÁöÑÂÆπÂô®ÂØπË±°ÔºåÂæóÁõä‰∫éËøôÁÇπÔºåÊàë‰ª¨ÂèØ‰ª•‰ª•ËæÉÂ∞èÁöÑ‰ª£‰ª∑Â∞ÜÊâÄÊúâË¢´ËøΩË∏™ÁöÑÂØπË±°Áî®ÂèåÂêëÈìæË°®‰∏≤ËÅîËµ∑Êù•ÔºàÂáèÂ∞ëÂú®‰ªªÊÑè‰ΩçÁΩÆÊèíÂÖ•ÊàñÂà†Èô§ËäÇÁÇπÁöÑ‰ª£‰ª∑ÔºâÔºåÂπ∂ÂÅöÂ¶Ç‰∏ãÂ§ÑÁêÜÔºö ÂØπÈìæË°®‰∏≠ÁöÑÊØè‰∏™ÂØπË±°ÔºåËÆæÁΩÆ‰∏Ä‰∏™ gc_ref sÂ≠óÊÆµ‰ΩøÂÖ∂Á≠â‰∫éËØ•ÂØπË±°ÁöÑÂºïÁî®ËÆ°Êï∞ÂÄºÔºõ ÂØπ‰∫éÈìæË°®‰∏≠ÁöÑÊØè‰∏™ÂØπË±°ÔºåÊâæÂà∞ÂÆÉÊâÄÂºïÁî®ÁöÑÁõÆÊ†áÂØπË±°Âπ∂Âáè1ËØ•ÂÆπÂô®ÁöÑ gc_refs ÂÄºÔºõ ÊâÄÊúâ gc_refs ÂÄºÂ§ß‰∫é1ÁöÑÂØπË±°ÊòØÊúâË¢´Á´ãÊ°àË°®Â§ñÂØπË±°ÂºïÁî®ÁöÑÂØπË±°ÔºåÂõ†Ê≠§Êàë‰ª¨‰∏çËÉΩÈáäÊîæÂÆÉ‰ª¨ÁöÑÂÜÖÂ≠òÔºåÂ∞ÜÂÆÉ‰ª¨ÁßªËá≥Âè¶‰∏Ä‰∏™ÈõÜÂêà‰∏≠ÂéªÔºàÊõ¥Âπ¥ËøàÁöÑ‰ª£ÔºâÔºõ ÊâÄÊúâË¢´Ëøô‰∫õËΩ¨ÁßªÁöÑÂÆπÂô®ÂØπË±°ÂºïÁî®ÁöÑÈìæË°®‰∏≠ÂØπË±°‰πü‰∏çËÉΩÂ§üË¢´ÈáäÊîæÔºå‰πüÂ∞ÜÂÆÉ‰ª¨ÁßªÂà∞Âè¶‰∏Ä‰∏™ÈõÜÂêà‰∏≠ÔºåÂØπË¢´ÂÆÉ‰ª¨ÂºïÁî®ÁöÑÂØπË±°ÂÅöÁõ∏ÂêåÁöÑÊìç‰ΩúÔºõ Áé∞Âú®Êàë‰ª¨ÁöÑÈìæË°®ÈáåÂâ©‰∏ãÂØπË±°Â∞±ÊòØË¢´Âæ™ÁéØÂºïÁî®ÁöÑÁöÑÂØπË±°ÔºåÂ∞ÜÂÆÉ‰ª¨ÈáäÊîæÔºõ ÊÄªÁªì Â∞ΩÁÆ°ÊúâÂàÜ‰ª£ÂûÉÂúæÊî∂ÈõÜÂô®Â∏ÆÂä©Êàë‰ª¨Â§ÑÁêÜÂæ™ÁéØÂºïÁî®ÁöÑÈóÆÈ¢òÔºå‰ΩÜÂú®Êàë‰ª¨ÁöÑ‰ª£Á†Å‰∏≠Êàë‰ª¨ËøòÊòØË¶ÅÊ≥®ÊÑèÈÅøÂÖçÂá∫Áé∞Âæ™ÁéØÂºïÁî®„ÄÇÂõ†‰∏∫Â¶ÇÊûúÂá∫Áé∞Â§ßÈáèÂæ™ÁéØÂºïÁî®ÁöÑËØùÔºåÂêØÂä® gc Êú∫Âà∂‰æùÁÑ∂Ë¶ÅËÄóË¥πÂ§ßÈáèÁöÑËµÑÊ∫ê„ÄÇÂú®ËøôÈáåÂéü‰ΩúËÄÖÁªôÂ§ßÂÆ∂ÁöÑÂª∫ËÆÆÊòØ‰ΩøÁî®python‰∏≠ÁöÑ weakref Ê®°ÂùóÔºåÂº±ÂºïÁî®Âπ∂‰∏ç‰ºöÂ¢ûÂä†ÂºïÁî®ËÆ°Êï∞ÔºåÂΩìÂÆÉÂºïÁî®ÁöÑÂØπË±°‰∏çÂ≠òÂú®Êó∂ÂÆÉ‰ºöËøîÂõûNoneÁªôË∞ÉÁî®Êñπ„ÄÇ Âè¶Â§ñÔºåÂºïÁî®ËÆ°Êï∞ÊòØ‰∏Ä‰∏™Êàë‰ª¨‰∏çËÉΩÊéßÂà∂ÁöÑÊú∫Âà∂Ôºå‰ΩÜÂàÜ‰ª£ÂûÉÂúæÊî∂ÈõÜÊú∫Âà∂Á°ÆÊòØÂèØ‰ª•Áî® gc Ê®°ÂùóhackÁöÑ„ÄÇÊàë‰ª¨ÂèØ‰ª•‰ΩøÁî® gc.disable() Êù•ÂÖ≥Èó≠ÂàÜ‰ª£ÂûÉÂúæÊî∂ÈõÜÂô®ÔºåÂπ∂‰∏î‰ΩøÁî® gc.collect() ÂáΩÊï∞Êù•ÊâãÂä®Ëß¶ÂèëÂûÉÂúæÊî∂ÈõÜ„ÄÇ‰ΩÜÂæàÂ§ö‰ªé‰∏ö‰∫∫ÂëòÂπ∂‰∏çÊèêÂÄ°Ëøô‰∏ÄÁÇπ„ÄÇ Additional ÂèÇËÄÉÊñáÁåÆÔºö 1. Things you need to know about garbage collection in Python 2. Python internals: Memory management 3. Objects, Types and Reference Counts 4. Garbage Collector interface 5. Garbage Collection for Python","tags":"Python","title":"PythonÂûÉÂúæÂ§ÑÁêÜÊú∫Âà∂"},{"url":"replace-asyncio-with-native-coroutine.html","text":"Description Âú®David BeazleyÁöÑ Topics of Interest(Python Asyncio) ÊºîËÆ≤ ‰∏≠Ôºå‰ªñ‰ªãÁªç‰∫ÜÁî±‰∫éasyncÂú®python‰∏≠ÁöÑÁßçÁßçÂéÜÂè≤ÈÅóÁïôÔºåasyncioÂ∫ìÂú® aync/await ËØ≠Âè•Âä†ÂÖ•‰πãÂêéÂ∑≤Áªè‰∏çÊòØ‰∏ÄÁßçÊúÄÁõ¥Êé•ÊúâÊïàÁöÑpython asyncÂÆûÁé∞„ÄÇÂú®ÂÜô‰∫Ü‰∏Ä‰∏™ÁÆÄÂçïÁ®ãÂ∫èÊõø‰ª£asyncioÂ∫ìÂπ∂‰∏éÂÖ∂ÂèägeventÂ∫ìÁöÑÊïàÁéáÂÅöÊØîËæÉ‰πãÂêéÔºåÊàë‰ª¨ÂèëÁé∞‰∫Üpython3.5ÁâàÊú¨‰∏≠ÂºïÂÖ•ÁöÑÂéüÁîüÂçèÁ®ãÂú®Â§ÑÁêÜÂºÇÊ≠•ÊñπÈù¢ÂÖ∑ÊúâÈùûÂ∏∏È´òÁöÑÊïàÁéá„ÄÇÂú®ÊºîËÆ≤ÁöÑÊúÄÂêé‰ªñÊèêÂá∫ÔºåÂèØËÉΩÊàë‰ª¨ÈúÄË¶ÅÁöÑasyncÂπ∂‰∏çÊòØ‰∏Ä‰∏™Â∫ìËÄåÊõ¥ÂÉèÊòØ‰∏Ä‰∫õapiÊù•‰æõÊàë‰ª¨Êõ¥ÊúâÊïàÂú∞ÂÅöÂ∫ïÂ±ÇÁöÑ‰ΩøÁî®„ÄÇ ËøôÊ¨°ÁöÑÊºîËÆ≤ÂêØËø™‰∫ÜÊàëËÆ∏Â§öÔºå‰ΩÜÁ¢ç‰∫éÂπ∂Ê≤°ÊúâÁõ∏ÂÖ≥ÁöÑpptÂíåÊùêÊñôÊèê‰æõ‰∏ãËΩΩÔºàÊúâÈÉ®ÂàÜÊòØDavidÂú®Âè∞‰∏äÂÖâÈÄüLive codingÁöÑÂéüÂõ†ÔºâÔºåÊàëÂè™ËÉΩÂ∞ÜÂÖ∂‰ª£Á†ÅË™äÂÜô‰∏ãÊù•Ôºå‰ª•‰æõÊ£ÄÈ™åÂèäÁ†îÁ©∂Ôºå‰Ωú‰∏∫‰∏™‰∫∫ÁöÑËØª‰π¶Á¨îËÆ∞„ÄÇ Core programing of async server ÂáÜÂ§áÂ∑•‰Ωú Êú¨ÊñáÊµãËØïÁéØÂ¢É‰∏∫python3.6ÁâàÊú¨ÔºåIntel Core i5-6500,8G RAMÔºåwin10„ÄÇ DavidÁî®‰∫Ü‰ª•‰∏ãÁ®ãÂ∫èÊù•ÂÅöasyncÊúçÂä°Âô®ÁöÑÊµãËØï„ÄÇËØ•Á®ãÂ∫è‰ºöÂèëÈÄÅ10000‰∏™ËØ∑Ê±ÇÂπ∂ËÆ°ÁÆóÊúçÂä°Âô®Â§ÑÁêÜËØ∑Ê±ÇÁöÑÈÄüÁéáÔºö #benchmark.py import time from socket import socket , AF_INET , SOCK_STREAM , SOL_SOCKET , SO_REUSEADDR def benchmark ( addr , nmessages ): sock = socket ( AF_INET , SOCK_STREAM ) sock . connect ( addr ) start = time . time () for n in range ( nmessages ): sock . send ( b 'x' ) resp = sock . recv ( 10000 ) end = time . time () print ( nmessages / ( end - start ), 'message/sec' ) benchmark (( 'localhost' , 25000 ), 100000 ) asyncioÊúçÂä°Âô® È¶ñÂÖàÊàë‰ª¨Áî®asyncioÊù•Êê≠Âª∫‰∏Ä‰∏™ÂºÇÊ≠•ÊúçÂä°Âô®Ôºå‰ª£Á†ÅÂ¶Ç‰∏ãÔºö #asyncio_server.py import asyncio from socket import socket , AF_INET , SOCK_STREAM , SOL_SOCKET , SO_REUSEADDR loop = asyncio . get_event_loop () async def echo_server ( address ): sock = socket ( AF_INET , SOCK_STREAM ) sock . setsockopt ( SOL_SOCKET , SO_REUSEADDR , 1 ) sock . bind ( address ) sock . listen ( 5 ) sock . setblocking ( False ) while True : client , addr = await loop . sock_accept ( sock ) print ( 'Connection from' , addr ) loop . create_task ( echo_handler ( client )) async def echo_handler ( client ): with client : while True : data = await loop . sock_recv ( client , 10000 ) if not data : break await loop . sock_sendall ( client , b 'Got:' + data ) print ( 'Connection closed' ) loop . create_task ( echo_server (( '' , 25000 ))) loop . run_forever () ËÆ©Êàë‰ª¨ÂêØÂä®ÊúçÂä°Âπ∂ËøêË°å benchmark.py ÂÅöÊµãËØïÔºåÂæóÂà∞ÁöÑÁªìÊûú‰∏∫ 9660.489944352334 message/sec „ÄÇ ÂéüÁîüÂçèÁ®ãÂÆûÁé∞eventloop ËßÇÂØü‰ª•‰∏äasyncioÊúçÂä°Âô®ÁöÑ‰ª£Á†ÅÔºå‰∏çÈöæÂèëÁé∞ÂÖ∂‰∏≠‰∏ç‰ªÖÊúâasyncioÁöÑeventloopÔºàÂ∫ïÂ±ÇÁî®ÁîüÊàêÂô®ÂçèÁ®ãÂíå yield from ÂÆûÁé∞ÔºâËøòÊúâÊñ∞ÂºïÂÖ•ÁöÑ aync/await ÂéüÁîüÂçèÁ®ãÔºåÊòØ‰∏ÄÁßçË∑®ÁïåÁªÑÂêàÁöÑÁä∂ÊÄÅ„ÄÇÈÇ£‰πàËÉΩ‰∏çËÉΩÂ∞Üeventloop‰πüÁî®ÂéüÁîüÂçèÁ®ã‰πüÂÆûÁé∞Âë¢ÔºüDavidÁªôÂá∫‰∫Ü‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊñπÊ°àÔºö #native_coroutine_asyncio.py from types import coroutine from collections import deque from selectors import DefaultSelector , EVENT_READ , EVENT_WRITE @coroutine def read_wait ( sock ): yield 'read_wait' , sock @coroutine def write_wait ( sock ): yield 'write_wait' , sock class Loop : def __init__ ( self ): self . ready = deque () self . selector = DefaultSelector () async def sock_recv ( self , sock , maxbytes ): await read_wait ( sock ) return sock . recv ( maxbytes ) async def sock_accept ( self , sock ): await read_wait ( sock ) return sock . accept () async def sock_sendall ( self , sock , data ): while data : try : nsent = sock . send ( data ) data = data [ nsent :] except BlockingIOError : await write_wait ( sock ) def create_task ( self , coro ): self . ready . append ( coro ) def run_forever ( self ): while True : while not self . ready : events = self . selector . select () for key , _ in events : self . ready . append ( key . data ) self . selector . unregister ( key . fileobj ) while self . ready : self . current_task = self . ready . popleft () try : op , * args = self . current_task . send ( None ) # run to the yield getattr ( self , op )( * args ) # sneaky method call except StopIteration : pass def read_wait ( self , sock ): self . selector . register ( sock , EVENT_READ , self . current_task ) def write_wait ( self , sock ): self . selector . register ( sock , EVENT_WRITE , self . current_task ) ËøôÊÆµ‰ª£Á†ÅÈáåÊúâ‰∫õÊØîËæÉ‰∏çËßÑËåÉÁöÑÂÅöÊ≥ïÔºåÊØîÂ¶Çgetattr(self,op)(* args)ËØ≠Âè•Áî®Â≠óÁ¨¶‰∏≤Êù•ËøêË°åÂáΩÊï∞Ôºå‰ΩÜÊó†‰º§Â§ßÈõÖÔºåÊàë‰ª¨ÁöÑÁõÆÁöÑÊòØÊ£ÄÈ™åÂ∞ÜeventloopÊç¢ÊàêÂéüÁîüÂçèÁ®ãÂÆûÁé∞ÁöÑËØù‰ºöÊÄéÊ†∑„ÄÇ Êàë‰ª¨Â∞Üasyncioo_server‰∏≠ÁöÑeventloopÊç¢ÊàêÂàöÂàöÂÆûÁé∞ÁöÑÁâàÊú¨,ÂÖ∂‰ªñ‰ª£Á†Å‰øùÊåÅ‰∏çÂèòÔºö import native_coroutine_asyncio as native loop = native . Loop () ËøêË°å benchmark.py ÂèëÁé∞ÊØèÁßíËØ∑Ê±ÇÂ§ÑÁêÜÊï∞Âèò‰∏∫‰∫Ü 19515.515222278125 message/sec ÔºåÊïàÁéáÊèêÂçá‰∫ÜË∂ÖËøá‰∫Ü100%„ÄÇ geventÊúçÂä°Âô® ‰∏∫‰∫ÜÂÅöÂπ≥Ë°åÊµãËØïÔºåDavidÂèàÁî®‰∫ÜgeventËøô‰∏™Â∫ïÂ±ÇÁî±cÂÆûÁé∞ÁöÑÂ∫ìÊù•Ê£ÄÊµãÂéüÁîüÂçèÁ®ãÁöÑÊïàÁéáÁ©∂Á´üÂ¶Ç‰ΩïÔºå‰ª£Á†ÅÂ¶Ç‰∏ãÔºö #gevent_server.py from gevent.server import StreamServer ### this handler will be run for each incoming connection in a deficated greenlet def echo ( socket , address ): print ( 'New connection from {} ' . format ( address )) while True : data = socket . recv ( 100000 ) if not data : break socket . sendall ( b 'Got:' + data ) socket . close () if __name__ == '__main__' : server = StreamServer (( '0.0.0.0' , 25000 ), echo ) server . serve_forever () Âú®python3.6‰∏ãÂÆÉÁöÑÊØèÁßíÂ§ÑÁêÜÁöÑËØ∑Ê±ÇÊï∞‰∏∫ 16807.0229190064 message/sec ÔºåÂéüÁîüÂçèÁ®ãÁîöËá≥ÊØîÂÆÉËøòÈ´ò‰∏ÄÁÇπ„ÄÇÂú®DavidÁöÑÁ∫øÁ®ãÊµãËØïÁöÑÊó∂ÂÄôÔºå‰ªñË∞ÉÁî®‰∫Üpython2.7ÁöÑÁéØÂ¢ÉÔºå‰ΩøÂÆÉÂíåÂéüÁîüÂçèÁ®ãÁöÑÊïàÁéáÊòØÂ∑Æ‰∏çÂ§ö„ÄÇ ÁªìËØ≠ asyncioÂ∫ìÂÖ∂ÂÆûÊúâÂæàÂ§ßÁöÑÂéÜÂè≤ÂåÖË¢±„ÄÇpython‰∏≠ÁöÑÂçèÁ®ã‰ªéÂçïÁ∫ØÁöÑyieldÁîüÊàêÂô®ÂºÄÂßãÔºåÁªèÂéÜ‰∫Ü‰∏Ä‰∏™‰∏Ä‰∏™ÁâàÊú¨ÁöÑÂèòËøÅÔºåÁîüÊàêÂô®ÂæóÂà∞ÂèØ‰ª•Áî® send „ÄÅ yield Ôºå throw ‰∏éÂ§ñÁïåÈÄö‰ø°ÁöÑÂäüËÉΩÊàê‰∏∫‰∫ÜÊÑè‰πâ‰∏äÁöÑÂçèÁ®ãÔºõ‰πãÂêépython3.3ÁâàÊú¨‰∏≠Âä†ÂÖ•ÁöÑ yield from Áªô‰∫à‰∫ÜÁîüÊàêÂô®ÂçèÁ®ãÊõ¥Â§öÁöÑ‰æøÂà©‰∏éÂèØËÉΩÔºõ‰∏∫Êúü‰∏âÂπ¥ÁöÑÈÉÅÈáëÈ¶ôÈ°πÁõÆÈÄêÊ∏êÂ≠µÂåñÂá∫asyncioÂèàÁªìÂêà‰∫Ü‰ª•‰∏äÁöÑËøô‰∫õÂçèÁ®ãÁîüÊàêÂô®ÁªÑ‰ª∂Âèäfutures„ÄÅcallback„ÄÅpollingÂú®3.4ÁâàÊú¨ÁªôÊàë‰ª¨Â∏¶Êù•‰∫ÜÊñ∞ÁöÑasyncÊ®°Âùó„ÄÇ‰ΩÜË¶ÅÊºîÂåñÂá∫Ëøô‰πà‰∏Ä‰∏™Ê®°ÂùóÊâÄÁªèÂéÜÁöÑ‰∏ÄÂàáÂÆûÂú®ÊòØÂ§™‰πÖÂ§™ÈïøÔºåÊàë‰ª¨Èù¢‰∏¥ÁöÑÈóÆÈ¢òÊòØÔºöÁªèËøá‰∫ÜËøô‰πàÂ§öÁâàÊú¨ÂíåËøô‰πà‰πÖÁöÑÊó∂Èó¥ÂèòËøÅÂêéÊòØÂê¶ÂÆÉÊòØÊúÄÂ•ΩÁöÑÂë¢ÔºüÊúâÊ≤°Êúâ‰∏Ä‰∏™‰∏ÄÊ≠•Âà∞‰ΩçÁöÑÂçèÁ®ãÊù•ËÆ©Êàë‰ª¨‰ΩøÁî®Âë¢Ôºü Âú®3.5ÁâàÊú¨‰∏≠ÂéüÁîüÂçèÁ®ãÂá∫Áé∞‰∫ÜÔºåÁªèËøá‰∏äÈù¢ÁöÑÂÆûÈ™åÊàë‰ª¨ÂèØ‰ª•ÂàùÊ≠•Âà§Êñ≠ÂÆÉÊòØ‰∏Ä‰∏™Êõ¥ÂÖ∑ÊïàÁéáÁöÑÂçèÁ®ãÂÆûÁé∞ÊñπÊ°à„ÄÇËøô‰πüËÆ©pythonÊúâ‰∫ÜÊñ∞ÁöÑ‰ºòËâØÁâπÊÄßÔºå‰πüËÆ©pythonÂú®ayncÊñπÂêëÂâçËøõ‰∫Ü‰∏ÄÂ§ßÊ≠•„ÄÇ Âú® How the heck does async/await work in Python 3.5? ‰∏ÄÊñá‰∏≠ËØ¶ÁªÜÁöÑ‰ªãÁªç‰∫Üpython asyncÁöÑÂéÜÂè≤Ôºö ÂèóÂà∞ IconËØ≠Ë®Ä ÁöÑÂêØÂèëÔºåpython2.2‰∏≠ÁîüÊàêÂô®È¶ñÊ¨°Ë¢´ PEP255 - simple generators ÂºïÂÖ•„ÄÇ ËÄåpython2.5‰∏≠yieldËØ≠Ê≥ïÁöÑÂä†ÂÖ•‰ΩøÂæóËøô‰∏Ä‰ΩøÁî®Êõ¥Â∞ëÂÜÖÂ≠òÊù•Ëø≠‰ª£Â∫èÂàóÁöÑÊÉ≥Ê≥ïÊõ¥Âä†ÂÆûÁî®„ÄÇÂú®Ëøô‰∏ÄÁâàÊú¨‰∏≠Ôºå PEP342 - coroutine via enhanced generators ‰ΩøÂæópython‰∏≠ÁöÑÁîüÊàêÂô®‰∏çÂÜçËØï‰∏ÄÁÇπÂçïÁ∫ØÁöÑËø≠‰ª£Âô®ÔºåË¢´ÊöÇÂÅúÁöÑÁîüÊàêÂô®‰πüÊã•Êúâ‰∫ÜÂèØ‰ª•Ë¢´send‰ø°ÊÅØÔºå‰∏éÂ§ñÁïå‰∫§‰∫íÁöÑËÉΩÂäõ„ÄÇ ÁîüÊàêÂô®ÂçèÁ®ãÂú®Áõ∏ÂÆâÊó†‰∫ã‰∫ÜÊï∞‰∏™ÁâàÊú¨‰πãÂêéÔºåÁªà‰∫éÂú®python3.3ÁâàÊú¨‰∏≠ PEP380 - syntax for delegating to a subgenerator Â¢ûÂä†‰∫ÜÊñ∞ÁöÑËØ≠Ê≥ïyield fromÁÆÄÂåñ‰∫ÜÂçèÁ®ã‰πãÈó¥ÁöÑÁÆ°ÈÅìÂºèË∞ÉÁî®„ÄÇÂêå‰∏Ä‰∏™ÁâàÊú¨‰∏≠Guido‰∏ªÂØºÁöÑasyncioÂ∫ì‰Ωú‰∏∫ÂÆûÈ™åÊÄßÂèëÂ∏ÉÔºåÂπ∂‰∏îÂú®python3.4‰∏≠Ê≠£ÂºèÊàê‰∏∫Ê†áÂáÜÂ∫ìÁöÑ‰∏ÄÂëò„ÄÇ python3.5‰∏≠ÂçèÁ®ãËøéÊù•‰∫ÜÊñ∞ÁöÑÁ∫™ÂÖÉÔºå PEP492 - Coroutine with async and await syntax Âä†ÂÖ•async def„ÄÅasync with„ÄÅasync for„ÄÅawaitËØ≠Ê≥ïÂèäÁõ∏ÂØπÂ∫îÁöÑÂ∫ïÂ±ÇÂçèËÆÆ„ÄÇ‰∏∫‰∫Ü‰ª•Á§∫Âå∫ÂàÜÔºåÁî®Ëøô‰∫õËØ≠Ê≥ïÊûÑÊàêÁöÑÂçèÁ®ãÁß∞‰πã‰∏∫ÂéüÁîüÂçèÁ®ã„ÄÇÂéüÁîüÂçèÁ®ã‰∏çÂèØ‰ª•await‰∏Ä‰∏™ÈùûÂçèÁ®ãÁîüÊàêÂô®ÔºåÂΩªÂ∫ïÂ∞ÜÁîüÊàêÂô®‰∏éÂçèÁ®ãÁöÑÁïåÈôêÂàíÂàÜÂºÄÊù•„ÄÇ Additional Ê∫ê‰ª£Á†ÅÔºö 1. asyncio_server.py 2. native_coroutine_asyncio.py 3. gevnet_server.py 4. benchmark.py","tags":"Python","title":"Replace asyncio with native coroutine"},{"url":"how-to-run-pypy.html","text":"Description PyPy ÊòØÁõÆÂâçÈÄüÂ∫¶ÊúÄÂø´ÁöÑpythonËß£ÈáäÂô®„ÄÇÂÖà‰∏çËØ¥ÂÆÉÊÉä‰∫∫ÁöÑÁî®pythonÊù•ÁºñÂÜôpythonËß£ÈáäÂô®ÁöÑÁêÜÂøµÔºå‰πãÂâçÂú®planet pythonÈáåÁúãÂà∞‰∏ÄÁØá PyPy ËÆ°ÂàíÁßªÈô§GILÁöÑ ÊñáÁ´† Â∞±Â∑≤ÁªèËÆ©ÊàëÊÉä‰∏∫Â§©‰∫∫‰∫Ü„ÄÇ Âê¨‰∫ÜDavid BeazleyÂú®2012Âπ¥ÂÖ≥‰∫é PyPy Âíå Rpython ÁöÑÂá†‰∏™ÊºîËÆ≤‰πãÂêé( Additional 1,2,3)ÔºåÂ∞±ÂØπËøô‰∏™È°πÁõÆËµ∑‰∫ÜÊµìÂéöÁöÑÂÖ¥Ë∂£„ÄÇ Download and install ÂèØ‰ª•Âú® https://pypy.org/download.html ‰∏ãËΩΩÂà∞ PyPy ÁöÑÊúÄÊñ∞ÁâàÊú¨„ÄÇ PyPy Â∑≤ÁªèÊîØÊåÅpython2.7Âíå3.5.3‰∫ÜÔºå‰ΩÜÂü∫‰∫épython3ÁöÑ PyPy ‰æùÊóßÊòØ‰∏Ä‰∏™betaÁâàÊú¨ÔºåÂπ∂‰∏îÂ£∞Áß∞ÊØî PyPy 2ÁöÑÈÄüÂ∫¶ÊÖ¢ÂæàÂ§ö„ÄÇÂõ†‰∏∫Êàë‰ª¨ÈÄâÊã©ÂÆâË£Ö‰∫ÜÂü∫‰∫éUbuntuÁöÑ64‰Ωç PyPy „ÄÇËß£ÂéãÂêéÔºå‰∏∫‰∫ÜÊó•Âêé‰ΩøÁî®Êàë‰ª¨‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§Âú® /usr/local/bin ‰∏ãÂàõÂª∫‰∏Ä‰∏™ËΩØËøûÊé•,ÂÖ∂‰∏≠Á¨¨‰∏Ä‰∏™ÁõÆÂΩï‰∏∫ PyPy ÁöÑÂÆâË£ÖÁõÆÂΩïÔºö ln -s ~/Program/pypy2-v5.8.0-linux64/bin/pypy /usr/local/bin Áé∞Âú®Êàë‰ª¨ÂèØ‰ª•Áî® pypy ÂëΩ‰ª§ËøõÂÖ• PyPy ÁöÑshell‰∫Ü„ÄÇ Performance test DavidÁªô‰∫Ü‰∏ÄÊÆµÊñêÊ≥¢ÈÇ£Â•ëÊï∞ÂàóÁöÑÊµãËØï‰ª£Á†Å,ÂÖ∂‰∏≠ PyPy ÊòØÂ∞Ü target ÂáΩÊï∞‰∏∫ÂÖ•Âè£ÂáΩÊï∞ÁöÑ„ÄÇÁªèËøáÊµãËØïÔºåËøô‰∏™ PyPy ÁâàÊú¨Â∑≤Áªè‰∏çÈúÄË¶ÅËøô‰∏™ÂÖ•Âè£ÂáΩÊï∞‰∫ÜÔºå‰πü‰∏çÈúÄË¶ÅÂêëDavidÂú® Pycon ÁöÑÂàÜ‰∫´‰∏≠ÈÇ£Ê†∑Áî® translate.py ÂÖàËøõË°åÁºñËØëÂÜçÊâßË°åcÊ∫êÁ†Å„ÄÇÔºàÂΩìÁÑ∂‰πüÂèØËÉΩÊòØÂè™Êúâ Rpython ÈúÄË¶ÅËøô‰πàÂÅö„ÄÇÔºâÊú¨ÊñáÊâÄÁî®ÁöÑÊñêÊ≥¢ÈÇ£Â•ëÊï∞ÂàóÁöÑÊ∫êÁ†ÅÂ¶Ç‰∏ãÔºö #fib.py import sys def fib ( n ): if n < 2 : return n else : return fib ( n - 1 ) + fib ( n - 2 ) def main ( argv ): print ( fib ( int ( argv [ 1 ]))) return 0 if __name__ == '__main__' : main ( sys . argv ) Êàë‰ª¨Áî®python2.7Ôºåpython3.6Ôºåpypy5.8Ëøô‰∏â‰∏™ÁéØÂ¢ÉÂÅöÊÄßËÉΩÊµãËØïÔºö python2.7 >> time python fib . py 41 165580141 real 0 m47 . 026 s user 0 m46 . 564 s sys 0 m0 . 024 s python3.6 >> time python fib . py 41 165580141 real 1 m9 . 771 s user 1 m8 . 992 s sys 0 m0 . 004 s pypy5.8 >> time pypy fib . py 41 165580141 real 0 m4 . 208 s user 0 m3 . 392 s sys 0 m0 . 736 s ‰ª•‰∏äÁªìÊûúÊòØÂú®ËôöÊãüÊú∫ÈáåÊµãËØïÁöÑÔºå‰ªÖ‰æõÂèÇËÄÉ„ÄÇÂèØ‰ª•ÂèëÁé∞ PyPy ÁöÑËøêÁÆóÈÄüÂ∫¶ÊØî Cpython Âø´‰∫ÜÈùûÂ∏∏Â§öÔºå‰ΩÜpython3ÊØîpython2ËøòÊÖ¢ËõÆÂ§öÁöÑÁ°ÆÂÆûËÆ©ÊàëÂæàÊ∞îÂïä„ÄÇÂΩìÁÑ∂ÔºåËøôÂè™ÊòØ‰∏Ä‰∏™Á∫ØcpuÂØÜÈõÜÂûãÁ®ãÂ∫èÁöÑËøêÁÆóÁªìÊûúÔºåÊ†πÊçÆ PyPy ÁöÑÁΩëÁ´ôÊâÄËØ¥ÔºåÂæóÁõä‰∫éJIT‰ª•ÂèäStacklessÔºå PyPy ÁöÑÂπ≥ÂùáÈÄüÂ∫¶Â∫îËØ•ÊòØ Cpython ÁöÑÂõõÂÄçÂ∑¶Âè≥„ÄÇ ÂÄºÂæó‰∏ÄÊèêÁöÑÊòØÔºåDavidÂú® Pycon ÊºîÁ§∫ÁöÑÈÇ£‰∏™ÂÖàÁºñËØëÂÜçËøêË°åÁöÑ PyPy ÁâàÊú¨ÔºåËøêË°åÁöÑÊñêÊ≥¢ÈÇ£Â•ëÊï∞ÂàóÁöÑÈÄüÂ∫¶ÁîöËá≥Ë∂ÖËøá‰∫ÜÊú™‰ºòÂåñÁöÑcÔºå‰∏ÄÁßíÈíüÂ∞±‰Ω†ÂÆåÊàêËØ•ËøêÁÆóÔºå‰ΩÜÂú®Ëøô‰∏™ÁâàÊú¨ÁöÑpypy‰∏≠Ê≤°ÊúâÁºñËØëÁöÑËøáÁ®ãÂπ∂‰∏î‰ºº‰πéÊ≤°Êúâ‰∫ÜDaivdÊèêÂà∞ÁöÑ Restrict Êï∞ÊçÆÁ±ªÂûãÁöÑÈôêÂà∂„ÄÇ Type restrict feature ‰∏∫‰∫ÜËØ¥Êòé PyPy ÁöÑÁº∫‰πèÂä®ÊÄÅÁ±ªÂûãÁöÑÊîØÊåÅÔºåDaivd‰∏æ‰∫Ü‰ª•‰∏ãÁöÑ‰æãÂ≠êÔºö lst = [ 1 , 2 , 3 , 'Hello' ] for item in lst Ôºö print ( lst ) class A ( object ): def __int__ ( self , x , y ): self . x = x self . y = y a = A ( 1 , 2 ) b = B ( 'Hello' , 'world' ) Ëøô‰∫õ‰ª£Á†ÅÊòØÈÄö‰∏çËøáÂΩìÊó∂ÁâàÊú¨ PyPy ÁöÑÁºñËØëÁöÑÔºåÁÑ∂ËÄåÂú®Áé∞Âú®ÁâàÊú¨‰∏≠ÂèØ‰ª•Ê≠£Â∏∏ËøêË°åÔºåËøôÁÇπÁùÄÂÆûËÆ©ÊàëÊÉäËÆ∂„ÄÇDavidÊèêÂà∞ÁöÑ‰∏Ä‰∏™ PyPy ÁöÑÁã¨ÁâπÂ§ÑÁêÜÊñπÂºèÔºåÂ∞±ÊòØËÆ≤Á∫Øpython‰ª£Á†ÅÂíårpython‰ª£Á†ÅÂàÜÂºÄÁºñËØëÔºåÊàëÊÉ≥ËøôÂ§ßÊ¶ÇÊòØÂÖ∂‰∏≠ÂéüÂõ†„ÄÇ Additional Understanding RPython Low Level RPython Let's Talk About PyPy PyPy documentation","tags":"Python","title":"How to run PyPy"},{"url":"leetcode-integer-break.html","text":"Description Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4). Note: You may assume that n is not less than 2 and not larger than 58. Source link Best practice ÁªèËøáÊûö‰∏æÂèØ‰ª•ÂèëÁé∞ÔºåËæìÂÖ•ÂÖÉÁ¥†ÊúÄÁªàÁöÑ‰∏çÂèØÂàÜÂçï‰Ωç‰∏∫2Âíå3ÔºàÊâÄÁªô‰æãÂ≠ê‰∏≠ÁöÑ10ÊúÄÂ∞èÂèØË¢´ÂàÜ‰∏∫3+3+2+2Ôºâ„ÄÇÁî±Ê≠§ÂèØËßÅÊàë‰ª¨Âè™ÈúÄË¶ÅÂú®Âè™‰∫ßÁîüËøô‰∏§Áßç‰∏çÂèØÂàÜÂÖÉÁ¥†ÁöÑÊÉÖÂÜµ‰∏ãÂ∞ΩÂèØËÉΩË¥™Â©™ÁöÑËé∑ÂèñÊõ¥Â§ö3Â∞±ËÉΩ‰ΩøË¢´breakÁöÑÂÖÉÁ¥†ÁßØÊúÄÂ§ß‰∫Ü„ÄÇÊõ¥Ê∑±ÂÖ•ÂèëÁé∞ÔºåËã•Ê¨≤‰ΩøÂÖÉÁ¥†ÁßØÊúÄÂ§ßÔºåÂè™‰ºöÂá∫Áé∞‰∏Ä‰∏™2Âíå‰∏§‰∏™2ÂÖÉÁ¥†ÁöÑÊÉÖÂÜµÔºåÂõ†Ê≠§Êàë‰ª¨ËÆæËÆ°ÁöÑ‰ª£Á†ÅÂ¶Ç‰∏ã„ÄÇ python version 1 class Solution ( object ): def integerBreak ( self , n ): \"\"\" :type n: int :rtype: int \"\"\" if n < 4 : return n - 1 if n % 3 == 0 : return 3 ** ( n // 3 ) if ( n - 2 ) % 3 == 0 : return 3 ** (( n - 2 ) // 3 ) * 2 if ( n - 4 ) % 3 == 0 : return 3 ** (( n - 4 ) // 3 ) * 2 ** 2 Mark: 32 ms ËøôÊòØleetcode‰∏äÁöÑpopÁöÑÁ≠îÊ°àÔºåÂÅèËÆ°ÁÆóÊú∫ÊÄùÁª¥„ÄÇÁî®ÊØîÁõÆÊ†áÂÖÉÁ¥†Â∞èÁöÑÂÖÉÁ¥†ÁöÑÁîüÊàêÁªìÊûúÊù•ËÆ°ÁÆó‰πãÂêéÁöÑÁªìÊûúÔºåÂÖ∂ÂÆûÂ§ö‰∫ÜÂæàÂ§öÂæ™ÁéØÔºå‰ΩÜ‰∏çÁü•ÈÅì‰∏∫‰ªÄ‰πàleetcodeÂ£∞Áß∞ËøêË°åËµ∑Êù•Êõ¥Âø´„ÄÇ python version 2 class Solution ( object ): def integerBreak ( self , n ): \"\"\" :type n: int :rtype: int \"\"\" if n < 4 : return n - 1 res = [ 0 , 1 , 2 , 3 ] for i in xrange ( 4 , n + 1 ): res [ i % 4 ] = max ( res [( i - 2 ) % 4 ] * 2 , res [( i - 3 ) % 4 ] * 3 ) return res [ n % 4 ] Mark: 28 ms Additional","tags":"Python","title":"LeetCode - Integer Break"},{"url":"python-descriptor-behavior-ii.html","text":"Description Âú®‰πãÂâç‰∏ÄÁØá ÊñáÁ´† ‰∏≠Êàë‰ª¨ËÆ®ËÆ∫‰∫ÜpythonÊèèËø∞Á¨¶‰ª•ÂèäÂÖ∂Ë°å‰∏∫Ôºå‰πüÂÅö‰∫Ü‰∏Ä‰∫õÊÄªÁªì„ÄÇ‰ΩÜ‰∏™‰∫∫ËÉΩÂäõÊúâÈôêÔºåÂØπÊèèËø∞Á¨¶ËÆøÈóÆÁöÑ‰ºòÂÖàËßÑÂàôËß£ÈáäÁöÑ‰∏çÊòØÈùûÂ∏∏Ê∏ÖÊ•ö„ÄÇ ËøëÊó•ÁúãÂà∞‰∏ÄÁØáÊñáÁ´†Ôºö Python‰∏≠ÁöÑÂ±ûÊÄßËÆøÈóÆ‰∏éÊèèËø∞Á¨¶ ‰∏≠ÂØπ‰∫éÂ±ûÊÄßËÆøÈóÆ‰ºòÂÖàËßÑÂàôÁöÑÈÉ®ÂàÜËß£ÈáäÁöÑÂæàÊ∏ÖÊô∞ÔºåÈÅÇËÆ∞ÂΩï‰∏ãÊù•Â≠¶‰π†„ÄÇ Â±ûÊÄßËÆøÈóÆÁöÑ‰ºòÂÖàËßÑÂàô Â±ûÊÄßËÆøÈóÆÁöÑÂÖ•Âè£ÁÇπÊòØ __getattribute__ ÊñπÊ≥ï„ÄÇÂÆÉÁöÑÂÆûÁé∞‰∏≠ÂÆö‰πâ‰∫ÜPython‰∏≠Â±ûÊÄßËÆøÈóÆÁöÑ‰ºòÂÖàËßÑÂàô„ÄÇPythonÂÆòÊñπÊñáÊ°£‰∏≠ÂØπ __getattribute__ ÁöÑÂ∫ïÂ±ÇÂÆûÁé∞ÊúâÁõ∏ÂÖ≥ÁöÑ‰ªãÁªçÔºåÊú¨ÊñáÊöÇÊó∂Âè™ÊòØËÆ®ËÆ∫Â±ûÊÄßÊü•ÊâæÁöÑËßÑÂàôÔºåÁõ∏ÂÖ≥ËßÑÂàôÂèØËßÅ‰∏ãÂõæÔºö ‰∏äÂõæÊòØÊü•Êâæb.xËøôÊ†∑‰∏Ä‰∏™Â±ûÊÄßÁöÑËøáÁ®ã„ÄÇÂú®ËøôÈáåË¶ÅÂØπÊ≠§ÂõæËøõË°åÁÆÄÂçïÁöÑ‰ªãÁªçÔºö Êü•ÊâæÂ±ûÊÄßÁöÑÁ¨¨‰∏ÄÊ≠•ÊòØÊêúÁ¥¢Âü∫Á±ªÂàóË°®ÔºåÂç≥type(b). mro ÔºåÁõ¥Âà∞ÊâæÂà∞ËØ•Â±ûÊÄßÁöÑÁ¨¨‰∏Ä‰∏™ÂÆö‰πâÔºåÂπ∂Â∞ÜËØ•Â±ûÊÄßÁöÑÂÄºËµãÂÄºÁªô descr Âà§Êñ≠descrÁöÑÁ±ªÂûã„ÄÇÂÆÉÁöÑÁ±ªÂûãÂèØÂàÜ‰∏∫Êï∞ÊçÆÊèèËø∞Á¨¶„ÄÅÈùûÊï∞ÊçÆÊèèËø∞Á¨¶„ÄÅÊôÆÈÄöÂ±ûÊÄß„ÄÅÊú™ÊâæÂà∞Á≠âÁ±ªÂûã„ÄÇËã•descr‰∏∫Êï∞ÊçÆÊèèËø∞Á¨¶ÔºåÂàôË∞ÉÁî®desc. get (b, type(b))ÔºåÂπ∂Â∞ÜÁªìÊûúËøîÂõûÔºåÁªìÊùüÊâßË°å„ÄÇÂê¶ÂàôËøõË°å‰∏ã‰∏ÄÊ≠• Â¶ÇÊûú descr ‰∏∫ÈùûÊï∞ÊçÆÊèèËø∞Á¨¶„ÄÅÊôÆÈÄöÂ±ûÊÄß„ÄÅÊú™ÊâæÂà∞Á≠âÁ±ªÂûãÔºåÂàôÊü•ÊâæÂÆû‰æãbÁöÑÂÆû‰æãÂ±ûÊÄßÔºåÂç≥b. dict „ÄÇÂ¶ÇÊûúÊâæÂà∞ÔºåÂàôÂ∞ÜÁªìÊûúËøîÂõûÔºåÁªìÊùüÊâßË°å„ÄÇÂê¶ÂàôËøõË°å‰∏ã‰∏ÄÊ≠•Ôºõ Â¶ÇÊûúÂú®b. dict Êú™ÊâæÂà∞Áõ∏ÂÖ≥Â±ûÊÄßÔºåÂàôÈáçÊñ∞ÂõûÂà∞ descr ÂÄºÁöÑÂà§Êñ≠‰∏ä„ÄÇ Ëã• descr ‰∏∫ÈùûÊï∞ÊçÆÊèèËø∞Á¨¶ÔºåÂàôË∞ÉÁî®desc. get (b, type(b))ÔºåÂπ∂Â∞ÜÁªìÊûúËøîÂõûÔºåÁªìÊùüÊâßË°å Ëã• descr ‰∏∫ÊôÆÈÄöÂ±ûÊÄßÔºåÁõ¥Êé•ËøîÂõûÁªìÊûúÂπ∂ÁªìÊùüÊâßË°åÔºõ Ëã• descr ‰∏∫Á©∫ÔºàÊú™ÊâæÂà∞ÔºâÔºåÂàôÊúÄÁªàÊäõÂá∫ AttributeError ÂºÇÂ∏∏ÔºåÁªìÊùüÊü•Êâæ„ÄÇ Additional","tags":"Python","title":"Python Descriptor Behavior II"},{"url":"leetcode-maximum-xor-of-two-numbers-in-an-array.html","text":"Description Given a non-empty array of numbers, $$ a_0, a_1, a_2, ‚Ä¶ , a_{n-1}, where 0 ‚â§ a_i < 2&#94;{31} $$ . Find the maximum result of a_i XOR a_j, where 0 ‚â§ i, j < n . Could you do this in O(n) runtime? Example: Input : [ 3 , 10 , 5 , 25 , 2 , 8 ] Output : 28 Explanation : The maximum result is 5 &#94; 25 = 28 . Source link Best practice Êàë‰ª¨‰ªéÂ∑¶Ëá≥Âè≥ÂØπÊØè‰∏Ä‰ΩçËøõË°åÂà§Êñ≠ÔºåÂú®Ëøô‰∏™ËøáÁ®ã‰∏≠ÈÄêÊ∏êÁº©Â∞èË¢´Êàë‰ª¨ÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†ËåÉÂõ¥„ÄÇÂÅáËÆæËæìÂÖ•ÂàóË°®ÂåÖÂê´26‰∏™Êï¥Êï∞ÔºàÂú®ËøôÈáåÊàë‰ª¨‰ª•a,b,c,dËá≥zÊù•Ë°®Á§∫Ôºâ„ÄÇÂêëÂè≥ÈÅçÂéÜÊó∂ÔºåÂΩìÊüêÂá†‰∏™Êï∞a,d,e,h,uÂú®ÊúÄÂ§ß‰∫åËøõÂà∂‰Ωç‰∏ä‰∏çÂêåÊó∂ÔºåÂ∞±ÂèØ‰ª•Á°ÆÂÆöËØ•‰Ωç‰∏∫Êàë‰ª¨ÊúÄÁªàÁ≠îÊ°àÁöÑÊúÄÂ§ß‰∫åËøõÂà∂‰Ωç‰∫Ü„ÄÇÂõ†‰∏∫ËØ•‰Ωç‰∏∫1ÁöÑÊÉÖÂÜµÂ§ß‰∫éËØ•‰ΩçÂè≥‰æßÊâÄÊúâ‰Ωç‰∏∫1ÁöÑÊÉÖÂÜµ„ÄÇÂú®‰∏ãÊ¨°ÈÅçÂéÜÊó∂Êàë‰ª¨Â∞±ÂèØ‰ª•Ê£ÄÊü•ËøôÂá†‰∏™Êï∞‰∏≠ÁöÑÊ¨°Â§ß‰∫åËøõÂà∂‰ΩçÊòØÂê¶‰∏çÂêåÔºå‰πüÂ∞±ÂèØ‰ª•Á°ÆÂÆöÊ¨°Â§ß‰∫åËøõÂà∂‰ΩçÁöÑÂÄºÔºåÊàë‰ª¨ÁöÑÂÄôÈÄâÁªÑ‰πü‰ºö‰ªéa,d,e,h,uÁº©Â∞èËá≥a,e,hÁöÑÊÉÖÂÜµ„ÄÇËøô‰∏™ÈóÆÈ¢òÁöÑÁâπÊÄßÊòØÔºåÊØèÊ¨°Êàë‰ª¨Áº©Â∞èÂÄôÈÄâÂÖÉÁ¥†ËåÉÂõ¥Êó∂ÔºåÊàë‰ª¨‰∏çÈúÄË¶ÅÂÖ≥ÂøÉÂì™‰∫õÂÖÉÁ¥†Áïô‰∏ãÊù•‰∫ÜÔºåÂè™ÈúÄË¶ÅÁü•ÈÅìÊàë‰ª¨ÁöÑÊúÄÁªàÁ≠îÊ°àÊòØÂ§öÂ∞ë„ÄÇ python version class Solution ( object ): def findMaximumXOR ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" max , mask = 0 , 0 for i in reversed ( range ( 32 )): mask = mask | ( 1 << i ) #prefix set prefixes = { num & mask for num in nums } temp = max | ( 1 << i ) for prefix in prefixes : # Âõ†‰∏∫1&#94;0=1,1&#94;1=0,0&#94;0=0,ÊâÄ‰ª•ÂΩìa&#94;b=cÊó∂Ôºåa&#94;c=b # item1&#94;item2=temp,item1&#94;temp=item2 if prefix &#94; temp in prefixes : max = temp break return max Mark: 129 ms Additional","tags":"Python","title":"LeetCode - Maximum XOR of Two Numbers in an Array"},{"url":"leetcode-total-hamming-distance.html","text":"Description The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers. Example: Input : 4 , 14 , 2 Output : 6 Explanation : In binary representation , the 4 is 0100 , 14 is 1110 , and 2 is 0010 ( just showing the four bits relevant in this case ). So the answer will be : HammingDistance ( 4 , 14 ) + HammingDistance ( 4 , 2 ) + HammingDistance ( 14 , 2 ) = 2 + 2 + 2 = 6 . Note: 1. Elements of the given array are in the range of 0 to 10&#94;9 2. Length of the array will not exceed 10&#94;4 . Source link Best practice ÁªèËøáËßÇÂØüÂèØ‰ª•ÂèëÁé∞ÔºåÊâÄÊúâÂàóË°®‰∏≠ÂÖÉÁ¥†ÁöÑÊ±âÊòéË∑ùÁ¶ª‰πüÂèØ‰ª•Áî®‰ªñ‰ª¨ÂêÑ‰∏™‰Ωç‰∏≠ÁöÑ0Âíå1ÁöÑÂàÜÂ∏ÉÊÉÖÂÜµÊù•ÂæóÂá∫„ÄÇ‰æãÂ¶ÇÂÖ±ÊúâÂÖ´‰∏™ÂÖÉÁ¥†ÔºåÊâÄÊúâÂÖÉÁ¥†ÁöÑ2&#94;0‰ΩçÊúâ‰∏â‰∏™1‰∫î‰∏™0ÔºåÂàôËØ•‰ΩçÂØπÊï¥‰ΩìÊ±âÊòéË∑ùÁ¶ªÁöÑË¥°ÁåÆ‰∏∫3 5„ÄÇÊú¨È¢ò‰∏≠ÊâÄÊèèËø∞ÁöÑtotal hamming distanceÂèØ‰ª•Áî±ÊâÄÊúâ‰Ωç‰∫ßÁîüÁöÑÊ±âÊòéË∑ùÁ¶ªÁöÑÂíåË°®Á§∫„ÄÇËøôÊ†∑ÁöÑÂπ≥ÂùáÊó∂Èó¥Â§çÊùÇÂ∫¶‰ΩçO(n m),m‰∏∫ÂÖÉÁ¥†‰∫åËøõÂà∂‰ΩçÂπ≥ÂùáÈïøÂ∫¶„ÄÇ python version from collections import defaultdict class Solution ( object ): def totalHammingDistance ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" result = 0 for i in range ( 32 ): count = 0 # ÂàóË°®‰∏≠ÊâÄÊúâÂÖÉÁ¥†Á¨¨i‰Ωç‰∏≠ÁöÑ1ÁöÑÊï∞Èáè bit = ( 1 << i ) # ÂèÇÁÖß‰∫åËøõÂà∂Êï∞ for item in nums : if item & bit : count += 1 result += count * ( len ( nums ) - count ) return result Mark: 268 ms Additional","tags":"Python","title":"LeetCode - Total Hamming Distance"},{"url":"leetcode-maximum-length-of-pair-chain.html","text":"Description You are given n pairs of numbers. In every pair, the first number is always smaller than the second number. Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c . Chain of pairs can be formed in this fashion. Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order. Example 1: Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4] Note: 1. The number of given pairs will be in the range [1, 1000]. Source link Best practice Êú¨È¢òÁöÑÂÖ≥ÈîÆÂú®‰∫éÂáèÂ∞ëÊó∂Èó¥Â§çÊùÇÂ∫¶„ÄÇÂ∞ùËØï‰∫ÜÊéíÂ∫èÂêéÂèëÁé∞ÔºåÂ∞ÜÂàóË°®ÂÖÉÁªÑÊåâÁ¨¨‰∫å‰∏™ÂÖÉÁ¥†ÊéíÂ∫èÊòØ‰∏Ä‰∏™Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫oÔºànÔºâÁöÑËß£ÂÜ≥ÊñπÊ°à„ÄÇ‰∏æ‰æãÊù•ËØ¥Ôºå[5,6]ÂâçÊâÄËÉΩÊé•ÁöÑÂÖÉÁ¥†ÈìæÈïøÂ∫¶ÊÄªÂ§ß‰∫éÁ≠â‰∫é[4,6]ÔºåÂõ†Ê≠§ÊåâÊ≠§ÊéíÂ∫èÂêé‰ªéÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†ÂºÄÂßãÈÅçÂéÜÁ≠õÈÄâÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇËøôÈáåÊàë‰ª¨Ê≤°ÊúâÂú®ÈÅáÂà∞Êã•ÊúâÁõ∏ÂêåÁ¨¨‰∫å‰∏™ÂÖÉÁ¥†ÁöÑÂÖÉÁªÑÊó∂‰ΩøÁî®ÂèñÊúÄÂ§ßÂÄºÁöÑÊñπÊ≥ïÔºåÂõ†‰∏∫ÊôÆÈÄöÁöÑÈ°∫Â∫èÈÅçÂéÜÂ∞±ËÉΩÂæóÂà∞oÔºànÔºâÂ§çÊùÇÂ∫¶ÁöÑÁÆóÊ≥ï‰∫Ü„ÄÇ python version from operator import itemgetter class Solution ( object ): def findLongestChain ( self , pairs ): \"\"\" :type pairs: List[List[int]] :rtype: int \"\"\" last , n = None , 0 for item in sorted ( pairs , key = itemgetter ( 1 )): if last is None : last , n = item , 1 elif item [ 0 ] > last [ 1 ]: last , n = item , n + 1 return n Mark: 75 ms Additional","tags":"Python","title":"LeetCode - Maximum Length of Pair Chain"},{"url":"yi-ge-jian-dan-de-wen-ben-jie-xi-ji-suan-qi.html","text":"Description ‰πãÂâçÂú®„Ääpython cookbook„Äã‰∏ä8.22ËäÇÁúãÂà∞‰∫ÜÁî®ÈùûÈÄíÂΩíÁöÑÊñπÂºèÂÆûÁé∞ËÆøÈóÆËÄÖÊ®°ÂºèÁöÑ ÊñπÊ≥ï ÔºåÈÄöËøáÂ∑ßÂ¶ôÂú∞‰ΩøÁî®ÁîüÊàêÂô®ÁöÑÊñπÂºèÂú®Ê†ëÈÅçÂéÜÊàñËÄÖÊêúÁ¥¢ÁÆóÊ≥ï‰∏≠‰∏≠Ê∂àÈô§ÈÄíÂΩí„ÄÇ‰ªéËÄåÈÅøÂÖç‰∫ÜÂú®‰ΩøÁî®ËÆøÈóÆËÄÖÊ®°ÂºèÈÅçÂéÜÊ∑±Â±ÇÂµåÂ•óÊ†ëÂΩ¢Êï∞ÊçÆÁªìÊûÑÊó∂ÔºåÂõ†‰∏∫Ë∂ÖËøáÂµåÂ•óÂ±ÇÁ∫ßÈôêÂà∂ËÄåÂ§±Ë¥•ÁöÑÊÉÖÂÜµ„ÄÇ ÂéüÊñáÊòØDavid DabeazÂü∫‰∫épython3.3ÁâàÊú¨ÊûÑÂª∫ÁöÑÔºåÂæà‰∏çÂáëÂ∑ßÁöÑÊòØÔºåÂú®python3.4ÁâàÊú¨ÂèàÊé®Âá∫‰∫Ü‰∏Ä‰∏™ÈùûÂ∏∏Âº∫Â§ßÁöÑÂçèÁ®ãÂíåÁîüÊàêÂô®ÁöÑÊñ∞ÁâπÊÄßÔºö yield from ÔºåËøôÊó†Áñë‰∏∫Êàë‰ª¨Â¢ûÊ∑ª‰∫ÜÊñ∞ÁöÑÁé©ÂÖ∑„ÄÇ 2014Âπ¥ÔºåDabeazÁöÑ Final generator ËÆ≤Â∫ßÂÖ®Èù¢Âú∞‰ªãÁªç‰∫ÜËÆ∏Â§öÂçèÁ®ãÁºñÂÜôÁöÑËØÄÁ™çÂπ∂‰∏îÁÇ∏ÊØÅ‰∫ÜËÆ∏Â§öÂê¨‰ºóÁöÑÂ§ßËÑëÔºàÂåÖÊã¨Á¨îËÄÖÁöÑÔºâÔºåÂú®ËØæÁ®ãÁöÑÊúÄÂêé‰∏ÄÈÉ®ÂàÜ‰ªñÂèà‰ªéÂ§¥Áî®ÂçèÁ®ã‰ª£Êõø‰∫ÜÁªèÂÖ∏ÁöÑËÆøÈóÆËÄÖÊ®°ÂºèÔºåÁî®‰∫éËÆ°ÁÆóÁÆóÊúØË°®ËææÂºè„ÄÇÂèó‰ªñÁöÑËØæÁ®ãÁöÑÂºïÂØºÂíåÂêØÂèë‰æøÊúâ‰∫ÜÊú¨Êñá„ÄÇ ‰ª£Á†ÅÂÆûÁé∞ Êàë‰ª¨Â∏åÊúõÂÆûÁé∞ÁöÑËÆ°ÁÆóÂô®ËÉΩÂ§üËøôÊ†∑‰ΩøÁî®Ôºö cal = Calculator () cal . caculate ( '1+2*4-5&#94;2' ) >>> - 16 ‰ªéÈÄªËæë‰∏äÊù•ËØ¥ÔºåËøô‰∏™ÊñáÊú¨ËÆ°ÁÆóÂô®‰ºö‰∏∫Êàë‰ª¨ÂàÜ‰∏âÊ≠•ÂÅö‰∫ãÊÉÖÔºö Ëß£Êûê‰º†ÂÖ•ÊñáÊú¨ÔºåÂ∞ÜÊñáÊú¨ËΩ¨Êç¢ÊàêÂèØËØÜÂà´ÂçïÂÖÉ„ÄÇÂæàÂÆπÊòìÊÉ≥Âà∞ÁöÑÊòØ‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÊù•Ëß£ÊûêÊñáÊú¨„ÄÇ Á°ÆÂÆöËøêÁÆóÁöÑÂÖàÂêéÈ°∫Â∫èÔºåÂ¶Ç‰πòÈô§‰ºòÂÖà‰∫éÂä†Âáè„ÄÇÂú®ËøôÈáåÊàë‰ª¨Â∞ÜËØÜÂà´Â•ΩÁöÑÂçïÂÖÉÊûÑÈÄ†ÊàêÊ†ëÊù•‰ΩìÁé∞ËøêÁÆóÁöÑ‰ºòÂÖàÁ∫ß„ÄÇ Ê∑±Â∫¶ÈÅçÂéÜÁîüÊàêÊ†ëÔºåËÆ°ÁÆóÂπ∂ËæìÂá∫ÁªìÊûú„ÄÇ Êé•‰∏ãÊù•Êàë‰ª¨Â∞±Êù•‰∏ÄÊ≠•‰∏ÄÊ≠•ÂÆûÁé∞Ëøô‰∏ÄÁÆÄÊòìÁºñËØëÂô®„ÄÇ ÂáÜÂ§áÂ∑•‰Ωú Êú¨Êñá‰ª£Á†ÅÁéØÂ¢É‰∏∫python3.6„ÄÇ È¶ñÂÖàÂÆö‰πâÂ•ΩÊ≠§Ê¨°ÊâÄÈúÄÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇÂú®ËøôÈáåÊàë‰ª¨Âà©Áî®‰∫ÜDavidÂú® Python 3 Metaprogramming ‰∏≠ÊâÄÊèèËø∞ÁöÑÂÖÉÁºñÁ®ãÁöÑÊñπÂºèÊù•ÊâπÈáèÂú∞ÊûÑÈÄ†ÁÆÄÂçïÁªìÊûÑÁ±ªÂûã„ÄÇËøôÈáåÊàë‰ª¨ÂØπ‰ªñÁöÑ‰ª£Á†ÅÁ®ç‰ΩúÊîπËøõÔºå‰ΩøÂÖ∂ÊîØÊåÅÈªòËÆ§ÂèÇÊï∞ÂèäÂèÇÊï∞Ê≥®Èáä„ÄÇËøô‰πüÁÆóÊàë‰ª¨ÂØπÂÖÉÁºñÁ®ãÁöÑ‰∏Ä‰∏™Â∞èÂ∞èÂÆûË∑µÔºåËØªËÄÖ‰∏çÈúÄË¶ÅÁêÜËß£ËøôÈÉ®ÂàÜÁöÑÂÜÖÂÆπÂ∞±ÂèØ‰ª•ÂÆåÊàê‰Ωô‰∏ãÁöÑÈòÖËØª„ÄÇ ËøôÈáå‰πüÁî®Âà∞‰∫Üpython3ÁöÑÊñ∞ÁâπÊÄßÔºå inpect Ê®°ÂùóÁöÑsignatureÈÉ®ÂàÜÔºåÂÖ∑‰ΩìÂèØÂèÇËßÅ ÂÆòÊñπÊñáÊ°£ „ÄÇ ÂÆö‰πâÊï∞ÊçÆÁªìÊûÑÁöÑ‰ª£Á†ÅÂ¶Ç‰∏ãÔºö import re import types from collections import namedtuple from functools import singledispatch from inspect import Parameter , Signature def make_signature ( names ): \"\"\"Áî®‰∏Ä‰∏™ÂàóË°®Êù•‰∫ßÁîüÂèÇÊï∞Á≠æÂêçÁöÑÊ®°ÂùóÂáΩÊï∞,‰πüÂèØ‰ª•ÊîæÂú®StructureMetaÂÜÖÈÉ®\"\"\" parameters = [] #ÊäìÂá∫ÂèÇÊï∞ÁöÑÂêçÁß∞„ÄÅÈªòËÆ§ÂÄºÂíåÊ≥®Èáä parameter_re = re . compile ( r '&#94;(?P<name>\\w+)(\\s*=\\s*(?P<default>\\w+))?(\\s*:\\s*(?P<annotation>\\w+))?$' ) for name in names : re_result = parameter_re . match ( name ) if not re_result : raise SyntaxError ( 'Invalid parameter syntaxÔºö {} ' . format ( name )) parameters . append ( Parameter ( kind = Parameter . POSITIONAL_OR_KEYWORD , ** re_result . groupdict ())) #ÊîØÊåÅÂèÇÊï∞ÈªòËÆ§ÂÄºÂíåÊ≥®Èáä return Signature ( parameters ) class StructureMeta ( type ): \"\"\" StructureÁ±ªÁöÑÂÖÉÁ±ªÔºåÂú®ÁîüÊàêclassÁöÑÊó∂ÂÄôÂ∞Ü_fieldsÈáåÊèê‰æõÁöÑÂ±ûÊÄßËΩ¨Âåñ‰∏∫ ÂèÇÊï∞Á≠æÂêçÁ±ªÂ±ûÊÄß„ÄÇ \"\"\" def __new__ ( cls , name , bases , clsdict ): clsobj = super () . __new__ ( cls , name , bases , clsdict ) sig = make_signature ( clsobj . _fields ) setattr ( clsobj , '__signature__' , sig ) return clsobj class Structure ( metaclass = StructureMeta ): \"\"\"ÁÆÄÊòìÊï∞ÊçÆÁªìÊûÑÊûÑÈÄ†Áà∂Á±ª\"\"\" _fields = [] def __init__ ( self , * args , ** kwargs ): # ËøôÈáåÂÆûÈôÖ‰∏äÂèñÁöÑÊòØself.__class___.__signature__ bound = self . __signature__ . bind ( * args , ** kwargs ) for name , val in bound . arguments . items (): setattr ( self , name , val ) class Number ( Structure ): \"\"\"Êï∞Â≠óÂûã\"\"\" _fields = [ 'value' ] class BinOp ( Structure ): \"\"\"Êìç‰ΩúÁ¨¶Âè∑Âûã\"\"\" _fields = [ 'op' , 'left' , 'right' ] ÂÖ∂Ê¨°ÂàôÊòØË¶Å‰ΩøÁî®ÁöÑCalculatorÁöÑÂü∫Êú¨Ê°ÜÊû∂Ôºå‰∏â‰∏™ÂÖ≥ÈîÆÊ≠•È™§ÁöÑÂáΩÊï∞ËÆ≤Âú®‰Ωô‰∏ãËäÇÂÜÖÂÆπ‰∏Ä‰∏ÄÂÆûÁé∞Ôºö class Calculator : # ÂèØ‰ª•Ë¢´tokenizeÂáΩÊï∞Ëß£ÊûêÁöÑÂ≠óÁ¨¶ TOKENS = [ r '(?P<NUM>\\d+)' , r '(?P<PLUS>\\+)' , r '(?P<MINUS>-)' , r '(?P<TIMES>\\*)' , r '(?P<DIVIDE>/)' , r '(?P<POWER>\\&#94;)' , r '(?P<WS>\\s+)' , ] # ÂÇ®Â≠òÂ≠óÁ¨¶Á±ªÂûãÂíåÂÄºÁöÑÂÖÉÁªÑ Token = namedtuple ( 'Token' , [ 'type' , 'value' ]) def __init__ ( self , token = None ): if token : self . TOKENS = token # È¢ÑÁºñËØëÊ≠£ÂàôË°®ËææÂºè self . MASTER_RE = re . compile ( '|' . join ( self . TOKENS )) def caculate ( self , text ): \"\"\"Ëß£ÊûêÂπ∂ËÆ°ÁÆóË°®ËææÂºè\"\"\" self . text = text try : token = self . _tokenize ( text ) tree = self . _parse ( token ) result = self . _evaluate ( tree ) except Exception as e : raise e return result def _tokenize ( self , text ): \"\"\"‰ªéÂ≠óÁ¨¶‰∏≤ÂºÄÂßãÊâ´ÊèèÊâÄÊúâÂåπÈÖçÂ≠óÁ¨¶,ËæìÂá∫ÊâÄÊúâÈùûÁ©∫ÂÖÉÁ¥†\"\"\" pass def _parse ( self , toks ): \"\"\"Â∞ÜtokenizeÂêéÁöÑÂÖÉÁ¥†parseÊàêÊ†ëÁªìÊûÑ\"\"\" pass def _evaluate ( self , node ): \"\"\"ÈÅçÂéÜÁîüÊàêÊ†ëËÆ°ÁÆóÁªìÊûú\"\"\" pass ÂØπ‰∫éÊï∞ÊçÆÁªìÊûÑÁ±ªÊàë‰ª¨‰ΩøÁî®‰∫Ü‰∏ÄÁßçÁÆÄÂçïÁ≤óÊö¥ÁöÑÊûÑÈÄ†ÊñπÊ≥ïÔºöÁõ¥Êé•ËÆæÁΩÆÊàêÁ±ªÁöÑÂ±ûÊÄß„ÄÇÂÖ∂ÂÆûËøô‰πüÊòØ‰∏ÄÁßçËõÆÂ∏∏Áî®ÁöÑÊñπÊ≥ïÔºåÈÄÇÂêàÊûÑÈÄ†Â§ßÈáèÁÆÄÂçïÊï∞ÊçÆÁªìÊûÑÁ±ª„ÄÇ ÂØπ‰∫éËÆ°ÁÆóÂô®Á±ªÔºåÊàë‰ª¨ÂºÄÊîæ‰∫Ücaculate apiÊé•Âèó‰º†ÂÖ•ÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÂπ∂ÁªèËøá‰∏äÊñáËÆ∫Ëø∞ÁöÑ‰∏â‰∏™Ê≠•È™§Êù•ËæìÂá∫ÁªìÊûú„ÄÇÂΩìÁÑ∂Êàë‰ª¨‰πüÂèØ‰ª•Áõ¥Êé•Ë∞ÉÁî®Ëøô‰∏â‰∏™Ê≠•È™§ÁöÑÊñπÊ≥ïÊù•ËøõË°åË∞ÉËØïÂíåÁª¥Êä§ÔºåÊàë‰ª¨Êé•‰∏ãÊù•ÁöÑ‰ªªÂä°Â∞±ÊòØÂàÜÂà´ÂÆûÁé∞Ëøô‰∏â‰∏™ÊñπÊ≥ï„ÄÇ Tokenize def _tokenize ( self , text ): \"\"\"‰ªéÂ≠óÁ¨¶‰∏≤ÂºÄÂßãÊâ´ÊèèÊâÄÊúâÂåπÈÖçÂ≠óÁ¨¶,ËæìÂá∫ÊâÄÊúâÈùûÁ©∫ÂÖÉÁ¥†\"\"\" try : scan = self . MASTER_RE . scanner ( text ) except Exception as e : raise e return ( self . Token ( m . lastgroup , m . group ()) for m in iter ( scan . match , None ) if m . lastgroup != 'WS' ) Tokenize ÊñπÊ≥ïÊ†πÊçÆÁ±ªÂèòÈáè TOKENS ÈáåÁöÑÊ≠£ÂàôË°®ËææÂºèÊçïËé∑ÂåπÈÖçÂ≠óÁ¨¶ÁªÑÂπ∂‰∏îÂ∞ÜÂÆÉ‰ª¨ÂëΩÂêçÔºå‰πãÂêéËøîÂõûÊâÄÊúâÈùûÁ©∫Ê†ºÁöÑÂ≠óÁ¨¶ÂÖÉÁ¥†„ÄÇ ËøôÈáåÂÄºÂæó‰∏ÄÊèêÁöÑÊòØ re Ê®°ÂùóÁöÑ scanner ÊñπÊ≥ï„ÄÇ‰∏çÁü•ÈÅìÊòØ‰∏çÊòØÂàªÊÑèËÄå‰∏∫‰πãÔºåÂÆÉÊ≤°Êúâ‰ªª‰ΩïÂÆòÊñπÁöÑÊñáÊ°£„ÄÇÂú®Êàë‰ª¨Ëøô‰∏™ÁÆÄÂçïÁºñËØëÂô®ÁöÑÊÉÖÊôØ‰∏ãÔºåÂÆÉÈÄê‰∏™Êâ´Êèè‰º†ÂÖ•Â≠óÁ¨¶‰∏≤ÈáåÁöÑÊâÄÊúâÁ¨¶ÂêàÊ≠£ÂàôË°®ËææÂºèÁöÑÂÖÉÁ¥†Âπ∂ËæìÂá∫„ÄÇ ÂØπ‰∫é 1+2*4-5&#94;2 Êàë‰ª¨Â∞ÜÁîüÊàêËøô‰∫õÂÖÉÁ¥†Ôºö cal = Calculator () cal . text = '1+2*4-5&#94;2' for item in cal . _tokenize ( cal . text ): print ( item ) >>> Token ( type = 'NUM' , value = '1' ) Token ( type = 'PLUS' , value = '+' ) Token ( type = 'NUM' , value = '2' ) Token ( type = 'TIMES' , value = '*' ) Token ( type = 'NUM' , value = '4' ) Token ( type = 'MINUS' , value = '-' ) Token ( type = 'NUM' , value = '5' ) Token ( type = 'POWER' , value = '&#94;' ) Token ( type = 'NUM' , value = '2' ) Parse def _parse ( self , toks ): \"\"\"Â∞ÜtokenizeÂêéÁöÑÂÖÉÁ¥†parseÊàêÊ†ëÁªìÊûÑ\"\"\" lookahead , current = next ( toks , None ), None def accept ( * toktypes ): \"\"\"Âà§Êñ≠ÁîüÊàêÂô®toksÁöÑ‰∏ã‰∏™ÂÖÉÁ¥†ÊòØÂê¶‰∏∫‰º†ÂÖ•Á±ªÂûã\"\"\" nonlocal lookahead , current if lookahead and lookahead . type in toktypes : current , lookahead = lookahead , next ( toks , None ) return True # Ë°®ËææÂºèÁªìÊûÑÔºö # expr ::= term { +|- term }* # term ::= pow { *|/ pow}* # pow ::= factor { &#94; factor}* # factor ::= NUM def expr (): left = term () while accept ( 'PLUS' , 'MINUS' ): left = BinOp ( current . value , left ) left . right = term () return left def term (): left = pow () while accept ( 'TIMES' , 'DIVIDE' ): left = BinOp ( current . value , left ) left . right = pow () return left def pow (): left = factor () while accept ( 'POWER' ): left = BinOp ( current . value , left ) left . right = factor () return left def factor (): if accept ( 'NUM' ): return Number ( int ( current . value )) else : raise SyntaxError () return expr () Parse ÊñπÊ≥ïÈÄöËøá accept ÂáΩÊï∞Êù•ÈÅçÂéÜ tokenize ËøîÂõûÁöÑÂ≠óÁ¨¶ÂÖÉÁ¥†Ëø≠‰ª£Âô®ÔºåÂπ∂ÈÄöËøáÊ†ëÁä∂ÁöÑÂáΩÊï∞ÁªìÊûÑÊù•ÁîüÊàê‰∏ÄÊ£µÁúüÊ≠£ÁöÑÊ†ë„ÄÇÈùûÂ∏∏Ê¨£ËµèÂÆÉÁöÑÊ®°‰ªøËÉΩÂäõ„ÄÇ ÂÆÉÂ∞ÜË°®ËææÂºèÂú®ËØ≠ÊÑè‰∏äÂàÜ‰∏∫‰∏âÁßçÁ±ªÂûãÔºötermÔºåpowÔºåfactor (ÂÆûÈôÖ‰∏äËøô‰∫õÂêçÂ≠óÊ≤°‰ªÄ‰πàÁâπÂà´ÁöÑÊÑèÊÑè‰πâ)„ÄÇ‰æãÂ¶Ç 1+2*4-5&#94;2 Ëøô‰∏™Ë°®ËææÂºèÔºåfactor‰∏∫ÊúÄÂ∞èÂçïÂÖÉÂç≥Êï∞Â≠óÔºåfactorÁªÑÊàêpowÂç≥ 1 2 4 5&#94;2 ‰∏∫Ê¨°Â∞èÂçïÂÖÉÔºåpowÁªÑÊàêterm 1 2*4 5&#94;2 ,termÁªÑÊàêË°®ËææÂºèÊù•‰ΩìÁé∞ËøêÁÆóÁ¨¶ÁöÑ‰ºòÂÖàÁ∫ß„ÄÇ ÂØπ‰∫é 1+2*4-5&#94;2 Êàë‰ª¨ÂèØ‰ª•ËøôÊ†∑ÁîüÊàêÊ†ëÔºö cal = Calculator () cal . text = '1+2*4-5&#94;2' print ( cal . _parse ( cal . _tokenize ( cal . text ))) Evaluate def _evaluate ( self , node ): \"\"\"ÈÅçÂéÜÁîüÊàêÊ†ëËÆ°ÁÆóÁªìÊûú\"\"\" @singledispatch def visit ( obj ): raise NotImplemented @visit . register ( BinOp ) def _ ( node ): \"\"\" ÂçèÁ®ã„ÄÇ visit method for BinOp \"\"\" left = yield node . left right = yield node . right # TODO: could be more dynamic switch = { '+' : lambda x , y : x + y , '-' : lambda x , y : x - y , '*' : lambda x , y : x * y , '/' : lambda x , y : x / y , '&#94;' : lambda x , y : x ** y , } try : return switch . get ( node . op , None )( left , right ) # ‰∫ßÁîüStopIterationÂπ∂ËøîÂõûÁªìÊûú except TypeError as e : pass @visit . register ( Number ) def _ ( node ): \"\"\"visit method for number\"\"\" return node . value def gen_visit ( node ): \"\"\" ÂßîÊ¥æÁîüÊàêÂô®„ÄÇ ËøîÂõûËæìÂÖ•Êï∞ÂÄºÂèä‰∏≠Èó¥ÂÄº„ÄÇ \"\"\" result = visit ( node ) return ( yield from result ) if isinstance ( result , types . GeneratorType ) else result stack = [ gen_visit ( node )] # Â∞ÜÊ†πËäÇÁÇπÁöÑÂçèÁ®ãÊîæÂÖ•Ê†à result = None while stack : try : node = stack [ - 1 ] . send ( result ) # send(None)È¢ÑÊøÄÂçèÁ®ãÔºåsendÔºàresultÔºâÂ∞ÜËÆ°ÁÆóÂ•ΩÁöÑÂÄºÂ≠òÂÖ•ÂçèÁ®ã stack . append ( gen_visit ( node )) # Ê∑±Â∫¶ÈÅçÂéÜÊ∑ªÂä†ÂçèÁ®ãÔºåÁ≠âÂæÖÂ§ÑÁêÜ result = None except StopIteration as e : stack . pop () result = e . value # ÂèñÂæónumberÁöÑÂÄºÊàñË°®ËææÂºèËÆ°ÁÆóÂÄº return result Evalute ÂáΩÊï∞ÈÅçÂéÜ parse ÊâÄÁîüÊàêÁöÑÊ†ëÂπ∂ËÆ°ÁÆóÁªìÊûú„ÄÇÂú®ËøôÈáåÊàë‰ª¨Áî®3.4Êñ∞Âä†ÂÖ•ÁöÑ singledispatch Êù•Êõø‰ª£ÂéüÂÖàDabeaz‰ΩøÁî®ÁöÑÊñπÂºèÔºö methname = 'visit_' + type ( node ) . __name__ meth = getattr ( self , methname , None ) ÊØîËæÉÂÆπÊòìËÆ©‰∫∫ÁÇ∏ËÑëÁöÑÊòØÁî®listÊù•ÁÆ°ÁêÜÊ†àÁöÑËøáÁ®ã„ÄÇ‰ª• 1+2*4-5 Ëøô‰∏™Ë°®ËææÂºè‰∏æ‰æãÔºå‰º†ÂÖ• evaluate ÊñπÊ≥ïÁöÑÁîüÊàêÊ†ëÊòØËøôÊ†∑ÁöÑ„ÄÇ Á¨¨‰∏ÄÂ±Ç: BinOp \"-\" Number Á¨¨‰∫åÂ±ÇÔºö Number \"+\" BinOp 5 Á¨¨‰∏âÂ±ÇÔºö 1 Number \"*\" Number Á¨¨ÂõõÂ±ÇÔºö 2 4 Â¶ÇÊûú‰Ω†ÂèëÁé∞Ëá™Â∑±Êó†Ê≥ïÁêÜËß£ÊàëÁöÑÁªòÁîª‰ΩúÂìÅÁöÑËØù‰∏çÂ¶®Ë∑ë‰∏ã parse ÊñπÊ≥ï„ÄÇ Êàë‰ª¨ÂÖàÂ∞ÜÂàùÂßãÂåñÊ†πËäÇÁÇπÁöÑÂßîÊ¥æÁîüÊàêÂô®ÂÖ•Ê†àÔºåËÆ∞ËØ•ÂßîÊ¥æÁîüÊàêÂô® gen_visit ‰∏∫ A Ôºå‰º†ÂÖ•NoneÈ¢ÑÊøÄ A , visit(BinOp('-',x,y)) ËøîÂõûÂçèÁ®ã a ÔºåÁî±‰∫éËØ•ÂçèÁ®ã‰∏∫ÁîüÊàêÂô®Â≠êÁ±ªÔºåËøõÂÖ• return ËØ≠Âè•‰∏≠ÁöÑ yield from result Â≠êÂè•‰ª£ÁêÜÁöÑÂçèÁ®ã a Ôºå yield Âá∫ BinOp('-',x,y) ÁöÑÂ∑¶ËäÇÁÇπ BinOp('+',x,y) „ÄÇÂ∞ÜÂÖ∂‰º†ÂÖ•ÂßîÊ¥æÁîüÊàêÂô® B Âπ∂ÂÖ•Ê†à„ÄÇÊ≠§Êó∂ÂçèÁ®ã a Ëµ∞Ëá≥ left = yield node.left ËØ≠Âè•ÁöÑÁ≠âÂè∑Âè≥Ëæπ„ÄÇ ‰º†ÂÖ•NoneÈ¢ÑÊøÄÂßîÊ¥æÁîüÊàêÂô® B , visit(BinOp('+',x,y)) ËøîÂõûÂçèÁ®ã b ÔºåËøõÂÖ• yield from result ‰ª£ÁêÜÁöÑÂçèÁ®ã b ‰∏≠ yield Âá∫ BinOp('+',x,y) ÁöÑÂ∑¶ËäÇÁÇπ Number(1) „ÄÇÂ∞ÜÂÖ∂‰º†ÂÖ•ÂßîÊ¥æÁîüÊàêÂô® C Âπ∂ÂÖ•Ê†à„ÄÇÊ≠§Êó∂ÂçèÁ®ã b Ëµ∞Ëá≥ left = yield node.left ËØ≠Âè•ÁöÑÁ≠âÂè∑Âè≥Ëæπ„ÄÇ ‰º†ÂÖ•NoneÈ¢ÑÊøÄÂßîÊ¥æÁîüÊàêÂô® C , visit(Number(1)) ËøîÂõûÊï¥ÂΩ¢ 1 Ôºå Ê≠§Êó∂ return Â∞ÜËøîÂõû result ÔºåÊäõÂá∫ StopIteration ÂºÇÂ∏∏„ÄÇÊàë‰ª¨ÊçïËé∑ÂºÇÂ∏∏Ëé∑Âæó result ÁöÑÂÄº 1 Âπ∂Â∞Ü C Âá∫Ê†à„ÄÇ Â∞Ü 1 ‰º†ÂÖ•ÂßîÊ¥æÁîüÊàêÂô® B ‰ª£ÁêÜÁöÑÂçèÁ®ã b ÔºåÊ≠§Êó∂ left = yield node.left ‰∏≠ÂèòÈáè left Ëé∑Âæó‰º†ÂÖ•ÂÄºÂπ∂ÁªßÁª≠ yield Âá∫Âè≥ËäÇÁÇπ BinOp('*',x,y) ‰∏≠Èó¥ÈáçÂ§çËøáÁ®ã‰∏çÂÜçÁ¥ØËø∞ÔºåÂΩìÂçèÁ®ãËµ∞Ëá≥ return switch.get(node.op, None)(left, right) Âàô‰ºöÊäõÂá∫ StopIteration ÂºÇÂ∏∏ÂíåËØ•Ë°®ËææÂºèÁöÑËøêÁÆóÁªìÊûúÔºå‰ª•Ê≠§Â±ÇÂ±ÇÂõûÊ∫ØÂæóÂà∞ÊúÄÁªàÁöÑÁªìÊûú„ÄÇ ÊÄªÁªì Ëá≥Ê≠§ÔºåÊàë‰ª¨Â∑≤ÁªèÂÆåÊàêÂØπ Calculator Á±ªÁöÑÁºñÂÜô„ÄÇ ÂÖ∂ÂÆûÊàë‰ª¨ÂÆåÂÖ®ÂèØ‰ª•Áî®pythonËá™Â∏¶ÁöÑ eval ÊñπÊ≥ïÊù•ÊâßË°å‰ªªÊÑèÂ≠óÁ¨¶‰∏≤‰ª£Á†Å„ÄÇ‰ΩÜ‰πãÊâÄ‰ª•Êàë‰ª¨Ë¶ÅÂ§ßË¥πÂë®Á´†Âú∞Áî®ÂçèÁ®ãÂÆûÁé∞Ëøô‰∏ÄÊñáÊú¨ËÆ°ÁÆóÂô®ÔºåÊòØ‰∏∫‰∫ÜÂú®python‰∏≠ÂÆûË∑µ stackless ÁöÑÊÄùÊÉ≥„ÄÇ ÊØîÂ¶ÇË¶ÅËÆ°ÁÆó cal.caculate('+'.join(str(i) for i in range(2017))) ,Êàë‰ª¨ÁöÑ parse ÂáΩÊï∞‰ºöÁîüÊàê‰∏ÄÊ£µË∂ÖËøá‰∏§ÂçÉÊ∑±Â∫¶ÁöÑÊ†ëÔºåËøôÊó∂ÂÄôÂ∞±Êó†Ê≥ïÁî®ÈÄíÂΩíÁöÑÊñπÂºèÊù•ÈÅçÂéÜÊ†ë‰∫Ü„ÄÇ Âè¶Â§ñÔºåÂ¶ÇcookbookÈáåËØ¥ÁöÑÔºåÂ¶ÇÊûúÊàë‰ª¨ÊÉ≥Áî®Âè¶‰∏ÄÁßçÊ≤°Êúâ yield ËØ≠Âè•ÁöÑÊñπÊ°àÔºåÊàë‰ª¨‰∏çÂæó‰∏çÂ§ÑÁêÜÂæàÂ§öÊ£òÊâãÁöÑÈóÆÈ¢ò„ÄÇ‰æãÂ¶ÇÔºå‰∏∫‰∫ÜÊ∂àÈô§ÈÄíÂΩíÔºåÊàë‰ª¨ÂøÖÈ°ªË¶ÅÁª¥Êä§‰∏Ä‰∏™Ê†àÁªìÊûÑ„ÄÇÂ¶ÇÊûú‰∏ç‰ΩøÁî®ÁîüÊàêÂô®Ôºå‰ª£Á†ÅÂ∞±‰ºöÂèòÂæóÂæàËáÉËÇøÔºåÂà∞Â§ÑÈÉΩÊòØÊ†àÊìç‰ΩúËØ≠Âè•„ÄÅ‰ºöÊéâÂáΩÊï∞Á≠â„ÄÇÂõ†Ê≠§‰ΩøÁî® yield ÂèØ‰ª•ËÆ©‰Ω†ÂÜôÂá∫ÈùûÂ∏∏ÊºÇÊµÅÁöÑ‰ª£Á†ÅÔºåÂÆÉÊ∂àÈô§‰∫ÜÈÄíÂΩí‰ΩÜÁúã‰∏äÂéªÂèàÂæàÂÉèÊòØÈÄíÂΩíÂÆûÁé∞Ôºå‰ª£Á†ÅÂæàÁÆÄÊ¥Å„ÄÇ Additional ‰ª£Á†ÅÊ∫êÊñá‰ª∂: 1. text_calculator.py","tags":"Python","title":"‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊñáÊú¨Ëß£ÊûêËÆ°ÁÆóÂô®"},{"url":"pythonzhuang-shi-qi-de-zheng-que-da-kai-fang-shi-2.html","text":"Description Ë£ÖÈ•∞Âô®ÊòØpythonËØ≠Ë®ÄÁöÑ‰∏Ä‰∏™ÈùûÂ∏∏Â∏∏Áî®ÂèäpythonicÁöÑÁâπÊÄßÔºå‰ΩÜÂæÄÂæÄÁî±‰∫éÂøΩËßÜpython‰∏≠ÁöÑÂÜÖÁúÅÔºåÊàë‰ª¨‰ºöÂÜôÂá∫‰∏Ä‰∫õ‰∏çÊòØÁâπÂà´ÂÆåÁæéÁöÑËá™ÂÆö‰πâË£ÖÈ•∞Âô®„ÄÇGraham DumpletonÂÜô‰∫Ü‰∏ÄÁ≥ªÂàó ÂçöÂÆ¢ ÔºåÊ∑±ÂÖ•ÂâñÊûê‰∫ÜÂ¶Ç‰ΩïÂÆûÁé∞Ë°å‰∏∫ËâØÂ•ΩÁöÑË£ÖÈ•∞Âô®„ÄÇÊ≠§Â§ñ‰ªñËøòÊòØ wraptÊ®°Âùó ÁöÑ‰ΩúËÄÖ,‰ªñÂ∞Ü‰ªñÂØπË£ÖÈ•∞Âô®ÁöÑÊ∑±ÂéöÁü•ËØÜÂÖÖÂàÜÂ∫îÁî®Âà∞Ëøô‰∏™Ê®°Âùó‰πã‰∏≠„ÄÇËøô‰∏™Ê®°ÂùóÁöÑ‰ΩúÁî®ÊòØÁÆÄÂåñË£ÖÈ•∞Âô®ÂíåÂä®ÊÄÅÂáΩÊï∞ÂåÖË£ÖËµ∑ÁöÑÂÆûÁé∞Ôºå‰ΩøÂæóÂ§öÂ±ÇË£ÖÈ•∞‰πüÊîØÊåÅÂÜÖÁúÅ‰∏îË°å‰∏∫Ê≠£Á°ÆÔºåÊó¢ÂèØ‰ª•Â∫îÁî®Âà∞ÊñπÊ≥ï‰∏äÔºå‰πüÂèØ‰ª•‰Ωú‰∏∫ÊèèËø∞Á¨¶‰ΩøÁî®„ÄÇ Êú¨ÊñáÊãæÂèñ‰∫ÜGraham DumpletonÂú®wraptÊ®°Âùó‰∏≠ÈôÑÂ∏¶ÁöÑ‰∏ÄÁ≥ªÂàóÂçöÊñáÁöÑÁâôÊÖßÔºåÊó®Âú®Â∏¶Êù•ÂØπpythonË£ÖÈ•∞Âô®Êõ¥Ê∑±ÁöÑÁêÜËß£ÂíåÊõ¥Â•ΩÁöÑËÆæËÆ°„ÄÇ ‰∏ä‰∏ÄÁØáÊñáÁ´† ËÆ∫Ëø∞‰∫ÜÊôÆÈÄöË£ÖÈ•∞Âô®ÂèØËÉΩÂ∏¶Êù•ÁöÑ‰∏Ä‰∫õÂÜÖÁúÅÁº∫Èô∑ÔºåÂπ∂ÊèêÂá∫‰∫Ü‰∏Ä‰∫õËß£ÂÜ≥ÊñπÊ°à„ÄÇÊú¨ÊñáÊé•‰∏äÊñáÊõ¥Ê∑±ÂÖ•Âú∞‰ªãÁªçpythonË£ÖÈ•∞Âô®ÁöÑÈ´òÁ∫ßÁî®Ê≥ï‰ª•‰æø‰πãÂêéÁªßÁª≠Êé¢ËÆ®ÂÖ≥‰∫éÂÜÖÁúÅÁº∫Èô∑ÁöÑËß£ÂÜ≥ÊñπÊ°à„ÄÇ Â∏¶ÂèÇÊï∞ÁöÑË£ÖÈ•∞Âô® Êé•‰∏äÊñáÔºåÊàë‰ª¨Ëá≥‰ªä‰∏∫Ê≠¢ÁöÑÊâÄÂàõÂª∫ÁöÑÊâÄÊúâË£ÖÈ•∞Âô®ÈÉΩ‰∏çËÉΩ‰º†ÂÖ•‰ªª‰ΩïÂèÇÊï∞Ôºå‰ΩÜË¶ÅÁü•ÈÅìÈÄöËøá‰º†ÂÖ•ÂèÇÊï∞Êù•ÊîπÂèòË£ÖÈ•∞Âô®ÁöÑÈÉ®ÂàÜË£ÖÈ•∞Ë°å‰∏∫ÊòØ‰∏ÄÁßçÂæàÂ∏∏ËßÅÂπ∂‰∏îÂº∫Â§ßÁöÑÁâπÊÄß„ÄÇÈÄöÂ∏∏Êàë‰ª¨Âè™Ë¶ÅÁî®‰∏Ä‰∏™Êé•ÂèóÂèÇÊï∞ÁöÑÂáΩÊï∞Èó≠ÂåÖÂ∞±ËÉΩÊûÑÊàê‰∏Ä‰∏™Â∏¶ÂèÇÊï∞ÁöÑË£ÖÈ•∞Âô®„ÄÇ def with_arguments ( arg ): @decorator def _wrapper ( wrapped , instance , args , kwargs ): return wrapped ( * args , ** kwargs ) return _wrapper @with_arguments ( arg = 1 ) def function (): pass Â¶ÇÊûúÁªôË£ÖÈ•∞Âô®ÂèÇÊï∞arg‰∏Ä‰∏™ÈªòËÆ§ÂÄºÁöÑËØùÔºåÂ∞±ËÉΩ‰ª• @with_arguments() ÁöÑÊñπÂºèË∞ÉÁî®ÂÆÉ‰∫Ü„ÄÇ‰ΩÜËøôÁßçË∞ÉÁî®ÊñπÂºè‰ºöÂíåÊàë‰ª¨‰πãÂâç‰ΩøÁî®Ë£ÖÈ•∞Âô®ÁöÑÊñπÂºè‰∏ç‰∏ÄËá¥„ÄÇ‰ΩÜÊòØÊàë‰ª¨ÂèØ‰ª•Áî®ÂèÇÊï∞ÈªòËÆ§ÂÄºÂíå partial ÂáΩÊï∞ÁªìÂêàÁöÑÊñπÊ≥ïÊù•ÂÆûÁé∞Ëøô‰∏ÄÂâçÂêéÁöÑÁªü‰∏ÄÔºö def optional_arguments ( wrapped = None , * , arg = 1 ): if wrapped is None : return functools . partial ( optional_arguments , arg = arg ) @decorator def _wrapper ( wrapped , instance , args , kwargs ): return wrapped ( * args , ** kwargs ) return _wrapper ( wrapped ) @optional_arguments ( arg = 2 ) def function1 (): pass @optional_arguments def function2 (): pass ÂΩìwrappedÂèÇÊï∞‰∏∫Á©∫Êó∂ÔºåÂàôËøîÂõû‰∏Ä‰∏™Â∑≤ÁªèÂÖ∑ÊúâÈªòËÆ§ÂèÇÊï∞ arg ÁöÑË£ÖÈ•∞Âô® functools.partial(optional_arguments, arg=arg) Êù•Ë£ÖÈ•∞ÂáΩÊï∞„ÄÇ ÁªôË¢´Ë£ÖÈ•∞ÁöÑÂáΩÊï∞Ê∑ªÂä†ÁºìÂ≠òÂäüËÉΩ ÂæàÂ§öÊó∂ÂÄôÔºåÂΩìÊàë‰ª¨Â§öÈÅçË∞ÉÁî®Êüê‰∏™ÂáΩÊï∞ÁöÑÊó∂ÂÄôÂ∞±‰ºöÂ∏åÊúõËØ•ÂáΩÊï∞ËÉΩÂ§ü\"ËÆ∞ÂΩï\"‰∏ãÊù•ÂÆÉ‰πãÂâçÊâÄËøêË°åÁöÑÁªìÊûúÔºåÂπ∂‰∏îÂú®‰∏ãÊ¨°‰º†ÂÖ•Áõ∏ÂêåÂèÇÊï∞ÁöÑÊó∂ÂÄô‰∏çÂÜçÂéªÂÅöÂÆÉÂÜÖÈÉ®ÈÇ£‰∫õÂ§çÊùÇÁöÑËøêÁÆóËÄåÊòØÁõ¥Êé•ËøîÂõûÁºìÂ≠òÁöÑÂÄº„ÄÇËøôÂê¨Ëµ∑Êù•ÊòØ‰∏Ä‰∏™Êúâ‰∫õÈ∫ªÁÉ¶ÁöÑÈúÄÊ±Ç„ÄÇÂπ∏ËøêÁöÑÊòØÔºåÈÄöËøáÂú®Ë£ÖÈ•∞Âô®‰∏≠ÂÆö‰πâ‰∏Ä‰∏™ÁºìÂ≠òÁªìÊûÑÔºåËÉΩËÆ©Êàë‰ª¨Êñπ‰æøÂú∞ËÆ©‰ªªÊÑè‰∏Ä‰∏™ÂáΩÊï∞Êã•ÊúâËøô‰∏ÄÁ•ûÂ•áÁöÑÂäüËÉΩ„ÄÇ ËøôÈáåÊàë‰ª¨‰πüÁî®Âà∞‰∫Ü‰∏ä‰∏ÄËäÇÊâÄÊèêÂà∞ÁöÑÈªòËÆ§ÂèÇÊï∞Âíå partial ÂáΩÊï∞ÁªìÂêàÁöÑË£ÖÈ•∞Âô®ËÆæËÆ°Ôºö def cache ( wrapped = None , d = None ): if wrapped is None : return functools . partial ( cache , d = d ) if d is None : d = {} @decorator def _wrapper ( wrapped , instance , args , kwargs ): try : key = ( args , frozenset ( kwargs . items ())) #Ê≠§Ê¨°‰º†ÂÖ•ÁöÑÂèÇÊï∞ÈõÜÂêà return d [ key ] #ÂΩìÂèÇÊï∞ÈõÜÂêàÂ∑≤ÁºìÂ≠òÊó∂Áõ¥Êé•ËøîÂõû‰πãÂâçÁöÑÁªìÊûú except KeyError : result = d [ key ] = wrapped ( * args , ** kwargs ) #ÂΩì‰∏∫Êñ∞ÂèÇÊï∞ÁöÑÁºìÂ≠òÂà∞Ë£ÖÈ•∞Âô®ÁöÑÂ≠óÂÖ∏‰∏≠ return result return _wrapper ( wrapped ) @cache def function1 (): return time . time () _d = {} #ÂΩì‰º†ÂÖ•Âêå‰∏Ä‰∏™Â≠óÂÖ∏ÁöÑÊó∂ÂÄôÔºåË¢´Ë£ÖÈ•∞ÁöÑ‰∏çÂêåÂáΩÊï∞‰ºöÊã•ÊúâÁõ∏ÂêåÁöÑÁºìÂ≠ò„ÄÇ @cache ( d = _d ) def function2 (): return time . time () @cache ( d = _d ) def function3 (): return time . time () ‰∏é‰πãÂâçÁõ∏ÂêåÔºåÊàë‰ª¨‰πüÂèØ‰ª•Â∞ÜËøô‰∏ÄÁºìÂ≠òË£ÖÈ•∞Âô®ÂÜôÊàêÁ±ªÁöÑÁâàÊú¨Ôºö class cache ( object ): def __init__ ( self , wrapped ): self . wrapped = wrapped self . d = {} def __call__ ( self , * args , ** kwargs ): try : key = ( args , frozenset ( kwargs . items ())) return self . d [ key ] except KeyError : result = self . d [ key ] = self . wrapped ( * args , ** kwargs ) return result @cache def function (): return time . time () python‰∏≠ÁöÑÂêåÊ≠•Ë£ÖÈ•∞Âô® Âú®Java‰∏≠ÔºåÂ¶ÇÊûúÊàë‰ª¨Â∏åÊúõ‰∏Ä‰∏™ÊñπÊ≥ïÊòØÂêåÊ≠• (synchronized) ÁöÑÔºåÊúâ‰∏§ÁßçÊñπÂºèÁªôÊàë‰ª¨ÁöÑ‰ª£Á†ÅÂ¢ûÂä†ÂêåÊ≠•ÁâπÊÄßÔºö //Á¨¨‰∏ÄÊòØ‰ΩøÁî®synchronizedÂÖ≥ÈîÆÂ≠óÁöÑÊñπÂºè‰ΩøÊï¥‰∏™ÊñπÊ≥ïÂÖ∑ÊúâÂêåÊ≠•ÁâπÊÄß public class SynchronizedCounter { private int c = 0 ; public synchronized void increment () { c ++ ; } public synchronized void decrement () { c -- ; } public synchronized int value () { return c ; } } //Á¨¨‰∫åÊòØ‰ΩøÁî®synchronizedËØ≠Âè•‰ΩøÂæóË¢´ÂåÖË£πÁöÑ‰ª£Á†ÅÂùóÂÖ∑ÊúâÂêåÊ≠•ÁâπÊÄß //‰∏éÁ¨¨‰∏Ä‰∏™ÊñπÊ≥ï‰∏çÂêåÁöÑÊòØÔºåÊàë‰ª¨ÂøÖÈ°ªÂà∂ÂÆö‰∏Ä‰∏™Êèê‰æõÂÜÖÂú®ÈîÅÁöÑÂØπË±°(Ëøô //ÈáåÊòØthis) public void addName ( String name ) { synchronized ( this ) { lastName = name ; nameCount ++ ; } nameList . add ( name ); } ÁÆÄÂçïÁöÑÊù•ËØ¥ÔºåÂêåÊ≠•ÁâπÊÄßÂç≥ÊòØËÆ©ÊØè‰∏™Á±ªÁöÑÂÆû‰æãÈÉΩÊã•Êúâ‰∏Ä‰∏™ÂÜÖÂú®ÁöÑÈîÅÔºåÂΩì‰∏Ä‰∏™ÊñπÊ≥ïÊàñ‰∏ÄÊÆµ‰ª£Á†ÅË¢´Ëß¶ÂèëÁöÑÊó∂ÂÄôÂ∞±ÂèñÂæóÈîÅÔºåÂΩìËØ•ÊñπÊ≥ïËøîÂõûÊó∂ÈöèÂêéËØ•ÈîÅÂ∞±Ë¢´ÈáäÊîæ„ÄÇËøôÁßçÈîÅË¢´Áß∞‰∏∫ ÈáçÂÖ•ÈîÅ „ÄÇÂΩì‰∏Ä‰∏™Á∫øÁ®ãËé∑ÂèñÂØπË±°ÈîÅ‰πãÂêéÔºåËøô‰∏™Á∫øÁ®ãÂèØ‰ª•‰∏çÁî®ÈòªÂ°ûÂú∞ÂÜçÊ¨°Ëé∑ÂèñÊú¨ÂØπË±°‰∏äÁöÑÈîÅÔºåËÄåÂÖ∂‰ªñÁöÑÁ∫øÁ®ãÊòØ‰∏çÂèØ‰ª•ÁöÑ„ÄÇËøôÂ∞±‰ΩøÂæó‰ªé‰∏Ä‰∏™ÂêåÊ≠•ÁöÑÊñπÊ≥ïËøêË°åÂú®Âêå‰∏ÄÂØπË±°‰∏≠ÁöÑÂè¶‰∏Ä‰∏™ÂêåÊ≠•ÊñπÊ≥ïÊàê‰∏∫‰∫ÜÂèØËÉΩ„ÄÇ ÂàùÊé¢ÂêåÊ≠•Ë£ÖÈ•∞Âô® Âú®python‰∏≠ÔºåÊàë‰ª¨ÂèØ‰ª•Âà©Áî®‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®ÂíåthreadingÊ®°ÂùóÁöÑÈîÅÊñπÊ≥ïÊù•Á°Æ‰øùË¢´Êàë‰ª¨Ë£ÖÈ•∞ÁöÑÂáΩÊï∞ÂÖ∑ÊúâÂêåÊ≠•ÁâπÊÄß„ÄÇ import threading def synchronized ( wrapped ): lock = threading . RLock () @functools . wraps ( wrapped ) def _wrapper ( * args , ** kwargs ): with lock : return wrapped ( * args , ** kwargs ) return _wrapper @synchronized def function (): pass ÂΩìÁÑ∂Êàë‰ª¨‰πüÂèØ‰ª•Áî®‰∏ä‰πãÂâçÊèêÂà∞ÁöÑÂ∏¶ÂèÇË£ÖÈ•∞Âô®ÊäÄÊúØ‰ΩøÊàë‰ª¨ÁöÑÂêåÊ≠•ÈîÅË£ÖÈ•∞Âô®Êõ¥Âä†ÁÅµÊ¥ª,ÂÜçÂä†‰∏ä decorator Ë£ÖÈ•∞Âô®Êù•Ëé∑Âèñ‰πãÂâçÁöÑËá™ÁúÅÁâπÊÄß„ÄÇ def synchronized ( wrapped = None , lock = None ): if wrapped is None : return functools . partial ( synchronized , lock = lock ) if lock is None : lock = threading . RLock () @decorator def _wrapper ( wrapped , instance , args , kwargs ): with lock : return wrapped ( * args , ** kwargs ) return _wrapper ( wrapped ) @synchronized def function1 (): pass lock = threading . Lock () @synchronized ( lock = lock ) def function2 (): pass Ëøô‰ΩøÂæóÊàë‰ª¨ÁöÑË£ÖÈ•∞Âô®ËÉΩÂ§üÈÄÇÁî®Âú®ÂÆû‰æã„ÄÅÁ±ªÂíåÈùôÊÄÅÊñπÊ≥ï„ÄÇ‰ΩÜ‰ªîÁªÜÊÉ≥ÊÉ≥‰ª•‰∏ä‰ª£Á†ÅÁöÑËØù‰ºöÂèëÁé∞Ëøô‰∏ÄÁÆÄÂçïÁöÑÂÆûÁé∞ÂÖ∂ÂÆûÂπ∂‰∏çÂÆûÁî®„ÄÇÂõ†‰∏∫ÂêåÊ≠•ÈîÅÂè™ÂØπ‰∏çÂêåÁ∫øÁ®ãËÆøÈóÆË¢´Ë£ÖÈ•∞ÁöÑÊñπÊ≥ïÊó∂ÊâçËµ∑‰ΩúÁî®Âπ∂‰∏î‰ªñ‰ºö‰ΩúÁî®‰∫éÁùÄ‰∏™Á±ªÁöÑÊâÄÊúâÂÆû‰æãÔºåËøôÂíåÊàë‰ª¨Â∏åÊúõÂú®java‰∏≠ÁúãÂà∞ÁöÑË°®Áé∞‰∏çÂ∞ΩÁõ∏Âêå„ÄÇ Êàë‰ª¨ÊÉ≥Ë¶ÅÁöÑË°å‰∏∫ÊòØÔºöÂØπ‰∫éÊüê‰∏™Á±ªÁöÑ‰∏Ä‰∏™ÂÆû‰æãÁöÑÊâÄÊúâË¢´synchronizedË£ÖÈ•∞ËøáÁöÑÂÆû‰æãÊñπÊ≥ïÔºåÂÆÉ‰ª¨‰ºöÂêåÊ≠•ÂÖ≥ËÅî‰∏Ä‰∏™Á±ªÂÆû‰æãÁöÑÂçïÈîÅÂØπË±°„ÄÇ ÂêåÊó∂ÔºåÊàë‰ª¨Ë¶ÅËÄÉËôë‰∏Ä‰∏™È¢ùÂ§ñÁöÑÈóÆÈ¢òÔºåÂèëÁîüÁ´û‰∫âÂàõÂª∫ÈîÅÂÖ≥Á≥ªÊó∂Êàë‰ª¨ËØ•Â¶Ç‰Ωï‰øùËØÅÊàë‰ª¨ÁöÑÁ∫øÁ®ãÂÆâÂÖ®ÊÄß„ÄÇ Âú®ÂØπË±°‰∏≠ÂÇ®Â≠òÂêåÊ≠•ÈîÅ ËÆ©Êàë‰ª¨ÈáçÊñ∞ËÄÉËôë‰∏Ä‰∏ãÈóÆÈ¢òÔºåÈô§‰∫Ü‰º†ÂÖ•ÈîÅÊàñËÄÖÂú®ÂáΩÊï∞Èó≠ÂåÖ‰∏≠ÂàõÂª∫ÂÆÉÔºåÊàë‰ª¨ÂèØ‰∏çÂèØ‰ª•ËÆ©Ë¢´Ë£ÖÈ•∞ÂØπË±°Ëá™Â∑±ÂÇ®Â≠òÈîÅÂπ∂ÈÄöËøáÂåÖË£ÖÂáΩÊï∞Êù•ÁÆ°ÁêÜÔºü Á≠îÊ°àÊòØËÇØÂÆöÁöÑ„ÄÇËÆ©Êàë‰ª¨Êù•Áúã‰ª•‰∏ã‰ª£Á†ÅÔºö @decorator def synchronized ( wrapped , instance , args , kwargs ): if instance is None : owner = wrapped #ÂΩìË¢´Ë£ÖÈ•∞ÁöÑ‰ΩçÊôÆÈÄöÂáΩÊï∞ÊàñÈùôÊÄÅÊñπÊ≥ïÊó∂Â∞ÜÂêåÊ≠•ÈîÅÁªëÂú®ÂáΩÊï∞ÊàñÊñπÊ≥ï‰∏ä else : owner = instance #ÂΩìË¢´Ë£ÖÈ•∞ÁöÑ‰∏∫ÂÆû‰æãÊñπÊ≥ïÊàñÁ±ªÊñπÊ≥ïÊó∂Â∞ÜÂêåÊ≠•ÈîÅÁªëÂú®ÂÆû‰æãÊàñÁ±ª‰∏ä lock = vars ( owner ) . get ( '_synchronized_lock' , None ) if lock is None : #‰ΩøÁî®metalockÊù•Á°Æ‰øùÂàõÂª∫ÂêåÊ≠•ÈîÅÊó∂‰∏ç‰ºöÂá∫Áé∞Á´û‰∫âÂÖ≥Á≥ª meta_lock = vars ( synchronized ) . setdefault ( '_synchronized_meta_lock' , threading . Lock ()) with meta_lock : #ÂÜçÊ¨°Á°ÆËÆ§ÈîÅÁöÑÂ≠òÂú®Áä∂ÊÄÅÔºåÈò≤Ê≠¢Âú®ÁîüÊàêmeta_lockÊó∂ÂêåÊ≠•ÈîÅÂ∑≤ÁªèË¢´ÂÖ∂‰ªñÁ∫øÁ®ãÁîüÊàê lock = vars ( owner ) . get ( '_synchronized_lock' , None ) if lock is None : lock = threading . RLock () setattr ( owner , '_synchronized_lock' , lock ) with lock : return wrapped ( * args , ** kwargs ) #ÂØπÂ∫îÁöÑÁªëÂÆöÂÖ≥Á≥ªÂ¶Ç‰∏ã @synchronized # lock bound to function1 def function1 (): pass @synchronized # lock bound to function2 def function2 (): pass @synchronized # lock bound to Class class Class ( object ): @synchronized # lock bound to instance of Class def function_im ( self ): pass @synchronized # lock bound to Class @classmethod def function_cm ( cls ): pass @synchronized # lock bound to function_sm @staticmethod def function_sm (): pass Âú®ÂÆûÁé∞Êàë‰ª¨ÁöÑËÆæËÆ°ÁöÑÊó∂ÂÄô‰∏Ä‰∏™ÂÖ≥ÈîÆÁöÑ‰∫ãÊÉÖÂ∞±ÊòØÂú®Á¨¨‰∏ÄÊ¨°ÂàõÂª∫ÂêåÊ≠•ÈîÅÁöÑÊó∂ÂÄôÊàë‰ª¨ÈúÄË¶ÅÂà§Êñ≠ÈîÅÊòØÂê¶Â≠òÂú®ÔºåÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØùÂ∞±ËøîÂõûÂéüÊúâÁöÑÈîÅ„ÄÇÊàë‰ª¨ÈÄöËøá lock = vars(wrapped).get('_synchronized_lock', None) Ëé∑ÂèñÈîÅ„ÄÇ ÂΩìÊàë‰ª¨ÈÅáÂà∞Â§ö‰∏™Á∫øÁ®ãÁ´û‰∫âÂàõÂª∫ÈîÅÊó∂ÔºåÂèØ‰ª•‰ΩøÁî® lock = vars(wrapped).setdefault('_synchronized_lock', threading.RLock()) ÈªòËÆ§Â≠óÂÖ∏ÁöÑÂΩ¢ÂºèÊù•Èò≤Ê≠¢‰ªª‰∏ÄÁ∫øÁ®ãÂàõÂª∫ÁöÑÈîÅË¢´Âè¶‰∏Ä‰∏™Á∫øÁ®ãË¶ÜÁõñ„ÄÇ‰ΩÜÂ¶ÇÊûúÊàë‰ª¨‰ΩøÁî®Ëøô‰∏ÄÊñπÊ≥ïÁöÑËØùÔºåÊàë‰ª¨‰ºöÂú®Ë£ÖÈ•∞Á±ªÊñπÊ≥ï‰∏äÈÅáÂà∞ÈóÆÈ¢ò„ÄÇÂõ†‰∏∫Á±ªÁöÑÂ≠óÂÖ∏ dictproxy Âπ∂Ê≤°ÊúâsetdefaultÊñπÊ≥ïÔºåÂõ†Ê≠§Êàë‰ª¨Âè™ËÉΩ‰ΩøÁî® setattr(Object, '_synchronized_lock', threading.RLock()) Êù•‰∏∫Á±ªËÆæÁΩÆÂêåÊ≠•ÈîÅ ËÆ©ÂêåÊ≠•ÈîÅË£ÖÈ•∞Âô®ÂÖ∑Êúâ‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®ÁöÑÂäüËÉΩ Ëá≥Ê≠§‰∏∫Ê≠¢ÔºåÊàë‰ª¨Â∑≤ÁªèÂÆûÁé∞‰∫ÜjavaÁöÑÂêåÊ≠•ÁöÑÁ¨¨‰∏Ä‰∏™ÂäüËÉΩ‰∫Ü„ÄÇÂØπ‰∫éÁ¨¨‰∫å‰∏™ÂäüËÉΩÔºåÂú®python‰∏≠ÊòØ‰∏Ä‰∏™Âíå‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®Áõ∏‰ººÁöÑË°å‰∏∫„ÄÇÊàë‰ª¨ÊÉ≥ËÆ©Êàë‰ª¨ÁöÑsynchronizedË£ÖÈ•∞Âô®ËÉΩÂ§üËøôÊ†∑‰ΩøÁî®Êù•ÂêåÊ≠•ÊñπÊ≥ïÊàñÂáΩÊï∞‰∏≠ÁöÑÈÉ®ÂàÜ‰ª£Á†ÅÔºö ```python class Object(object): @synchronized def function_im_1 ( self ) : pass def function_im_2 ( self ) : with synchronized ( self ) : pass ``` ‰∏∫‰∫ÜÊã•Êúâ‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®ÁöÑÂäüËÉΩÔºåÊàë‰ª¨ÂøÖÈ°ªËÆ©Ë£ÖÈ•∞Âô®ÂáΩÊï∞ËøîÂõû‰∏Ä‰∏™ÂÖ∑Êúâ __enter__ and __exit__ ÊñπÊ≥ïÁöÑÂØπË±°„ÄÇ‰ΩÜÊàë‰ª¨ÁöÑ synchronized(None) ÂÆûÈôÖËøîÂõûÁöÑÊòØ‰∏Ä‰∏™ <__main__.function_wrapper object at 0x107b7ea10> ÂØπË±°ÔºåÂÜçËØ•Á±ªÈáåÊàë‰ª¨ËøòÊ≤°ÊúâÁùÄ‰∏§‰∏™ÊñπÊ≥ïÁöÑÂÆö‰πâ„ÄÇÂõ†Ê≠§Êàë‰ª¨Â∑≤Áªè‰∏çËÉΩ‰ΩøÁî®ÂéüÊù•ÁöÑË£ÖÈ•∞Âô®Â∑•ÂéÇÂáΩÊï∞ @decorator ‰∫ÜÔºå‰Ωú‰∏∫Êõø‰ª£Êàë‰ª¨È¶ñÂÖàË¶ÅÁõ¥Êé•‰ΩøÁî®‰πãÂâçÂÆö‰πâÁöÑ function_wrapper Á±ªË£ÖÈ•∞Âô®Êù•Ëé∑ÂæóÂÜÖÁúÅÂäüËÉΩÔºö ```python def synchronized(wrapped): def _synchronized_lock(owner): lock = vars(owner).get('_synchronized_lock', None) if lock is None : meta_lock = vars ( synchronized ). setdefault ( '_synchronized_meta_lock' , threading . Lock ()) with meta_lock : lock = vars ( owner ). get ( '_synchronized_lock' , None ) if lock is None : lock = threading . RLock () setattr ( owner , '_synchronized_lock' , lock ) return lock # ‰ΩøÁî® _synchronized_lock ÂêåÊ≠•ÈîÅÁöÑËá™ÂÆö‰πâË£ÖÈ•∞Âô® def _synchronized_wrapper ( wrapped , instance , args , kwargs ): with _synchronized_lock ( instance or wrapped ): return wrapped ( * args , ** kwargs ) # Áõ¥Êé•‰ΩøÁî® function_wrapper Ëá™ÂÆö‰πâÂêåÊ≠•ÈîÅË£ÖÈ•∞Âô®Ë£ÖÈ•∞Âà∞Ë¢´Ë£ÖÈ•∞ÂáΩÊï∞ warpped ‰∏ä return function_wrapper ( wrapped , _synchronized_wrapper ) ``` Áé∞Âú®Êàë‰ª¨Â∑≤ÁªèÂÆåÊàêË£ÖÈ•∞Â∑•Á®ãÂáΩÊï∞ÁöÑÊõøÊç¢Â∑•‰Ωú‰∫ÜÔºåÊé•‰∏ãÊù•ÁöÑÂäüËÉΩÂ∞±ÊòØÂú® function_wrapper Á±ªË£ÖÈ•∞Âô®‰∏≠Âä†ÂÖ• __enter__ and __exit__ È≠îÊúØÊñπÊ≥ïÊù•ÂÆûÁé∞‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®ÔºåËøôÈáåÊàë‰ª¨ÁªßÊâø‰∫Ü function_wrapper Á±ª: def synchronized ( wrapped ): def _synchronized_lock ( owner ): lock = vars ( owner ) . get ( '_synchronized_lock' , None ) if lock is None : meta_lock = vars ( synchronized ) . setdefault ( '_synchronized_meta_lock' , threading . Lock ()) with meta_lock : lock = vars ( owner ) . get ( '_synchronized_lock' , None ) if lock is None : lock = threading . RLock () setattr ( owner , '_synchronized_lock' , lock ) #‰∏∫Ë¢´Ë£ÖÈ•∞Âô®Ë£ÖÈ•∞ÁöÑÊñπÊ≥ïÂä†ÈîÅ return lock def _synchronized_wrapper ( wrapped , instance , args , kwargs ): with _synchronized_lock ( instance or wrapped ): return wrapped ( * args , ** kwargs ) class _synchronized_function_wrapper ( function_wrapper ): def __enter__ ( self ): self . _lock = _synchronized_lock ( self . wrapped ) #‰∏∫‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®Êû∑ÈîÅ self . _lock . acquire () return self . _lock def __exit__ ( self , * args ): self . _lock . release () return _synchronized_function_wrapper ( wrapped , _synchronized_wrapper ) Ëá≥Ê≠§‰∏∫Ê≠¢ÔºåÊàë‰ª¨ÂØπjavaÁöÑ synchronized ÁöÑÁßªÊ§çÂ∞±ÂÖ®ÈÉ®ÂÆåÊàê‰∫Ü„ÄÇ Additional ÂèÇËÄÉÊñáÁåÆ: 1. Wrapt blog","tags":"Python","title":"PythonË£ÖÈ•∞Âô®ÁöÑÊ≠£Á°ÆÊâìÂºÄÊñπÂºè(2)"},{"url":"leetcode-replace-words.html","text":"Description In English, we have a concept called root , which can be followed by some other words to form another longer word - let's call this word successor . For example, the root an , followed by other , which can form another word another. Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length. You need to output the sentence after the replacement. Example 1: Input : dict = [ \"cat\" , \"bat\" , \"rat\" ] sentence = \"the cattle was rattled by the battery\" Output : \"the cat was rat by the bat\" Note: 1. The input will only have lower-case letters. 2. 1 <= dict words number <= 1000 3. 1 <= sentence words number <= 1000 4. 1 <= root length <= 100 5. 1 <= sentence words length <= 1000 Source link Best practice Âú®ËøôÈáåÁî®Âà∞ÁöÑÊï∞ÊçÆÁªìÊûÑÊòØTireÊ†ë„ÄÇ TrieÊ†ëÔºåÂç≥Â≠óÂÖ∏Ê†ëÔºåÂèàÁß∞ÂçïËØçÊü•ÊâæÊ†ëÊàñÈîÆÊ†ëÔºåÊòØ‰∏ÄÁßçÊ†ëÂΩ¢ÁªìÊûÑÔºåÊòØ‰∏ÄÁßçÂìàÂ∏åÊ†ëÁöÑÂèòÁßç„ÄÇÂÖ∏ÂûãÂ∫îÁî®ÊòØÁî®‰∫éÁªüËÆ°ÂíåÊéíÂ∫èÂ§ßÈáèÁöÑÂ≠óÁ¨¶‰∏≤Ôºà‰ΩÜ‰∏ç‰ªÖÈôê‰∫éÂ≠óÁ¨¶‰∏≤ÔºâÔºåÊâÄ‰ª•ÁªèÂ∏∏Ë¢´ÊêúÁ¥¢ÂºïÊìéÁ≥ªÁªüÁî®‰∫éÊñáÊú¨ËØçÈ¢ëÁªüËÆ°„ÄÇÂÆÉÁöÑ‰ºòÁÇπÊòØÔºöÊúÄÂ§ßÈôêÂ∫¶Âú∞ÂáèÂ∞ëÊó†Ë∞ìÁöÑÂ≠óÁ¨¶‰∏≤ÊØîËæÉÔºåÊü•ËØ¢ÊïàÁéáÊØîÂìàÂ∏åË°®È´ò„ÄÇ TrieÁöÑÊ†∏ÂøÉÊÄùÊÉ≥ÊòØÁ©∫Èó¥Êç¢Êó∂Èó¥„ÄÇÂà©Áî®Â≠óÁ¨¶‰∏≤ÁöÑÂÖ¨ÂÖ±ÂâçÁºÄÊù•Èôç‰ΩéÊü•ËØ¢Êó∂Èó¥ÁöÑÂºÄÈîÄ‰ª•ËææÂà∞ÊèêÈ´òÊïàÁéáÁöÑÁõÆÁöÑ„ÄÇ python version from collections import defaultdict import functools class Solution ( object ): def replaceWords ( self , dict , sentence ): \"\"\" :type dict: List[str] :type sentence: str :rtype: str \"\"\" IS_WORD = True #TireÊ†ë‰∏≠Ë°®Á§∫ËäÇÁÇπ‰∏∫ÂçïËØçÊú´Â≠óÊØçÁöÑÊ†áËØÜÁ¨¶ÔºåËøôÈáåÈ¢ùÂ§ñÂ≠òÂÇ®ÂÆåÊï¥ÂçïËØç def generateTire ( dct ): #ËøôÊòØ‰∏Ä‰∏™ÂæàÂº∫Â§ßÁöÑÈÄíÂΩíÁîüÊàêdefaultdictÊ†ëÁöÑË°®ËææÂºè _tire = lambda : defaultdict ( _tire ) tire = _tire () for word in dct : node = tire for char in word : node = node [ char ] node [ IS_WORD ] = word return tire def searchWord ( tire , word ): #Âú®tireÊ†ëÁßçÊü•ÊâæÂà∞ÊúÄÁü≠ÁöÑÂçïËØçsuccessorÔºåËøôÈáå #Âè™Ë¶ÅÈÅáÂà∞IS_WORDÈîÆÂ∞±ËøîÂõûÊü•Âà∞ÁöÑÂçïËØç node = tire for char in word : if char not in node : break node = node [ char ] if IS_WORD in node : return node [ IS_WORD ] return word #Âà©Áî®partialÊñπÊ≥ïÊûÑÈÄ†mapÂáΩÊï∞ replace = functools . partial ( searchWord , generateTire ( dict )) return \" \" . join ( map ( replace , sentence . split ())) Mark: 116 ms Additional","tags":"Python","title":"LeetCode - Replace Words"},{"url":"pythonzhuang-shi-qi-de-zheng-que-da-kai-fang-shi-1.html","text":"Description Ë£ÖÈ•∞Âô®ÊòØpythonËØ≠Ë®ÄÁöÑ‰∏Ä‰∏™ÈùûÂ∏∏Â∏∏Áî®ÂèäpythonicÁöÑÁâπÊÄßÔºå‰ΩÜÂæÄÂæÄÁî±‰∫éÂøΩËßÜpython‰∏≠ÁöÑÂÜÖÁúÅÔºåÊàë‰ª¨‰ºöÂÜôÂá∫‰∏Ä‰∫õ‰∏çÊòØÁâπÂà´ÂÆåÁæéÁöÑËá™ÂÆö‰πâË£ÖÈ•∞Âô®„ÄÇGraham DumpletonÂÜô‰∫Ü‰∏ÄÁ≥ªÂàó ÂçöÂÆ¢ ÔºåÊ∑±ÂÖ•ÂâñÊûê‰∫ÜÂ¶Ç‰ΩïÂÆûÁé∞Ë°å‰∏∫ËâØÂ•ΩÁöÑË£ÖÈ•∞Âô®„ÄÇÊ≠§Â§ñ‰ªñËøòÊòØ wraptÊ®°Âùó ÁöÑ‰ΩúËÄÖ,‰ªñÂ∞Ü‰ªñÂØπË£ÖÈ•∞Âô®ÁöÑÊ∑±ÂéöÁü•ËØÜÂÖÖÂàÜÂ∫îÁî®Âà∞Ëøô‰∏™Ê®°Âùó‰πã‰∏≠„ÄÇËøô‰∏™Ê®°ÂùóÁöÑ‰ΩúÁî®ÊòØÁÆÄÂåñË£ÖÈ•∞Âô®ÂíåÂä®ÊÄÅÂáΩÊï∞ÂåÖË£ÖËµ∑ÁöÑÂÆûÁé∞Ôºå‰ΩøÂæóÂ§öÂ±ÇË£ÖÈ•∞‰πüÊîØÊåÅÂÜÖÁúÅ‰∏îË°å‰∏∫Ê≠£Á°ÆÔºåÊó¢ÂèØ‰ª•Â∫îÁî®Âà∞ÊñπÊ≥ï‰∏äÔºå‰πüÂèØ‰ª•‰Ωú‰∏∫ÊèèËø∞Á¨¶‰ΩøÁî®„ÄÇ Êú¨ÊñáÊãæÂèñ‰∫ÜGraham DumpletonÂú®wraptÊ®°Âùó‰∏≠ÈôÑÂ∏¶ÁöÑ‰∏ÄÁ≥ªÂàóÂçöÊñáÁöÑÁâôÊÖßÔºåÊó®Âú®Â∏¶Êù•ÂØπpythonË£ÖÈ•∞Âô®Êõ¥Ê∑±ÁöÑÁêÜËß£ÂíåÊõ¥Â•ΩÁöÑËÆæËÆ°„ÄÇ ‰∏§Á±ªË£ÖÈ•∞Âô®ÂèäÂÜÖÁúÅÁº∫Èô∑ Ë£ÖÈ•∞Âô®Á¨¶ @ ÊòØ‰∏ÄÁßçËØ≠Ê≥ïÁ≥ñÔºåÊ∑±Á©∂ÂéüÁêÜÁöÑËØù‰ΩøÁî®Ë£ÖÈ•∞Âô®ÂÆûÈôÖ‰∏äÊòØ‰∏ÄÁßçÁå¥Â≠êË°•‰∏ÅÁöÑÂÆûÁé∞ÊñπÂºè„ÄÇ‰ª•‰∏ãÁöÑ‰∏§ÁßçÊñπÂºèÊòØÁ≠â‰ª∑ÁöÑÔºö @function_wrapper def function (): pass Á≠â‰ª∑‰∫é #Âú®python2.4ÁâàÊú¨‰Ω†‰ºöËøô‰πàÂÅö def function (): pass function = function_wrapper ( function ) ËÄåÂØπ‰∫éË£ÖÈ•∞Âô®ÁöÑÂÆûÁé∞ÔºåÊàë‰ª¨Êúâ‰ª•‰∏ã‰∏§ÁßçÊñπÂºèÔºö 1.ÂÆö‰πâÁ±ª class function_wrapper : def __init__ ( self , wrapped ): self . wrapped = wrapped def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) @function_wrapper def function (): pass #ÈÄöËøáÈ≠îÊúØÊñπÊ≥ï__call__Êù•ËøêË°åË¢´ÂåÖË£πÁöÑÊñπÊ≥ï 2.‰ΩøÁî®Èó≠ÂåÖÂáΩÊï∞ def function_wrapper ( wrapped ): def _wrapper ( * args , ** kwargs ): return wrapped ( * args , ** kwargs ) return _wrapper @function_wrapper def function (): pass ÁÑ∂ËÄåÁî±‰∫éÊèèËø∞Á¨¶ÁöÑÂéüÂõ†Ôºå‰ΩøÁî®Á±ª‰Ωú‰∏∫Ë£ÖÈ•∞Âô®ÊòØ‰∏Ä‰∏™Êõ¥Â•ΩÂú∞ÈÄâÊã©„ÄÇ ÂØπ‰∫éÁõ¥Êé•ÂÆö‰πâÁöÑË£ÖÈ•∞Âô®ÔºåË¢´Ë£ÖÈ•∞ÁöÑÊñπÊ≥ïÁöÑ name Âíå doc Â±ûÊÄßÂ∞Ü‰ºö‰∏¢Â§±ÔºåÂõ†Ê≠§Ê†áÂáÜÂ∫ìfunctoolsÊèê‰æõ‰∫Ü warps Âíå update_wrapper Ë£ÖÈ•∞Âô®Êù•Â∞ÜË¢´Ë£ÖÈ•∞ÊñπÊ≥ïÁöÑËá™ÁúÅÂ±ûÊÄß‰º†ÈÄíÁªôË£ÖÈ•∞Âô®Ôºö import functools def function_wrapper ( wrapped ): #ÂØπÈó≠ÂåÖ‰ΩøÁî®functools.wrapsË£ÖÈ•∞ @functools . wraps ( wrapped ) def _wrapper ( * args , ** kwargs ): return wrapped ( * args , ** kwargs ) return _wrapper class function_wrapper : def __init__ ( self , wrapped ): self . wrapped = wrapped #ÂØπ‰∫éÁ±ª‰ΩøÁî®functools.update_wrapperË£ÖÈ•∞ functools . update_wrapper ( self , wrapped ) def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) @function_wrapper def function (): pass ‰∫ãÂÆû‰∏äwarps()ÈáçÁî®‰∫Üupdate_wrapper()ÁöÑ‰ª£Á†ÅÔºå‰∏∫‰∫ÜÊõ¥Â•ΩÂú∞ÁêÜËß£Ë£ÖÈ•∞Âô®ÁöÑËøê‰ΩúÔºå‰∏çÂ¶®ËÆ©Êàë‰ª¨Êù•Áúã‰∏Ä‰∏ãÂÆÉÁöÑÊ∫êÁ†Å„ÄÇ \"\"\" python 3.3ÁâàÊú¨ÁöÑupdate_wrapper()ÁöÑÊ∫êÁ†Å,Âú®ËøôÈáåÂ∞ÜË¢´Ë£ÖÈ•∞ÁöÑÊñπÊ≥ï‰øùÂ≠òÂú®__wrapped__Â±ûÊÄß‰∏≠„ÄÇËøôÊòØ‰∏Ä‰∏™bugÔºå3.4‰∏≠Â∞ÜËøô‰∏ÄÊ≠•ÊîæÂú®‰∫ÜÂáΩÊï∞‰ΩìÁöÑÊúÄÂêé„ÄÇ Ëøô‰∏™ÂáΩÊï∞ÂèàÂ∞ÜWRAPPER_ASSIGNMENTS‰∏≠ÁöÑÂ±ûÊÄß‰ªéË¢´Ë£ÖÈ•∞ÂáΩÊï∞wrapped‰∏≠Â§çÂà∂Âà∞Ë£ÖÈ•∞Âô®wrapper‰∏≠„ÄÇ ÊúÄÂêéÂ∞ÜË¢´Ë£ÖÈ•∞ÂáΩÊï∞__dict__‰∏≠ÁöÑÂÜÖÂÆπÂ§çÂà∂Âà∞Ë£ÖÈ•∞Âô®‰∏≠„ÄÇ \"\"\" WRAPPER_ASSIGNMENTS = ( '__module__' , '__name__' , '__qualname__' , '__doc__' , '__annotations__' ) WRAPPER_UPDATES = ( '__dict__' ,) def update_wrapper ( wrapper , wrapped , assigned = WRAPPER_ASSIGNMENTS , updated = WRAPPER_UPDATES ): wrapper . __wrapped__ = wrapped for attr in assigned : try : value = getattr ( wrapped , attr ) except AttributeError : pass else : setattr ( wrapper , attr , value ) for attr in updated : getattr ( wrapper , attr ) . update ( getattr ( wrapped , attr , {})) ÁÑ∂ËÄåÔºåÂç≥‰æø‰ΩøÁî®‰∫ÜfunctoolsÁöÑ‰øÆÊ≠£ÊñπÊ≥ï‰øùÂ≠ò‰∫ÜÂéüÂáΩÊï∞ÁöÑ name Âíå doc ÊñπÊ≥ïÔºå‰ΩÜËøòÊòØ‰ºöÂú®‰ª•‰∏ãÂá†‰∏™ÊñπÈù¢Â≠òÂú®Áº∫Èô∑Ôºö ‰øùÂ≠òÂáΩÊï∞ÂèÇÊï∞ËßÑËåÉÔºà inspect.getargspec() Ôºâ ‰øùÂ≠òÂáΩÊï∞Ëé∑ÂèñÊ∫êÁ†ÅÁöÑËÉΩÂäõÔºà inspect.getsource() Ôºâ * Âè†Âä†ÈôÑÂä†Âú®ÊèèËø∞Á¨¶‰∏äÁöÑËÉΩÂäõ Ëß£ÂÜ≥ÊñπÊ°à ÊèèËø∞Á¨¶Ë£ÖÈ•∞Âô® Ëß£ÂÜ≥ÈóÆÈ¢òÁöÑ‰∏Ä‰∏™ÂäûÊ≥ïÊòØ‰∏∫ÊôÆÈÄöÂáΩÊï∞ÂíåÁ±ª‰∏≠ÂáΩÊï∞ÂàÜÈÖçÂêÑËá™ÁöÑË£ÖÈ•∞ÊñπÊ≥ïÔºåËøôÊ†∑ÂΩ¢ÊàêÁöÑË£ÖÈ•∞Âô®‰πü‰ºöÊòØ‰∏ÄÁßçÊèèËø∞Á¨¶„ÄÇ class bound_function_wrapper : def __init__ ( self , wrapped ): self . wrapped = wrapped functools . update_wrapper ( self , wrapped ) def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) class function_wrapper : def __init__ ( self , wrapped ): self . wrapped = wrapped functools . update_wrapper ( self , wrapped ) def __get__ ( self , instance , owner ): wrapped = self . wrapped . __get__ ( instance , owner ) return bound_function_wrapper ( wrapped ) def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) Â¶ÇÊûúË£ÖÈ•∞Âô®ÈôÑÂä†Âú®‰∏Ä‰∏™ÊôÆÈÄöÂáΩÊï∞‰∏äÔºå‰ºö‰ΩøÁî®function_wrapperÁöÑ__call__ÊñπÊ≥ïËøîÂõûÁöÑÂáΩÊï∞„ÄÇËÄåÂ¶ÇÊûúÊòØÈôÑÂä†Âú®Á±ªÊñπÊ≥ï‰∏äÁöÑËØùÔºåÂàô‰ºöË∞ÉÁî®__get__ÊñπÊ≥ïËøîÂõû‰∏Ä‰∏™ÁªëÂÆöinstanceÁöÑwrapperÔºåÁÑ∂ÂêéÂÆÉÁöÑ__call__ÊñπÊ≥ïÂàô‰ºöË¢´Ëß¶Âèë„ÄÇËøô‰ΩøÂæóËØ•Ë£ÖÈ•∞Âô®ËÉΩ‰º†ÈÄíÊèèËø∞Á¨¶ÂçèËÆÆ„ÄÇ ÂÄºÂæó‰∏ÄÊèêÁöÑÊòØÔºåÊØèÊ¨°ÂΩìËøô‰∏™wrapperÈôÑÂä†Âú®Á±ªÊñπÊ≥ï‰∏äË¢´Ë∞ÉÁî®ÁöÑÊó∂ÂÄôÔºå‰∏Ä‰∏™Êñ∞ÁöÑËæÖÂä©wrapperÂ∞Ü‰ºöË¢´ÂàõÂª∫„ÄÇËøôÁÇπÊó†ÁñëÂΩ±Âìç‰∫ÜÊïàÁéá„ÄÇÊàë‰ª¨ÂèØËÉΩÈúÄË¶Å‰∏Ä‰∏™Êõ¥Âä†È´òÊïàÁöÑÊñπÊ≥ïÊù•ÂÆûÁé∞ËøôÁßçË£ÖÈ•∞Âô®‰∫Ü„ÄÇ ÈÄèÊòéÂØπË±°‰ª£ÁêÜ ÂØπ‰∫é‰ª•‰∏äÈóÆÈ¢òÁöÑËß£ÂÜ≥ÊñπÊ°àË¢´Áß∞‰∏∫ÂØπË±°‰ª£ÁêÜ„ÄÇ‰ª•‰∏ãÊòØ‰∏Ä‰∏™‰∏éË¢´ÂÆÉÂåÖË£ÖÁöÑÂØπË±°Áúã‰∏äÂéªÂæàÁõ∏‰ººÁöÑwrapperÔºö #Ëøô‰∏™ÂØπË±°‰ª£ÁêÜÁöÑ‰æãÂ≠êÂè™‰ª£ÁêÜ‰∫Ü‰∏Ä‰∫õÂü∫Êú¨ÁöÑÊñπÊ≥ï„ÄÇ class object_proxy : def __init__ ( self , wrapped ): self . wrapped = wrapped try : self . __name__ = wrapped . __name__ except AttributeError : pass @property def __class__ ( self ): return self . wrapped . __class__ def __getattr__ ( self , name ): return getattr ( self . wrapped , name ) Êúâ‰∫ÜËøô‰∏™wrapperÁ±ªÊàë‰ª¨Â∞±ÂèØ‰ª•Ë∑ü update_wrapper() ËØ¥ÊãúÊãú‰∫Ü„ÄÇÂèØ‰ª•ÂØπÊàë‰ª¨ÁöÑË£ÖÈ•∞Âô®ÂÅö‰ª•‰∏ã‰øÆÊîπÔºö class bound_function_wrapper ( object_proxy ): def __init__ ( self , wrapped ): super () . __init__ ( wrapped ) def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) class function_wrapper ( object_proxy ): def __init__ ( self , wrapped ): super () . __init__ ( wrapped ) def __get__ ( self , instance , owner ): wrapped = self . wrapped . __get__ ( instance , owner ) return bound_function_wrapper ( wrapped ) def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) ËøôÊó∂__name__Âíå__doc__ ‰πãÁ±ªÁöÑÂ±ûÊÄßÂ∞Ü‰ºö‰ªé‰ª£ÁêÜÂØπË±°‰∏≠Ëé∑ÂèñÔºåinspect.getargspec()Âíåinspect.getsource()‰πüËÉΩÂ§üÈ°∫Âà©Â∑•‰Ωú„ÄÇ Ëøô‰∏™ÊñπÊ°àËøòÂ≠òÂú®ÁöÑ‰∏Ä‰∏™ÊòéÊòæÁº∫Èô∑Â∞±ÊòØÔºöÊØèÊ¨°Êàë‰ª¨Ë¶ÅÂÆö‰πâ‰∏Ä‰∏™Êñ∞Ë£ÖÈ•∞Âô®‰æøË¶ÅÁªßÊâøobject_proxy‰ª£ÁêÜÂáΩÊï∞Âπ∂ÂÜô‰∏§‰∏™Á±ªÁöÑ‰ª£Á†Å„ÄÇ‰∏∫‰∫ÜËÆ©Êàë‰ª¨ÁöÑË£ÖÈ•∞Âô®Êõ¥Â•ΩÁî®‰∏çÂ¶®Áî®Â∑•ÂéÇÂáΩÊï∞Êù•Â∏ÆÊàë‰ª¨ÂÆåÊàêËøôÈ°πÈáçÂ§çÂ∑•‰Ωú„ÄÇ ‰ΩøÁî®Ë£ÖÈ•∞Âô®Â∑•ÂéÇÊù•ÂàõÂª∫Ë£ÖÈ•∞Âô® Âú®ËøôËäÇÊàë‰ª¨ÁöÑÁõÆÁöÑÊòØÂàõÂª∫‰∏Ä‰∏™Â∏ÆÂä©Êàë‰ª¨Êõ¥Â•ΩÂú∞ÂàõÂª∫Ë£ÖÈ•∞Âô®ÁöÑË£ÖÈ•∞Âô®„ÄÇËøôÂèØËÉΩÂê¨Ëµ∑Êù•Êúâ‰∫õÊãóÂè£Ôºå‰ΩÜËøôÁßçËÆæËÆ°Á°ÆÂÆûËÉΩÂáèÂ∞ëÊàë‰ª¨ÊûÑÂª∫‰∏Ä‰∏™Êñ∞ÁöÑË£ÖÈ•∞Âô®Êó∂ÂÄôÁöÑ‰ª£Á†Å„ÄÇÁÆÄËÄåË®Ä‰πãÔºåÊàë‰ª¨ÁöÑÁõÆÊ†áÊòØËÆ©Êàë‰ª¨ÂèØ‰ª•ÂÉèËøôÊ†∑ÂàõÂª∫‰∏Ä‰∏™Ë£ÖÈ•∞Âô®Ôºö @decorator def my_function_wrapper ( wrapped , args , kwargs ): return wrapped ( * args , ** kwargs ) @my_function_wrapper def function (): pass ‰∫ãÂÆû‰∏äÔºåÊàë‰ª¨ÁöÑË£ÖÈ•∞Âô®Â∑•ÂéÇÁöÑÂÆûÁé∞ÊñπÂºèÂíå‰ΩøÁî® partial() ÂáΩÊï∞ÂæàÂÉèÔºåÂÆÉÂú®ÂÆö‰πâÊó∂Â∞ÜÊñ∞Ë£ÖÈ•∞Âô®ÁªëÂÖ•ÔºåÂú®ËøêË°åÊó∂Êé•ÂèóË¢´Êñ∞Ë£ÖÈ•∞Âô®Ë£ÖÈ•∞ÁöÑÁöÑÂØπË±°„ÄÇÂõ†Ê≠§Âú®Êàë‰ª¨‰πãÂâçÁöÑÂÆö‰πâÁöÑË£ÖÈ•∞Âô®Âü∫Á°Ä‰∏äË¶Å‰º†ÂÖ•wrapperÂèÇÊï∞„ÄÇ import functools def decorator ( wrapper ): @functools . wraps ( wrapper ) def _decorator ( wrapped ): return function_wrapper ( wrapped , wrapper ) return _decorator class bound_function_wrapper ( object_proxy ): def __init__ ( self , wrapped , wrapper ): super () . __init__ ( wrapped ) self . instace = instance #‰∏∫‰πãÂêéÁöÑÂÜÖÁúÅ‰øùÂ≠òinstanceÂ±ûÊÄß self . wrapper = wrapper def __call__ ( self , * args , ** kwargs ): if self . instance is None : #ÂΩìÁ±ªÊñπÊ≥ï‰ª•Class.method(instance,arg1,arg2)ÁöÑÂΩ¢ÂºèË∞ÉÁî® #ÁöÑÊó∂ÂÄôÔºå‰ºö‰∫ßÁîüself.instance‰∏∫NoneÁöÑÁâπÊÆäÊÉÖÂÜµÔºåËøôÊó∂Á¨¨‰∏Ä #‰∏™ÂèÇÊï∞‰∏∫instanceÔºåÂÖ∂‰ΩôÂèÇÊï∞‰∏∫‰º†ÂÖ•ÂèòÈáèÔºå‰ª•Ëøô‰∏™ÂΩ¢ÂºèËøîÂõûË¢´ #Ë£ÖÈ•∞Â•ΩÁöÑÁ±ªÊñπÊ≥ï instance , args = args [ 0 ], args [ 1 :] wrapped = functools . partial ( self . wrapped , instance ) return self . wrapper ( wrapped , instance , args , kwargs ) return self . wrapper ( self . wrapped , self . instance , args , kwargs ) class function_wrapper ( object_proxy ): def __init__ ( self , wrapped , wrapper ): super () . __init__ ( wrapped ) self . wrapper = wrapper def __get__ ( self , instance , owner ): wrapped = self . wrapped . __get__ ( instance , owner ) return bound_function_wrapper ( wrapped , instance , self . wrapper ) #ÂΩìË£ÖÈ•∞Âô®ÈôÑÂä†Âú®Á±ªÊñπÊ≥ïÊó∂‰º†ÂÖ•ËØ•instance def __call__ ( self , * args , ** kwargs ): return self . wrapper ( self . wrapped , None , args , kwargs ) #ÂΩìË£ÖÈ•∞Âô®ÈôÑÂä†Âú®ÊôÆÈÄöÂáΩÊï∞Êó∂instanceÂèòÈáè‰º†ÂÖ•None Ëøô‰∏™Ë£ÖÈ•∞Âô®Â∑•ÂéÇÁöÑ‰ΩøÁî®Á§∫‰æãÂ¶Ç‰∏ãÔºö @decorator def my_function_wrapper ( wrapped , instance , args , kwargs ): print ( 'INSTANCE' , instance ) print ( 'ARGS' , args ) return wrapped ( * args , ** kwargs ) @my_function_wrapper def function ( a , b ): pass class Class ( object ): @my_function_wrapper def function_im ( self , a , b ): pass >>> function ( 1 , 2 ) INSTANCE None ARGS ( 1 , 2 ) >>> c . function_im ( 1 , 2 ) INSTANCE < __main__ . Class object at 0x1085ca9d0 > ARGS ( 1 , 2 ) >>> Class . function_im ( c , 1 , 2 ) INSTANCE < __main__ . Class object at 0x1085ca9d0 > ARGS ( 1 , 2 ) ÂèØ‰ª•ÁúãÂà∞Ëøô‰∏™ËÆæËÆ°Â∑≤ÁªèÊØîËæÉÂ•ΩÂú∞Ëß£ÂÜ≥‰∫ÜÊàë‰ª¨‰πãÂâçÈÅáÂà∞ÁöÑÈÇ£‰∫õÈóÆÈ¢òÔºå‰ΩÜËøô‰ªçÊóß‰∏çÊòØ‰∏Ä‰∏™ÂÆåÁæéÁöÑÊñπÊ°à„ÄÇÁßâÊåÅÁùÄÊ±ÇÁúüÂä°ÂÆûÁöÑÁ≤æÁ•ûÔºåÊàë‰ª¨ÂèØ‰ª•ÂèëÁé∞ËØ•Ë£ÖÈ•∞Âô®Â¶ÇÊûúÂè†Âä†ËΩΩclassmethod‰∏äÂàô‰ºöÂá∫Áé∞ÈóÆÈ¢òÔºö class Class ( object ): @my_function_wrapper @classmethod def function_cm ( cls , a , b ): pass >>> Class . function_cm ( 1 , 2 ) INSTANCE 1 ARGS ( 2 ,) Êàë‰ª¨‰πüÂæàÁªùÊúõÂïä,ÊâÄ‰ª•Âè™ËÉΩÊîπËøõÂï¶„ÄÇÊé•‰∏ãÊù•Êàë‰ª¨‰ºöËÆæËÆ°‰∏Ä‰∏™Áªü‰∏ÄË£ÖÈ•∞Âô®ÔºàÂÆáÂÆôË£ÖÈ•∞Âô®ÔºâÊù•ÂØπË£ÖÈ•∞Âô®ÈôÑÂä†Âú®ÊôÆÈÄöÂáΩÊï∞„ÄÅÂÆû‰æãÊñπÊ≥ï„ÄÅÁ±ªÊñπÊ≥ï„ÄÅÈùôÊÄÅÂáΩÊï∞ÁîöËá≥Á±ª‰∏äÁöÑÊÉÖÂÜµÂàÜÂèëÂØπÂ∫îÁöÑÁ≠ñÁï•„ÄÇ ËÆ≤Á±ªÊñπÊ≥ïÂíåÈùôÊÄÅÊñπÊ≥ïÁ∫≥ÂÖ•ÁñÜÁïå Âú®Ëß£ÂÜ≥‰πãÂâçÔºåÊàë‰ª¨ÂÖàÊòéÁ°Æ‰∏Ä‰∏ãÈóÆÈ¢ò„ÄÇÊàë‰ª¨ÁöÑÁõÆÊ†áÊòØËÆ©Êàë‰ª¨ÁöÑË£ÖÈ•∞Âô®ËÉΩÂ§üÂå∫ÂàÜ‰ª•‰∏ã‰∏âÁßç‰∏çÂêåÁöÑÊñπÊ≥ïÔºö ÈÄöËøáÁ±ªÁöÑÈÄîÂæÑËøêË°åÁöÑÂÆû‰æãÊñπÊ≥ï Ë¢´classmethodË£ÖÈ•∞ÁöÑÁ±ªÊñπÊ≥ï * Ë¢´staticmethodË£ÖÈ•∞ÁöÑÈùôÊÄÅÊñπÊ≥ï È¶ñÂÖàËÉΩÊÉ≥Âà∞ÁöÑÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÊñπÊ≥ïÔºåÂ∞±ÊòØÂú®‰º†ÂÖ•‰∏Ä‰∏™ÂèÇÊï∞Êù•ËÆ∞ÂΩïË¢´ÁªëÂÆöÁöÑÊñπÊ≥ïÁ±ªÂûã„ÄÇÂõ†Ê≠§Êàë‰ª¨ÂèØ‰ª•ÂØπ‰ª£Á†Å‰ΩúÂ¶Ç‰∏ã‰øÆÊîπ„ÄÇ class bound_function_wrapper ( object_proxy ): def __init__ ( self , wrapped , instance , wrapper , binding ): super ( bound_function_wrapper , self ) . __init__ ( wrapped ) self . instance = instance self . wrapper = wrapper self . binding = binding #‰º†ÂÖ•ÁªëÂÆöÁöÑÊñπÊ≥ïÁ±ªÂûã def __call__ ( self , * args , ** kwargs ): if self . binding == 'function' : #ÊñπÊ≥ïË∞ÉÁî® if self . instance is None : #‰ª•Class.method(instan,args,kwargs)ÂΩ¢ÂºèË∞ÉÁî®ÔºåÂàôÂèñÁ¨¨‰∏Ä‰∏™ÂèÇÊï∞‰Ωú‰∏∫self instance , args = args [ 0 ], args [ 1 :] wrapped = functools . partial ( self . wrapped , instance ) return self . wrapper ( wrapped , instance , args , kwargs ) else : #‰ª•instance.method()ÊñπÂºèË∞ÉÁî® return self . wrapper ( self . wrapped , self . instance , args , kwargs ) else : #Â¶ÇÊûúÊòØÁ±ªÊñπÊ≥ïÊàñËÄÖÈùôÊÄÅÊñπÊ≥ïË∞ÉÁî® instance = getattr ( self . wrapped , '__self__' , None ) #ÂΩì‰∏∫Êó∂Á±ªÊñπÊ≥ïinstanceÂèòÈáèÁ≠â‰∫éÊñπÊ≥ï__self__Âç≥ClassÂØπË±°ÔºåÂΩì‰∏∫ÈùôÊÄÅÊñπÊ≥ïÊó∂Âàô‰∏∫None return self . wrapper ( self . wrapped , instance , args , kwargs ) class function_wrapper ( object_proxy ): def __init__ ( self , wrapped , wrapper ): super ( function_wrapper , self ) . __init__ ( wrapped ) self . wrapper = wrapper #Âà§Êñ≠Ë¢´ÁªëÂÆöÊñπÊ≥ïÁöÑÁßçÁ±ª if isinstance ( wrapped , classmethod ): self . binding = 'classmethod' elif isinstance ( wrapped , staticmethod ): self . binding = 'staticmethod' else : self . binding = 'function' def __get__ ( self , instance , owner ): wrapped = self . wrapped . __get__ ( instance , owner ) return bound_function_wrapper ( wrapped , instance , self . wrapper , self . binding ) def __call__ ( self , * args , ** kwargs ): return self . wrapper ( self . wrapped , None , args , kwargs ) Êé•‰∏ãÊù•Êàë‰ª¨ÂèØ‰ª•ÂàÜÂà´ÂØπÊôÆÈÄöÁ±ªÊñπÊ≥ïimÔºåÁ±ªÊñπÊ≥ïcmÔºåÈùôÊÄÅÊñπÊ≥ïsmÂÅöÊµãËØïÊù•Ê£ÄÈ™å‰∫ÜÔºö >>> c . function_im ( 1 , 2 ) INSTANCE < __main__ . Class object at 0x10c2c43d0 > ARGS ( 1 , 2 ) >>> Class . function_im ( c , 1 , 2 ) INSTANCE < __main__ . Class object at 0x10c2c43d0 > ARGS ( 1 , 2 ) >>> c . function_cm ( 1 , 2 ) INSTANCE < class ' __main__ . Class '> ARGS ( 1 , 2 ) >>> Class . function_cm ( 1 , 2 ) INSTANCE < class ' __main__ . Class '> ARGS ( 1 , 2 ) >>> c . function_sm ( 1 , 2 ) INSTANCE None ARGS ( 1 , 2 ) >>> Class . function_sm ( 1 , 2 ) INSTANCE None ARGS ( 1 , 2 ) ÂÜôÂÆåËøô‰∫õ‰ª£Á†ÅÂ∞±ÂèØ‰ª•‰∫ÜÂòõÔºåÂæà‰∏çÂπ∏ÁöÑÂëäËØâ‰Ω†ÔºåËøôËøò‰∏çÂ§ü„ÄÇÂú®Êé•‰∏ãÊù•ÁöÑÂçöÊñá‰∏≠‰ºöÂ±ïÁé∞GrahamDumpletonÂØπË£ÖÈ•∞Âô®ÁêÜËß£ÁöÑÊñπÊñπÈù¢Èù¢ÔºåËÆ©Êàë‰ª¨Êù•ÁúãÁúã‰ªñÂØπÂÆåÁæéË£ÖÈ•∞Âô®ÁöÑ‰∏çÊáàËøΩÊ±ÇÂêß„ÄÇ Additional ÂèÇËÄÉÊñáÁåÆ: 1. Wrapt blog","tags":"Python","title":"PythonË£ÖÈ•∞Âô®ÁöÑÊ≠£Á°ÆÊâìÂºÄÊñπÂºè(1)"},{"url":"leetcode-linked-list-random-node.html","text":"Description Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? Example: // Init a singly linked list [ 1 , 2 , 3 ]. ListNode head = new ListNode ( 1 ); head . next = new ListNode ( 2 ); head . next . next = new ListNode ( 3 ); Solution solution = new Solution ( head ); // getRandom () should return either 1 , 2 , or 3 randomly . Each element should have equal probability of returning . solution . getRandom (); Source link Analytics ÂΩìÊï∞ÊçÆÊµÅÈïøÂ∫¶Â∑≤Áü•Êàñ‰∏çÂ§ßÁöÑÊó∂ÂÄôÂèØ‰ª•ÁÆÄÂçïÁöÑËß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢òÔºöÈÅçÂéÜÈìæË°®‰πãÂêéÂæóÂà∞ÈïøÂ∫¶nÔºå‰ª• $$ {\\frac{1}{n}} $$ ÁöÑÊ¶ÇÁéáÈÄâÂèñÂÖÉÁ¥†„ÄÇ ‰ΩÜÂΩìÁªôÂá∫Êï∞ÊçÆÊµÅÁöÑÈïøÂ∫¶ÂæàÂ§ßÊàñËÄÖÊú™Áü•Êó∂ÔºåÊàë‰ª¨Â∞ÜÊó†Ê≥ïÂÅöÈÅçÂéÜÈìæË°®ÂæóÂà∞ÈïøÂ∫¶ÁöÑÊìç‰Ωú„ÄÇÊ≠§Êó∂Âõ†‰∏∫Êï∞ÊçÆÊµÅÂæàÂ§ßÔºå‰∏∫‰∫ÜËøΩÊ±ÇÊïàÁéáÔºåËØ•Êï∞ÊçÆÊµÅ‰∏≠Êï∞ÊçÆÂè™ËÉΩËÆøÈóÆ‰∏ÄÊ¨°„ÄÇÊúâÊ≤°ÊúâËøô‰πà‰∏Ä‰∏™ÈöèÊú∫ÈÄâÊã©ÁÆóÊ≥ïÔºå‰ΩøÂæóËØ•Êï∞ÊçÆÊµÅ‰∏≠ÁöÑÊâÄÊúâÊï∞ÊçÆË¢´ÈÄâ‰∏≠ÁöÑÊ¶ÇÁéáÁõ∏Á≠âÂë¢Ôºü Ëøô‰∏™Êó†ËæπÁïåÁöÑÈóÆÈ¢òÁ°ÆÂÆûÂæàËÆ©‰∫∫Â§¥ÁñºÂïäÔºå‰ΩÜÂπ∏ËøêÁöÑÊòØÔºåËøôÊàë‰ª¨ÂèØ‰ª•Áî®‰∏∫ËìÑÊ∞¥Ê±†ÊäΩÊ†∑ÔºàReservoir SamplingÔºâÁöÑÊñπÊ≥ïÊù•Ëß£ÂÜ≥ËØ•Á±ªÈóÆÈ¢ò„ÄÇ ËìÑÊ∞¥Ê±†ÊäΩÊ†∑‰ªãÁªç ËìÑÊ∞¥Ê±†ÊäΩÊ†∑ÊòØ‰∏ÄÁßç‰ªé‰∏Ä‰∏™ÂåÖÂê´ n ‰∏™ÂÖÉÁ¥†ÁöÑÂàóË°® S ‰∏≠ÈöèÊú∫ÊäΩÂèñ k ‰∏™Ê†∑Êú¨ÁöÑÈöèÊú∫ÁÆóÊ≥ïÔºåËøôÈáåÁöÑ n ÊòØ‰∏Ä‰∏™ÈùûÂ∏∏Â§ßÊàñËÄÖÊú™Áü•ÁöÑÂÄº„ÄÇ Ëøô‰∏™ÁÆóÊ≥ïÁöÑÂü∫Êú¨ÊÄùÊÉ≥Â∞±ÊòØÂÖàÈÄâ‰∏≠ 1 Âà∞ k ‰∏™ÂÖÉÁ¥†Ôºå‰Ωú‰∏∫Ë¢´ÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†„ÄÇÁÑ∂Âêé‰æùÊ¨°ÂØπÁ¨¨ k+1 Ëá≥Á¨¨ n ‰∏™ÂÖÉÁ¥†ÂÅö‰ª•‰∏ãÊìç‰ΩúÔºö ÊØè‰∏™ÂÖÉÁ¥†ÈÉΩÊúâ $$ {\\frac{k}{i}} $$ ÁöÑÊ¶ÇÁéáË¢´ÈÄâ‰∏≠ÔºåÁÑ∂Âêé‰ª•Á≠âÊ¶ÇÁéá $$ {\\frac{1}{k}} $$ ÊõøÊç¢ÊéâË¢´ÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†„ÄÇÂÖ∂‰∏≠ i ÊòØÂÖÉÁ¥†ÁöÑÂ∫èÂè∑„ÄÇ ÁÆóÊ≥ïËØÅÊòé ÁÆóÊ≥ïÁöÑÊàêÁ´ãÊòØÁî®Êï∞Â≠¶ÂΩíÁ∫≥Ê≥ïËØÅÊòéÁöÑ: ËÆæÊØèÊ¨°ÈÉΩÊòØ‰ª• k / i ÁöÑÊ¶ÇÁéáÊù•ÈÄâÊã©„ÄÇÂÅáËÆæÂΩìÂâçÊòØ i + 1 , ÊåâÁÖßÊàë‰ª¨ÁöÑËßÑÂÆöÔºå i + 1 Ëøô‰∏™ÂÖÉÁ¥†Ë¢´ÈÄâ‰∏≠ÁöÑÊ¶ÇÁéáÊòØ k / i + 1 Ôºå‰πüÂç≥Á¨¨ i + 1 Ëøô‰∏™ÂÖÉÁ¥†Âú®ËìÑÊ∞¥Ê±†‰∏≠Âá∫Áé∞ÁöÑÊ¶ÇÁéáÊòØ k / i + 1 Ê≠§Êó∂ËÄÉËôëÂâç i ‰∏™ÂÖÉÁ¥†ÔºåÂ¶ÇÊûúÂâç i ‰∏™ÂÖÉÁ¥†Âá∫Áé∞Âú®ËìÑÊ∞¥Ê±†‰∏≠ÁöÑÊ¶ÇÁéáÈÉΩÊòØ k / i + 1 ÁöÑËØùÔºåËØ¥ÊòéÊàë‰ª¨ÁöÑÁÆóÊ≥ïÊòØÊ≤°ÊúâÈóÆÈ¢òÁöÑ„ÄÇ ÂØπËøô‰∏™ÈóÆÈ¢òÂèØ‰ª•Áî®ÂΩíÁ∫≥Ê≥ïÊù•ËØÅÊòéÔºö k < i <= N Ôºö 1 . ÂΩì i = k + 1 ÁöÑÊó∂ÂÄôÔºåËìÑÊ∞¥Ê±†ÁöÑÂÆπÈáè‰∏∫ k ÔºåÁ¨¨ k + 1 ‰∏™ÂÖÉÁ¥†Ë¢´ÈÄâÊã©ÁöÑÊ¶ÇÁéáÊòéÊòæ‰∏∫ k / ( k + 1 ), Ê≠§Êó∂Ââç k ‰∏™ÂÖÉÁ¥†Âá∫Áé∞Âú®ËìÑÊ∞¥Ê±†ÁöÑÊ¶ÇÁéá‰∏∫ k / ( k + 1 ), ÂæàÊòéÊòæÁªìËÆ∫ÊàêÁ´ã„ÄÇ 2 . ÂÅáËÆæÂΩì j = i ÁöÑÊó∂ÂÄôÁªìËÆ∫ÊàêÁ´ãÔºåÊ≠§Êó∂‰ª• k / i ÁöÑÊ¶ÇÁéáÊù•ÈÄâÊã©Á¨¨ i ‰∏™ÂÖÉÁ¥†ÔºåÂâç i - 1 ‰∏™ÂÖÉÁ¥†Âá∫Áé∞Âú®ËìÑÊ∞¥Ê±†ÁöÑÊ¶ÇÁéáÈÉΩ‰∏∫ k / i „ÄÇ ËØÅÊòéÂΩì j = i + 1 ÁöÑÊÉÖÂÜµÔºö Âç≥ÈúÄË¶ÅËØÅÊòéÂΩì‰ª• k / i + 1 ÁöÑÊ¶ÇÁéáÊù•ÈÄâÊã©Á¨¨ i + 1 ‰∏™ÂÖÉÁ¥†ÁöÑÊó∂ÂÄôÔºåÊ≠§Êó∂‰ªª‰∏ÄÂâç i ‰∏™ÂÖÉÁ¥†Âá∫Áé∞Âú®ËìÑÊ∞¥Ê±†ÁöÑÊ¶ÇÁéáÈÉΩ‰∏∫ k / ( i + 1 ). Ââç i ‰∏™ÂÖÉÁ¥†Âá∫Áé∞Âú®ËìÑÊ∞¥Ê±†ÁöÑÊ¶ÇÁéáÊúâ 2 ÈÉ®ÂàÜÁªÑÊàê , ‚ë†Âú®Á¨¨ i + 1 Ê¨°ÈÄâÊã©ÂâçÂæóÂá∫Áé∞Âú®ËìÑÊ∞¥Ê±†‰∏≠Ôºå‚ë°Âæó‰øùËØÅÁ¨¨ i + 1 Ê¨°ÈÄâÊã©ÁöÑÊó∂ÂÄô‰∏çË¢´ÊõøÊç¢Êéâ ‚ë† . Áî± 2 Áü•ÈÅìÂú®Á¨¨ i + 1 Ê¨°ÈÄâÊã©ÂâçÔºå‰ªª‰∏ÄÂâç i ‰∏™ÂÖÉÁ¥†Âá∫Áé∞Âú®ËìÑÊ∞¥Ê±†ÁöÑÊ¶ÇÁéáÈÉΩ‰∏∫ k / i ‚ë° . ËÄÉËôëË¢´ÊõøÊç¢ÁöÑÊ¶ÇÁéáÔºö È¶ñÂÖàË¶ÅË¢´ÊõøÊç¢ÂæóÁ¨¨ i + 1 ‰∏™ÂÖÉÁ¥†Ë¢´ÈÄâ‰∏≠ ( ‰∏çÁÑ∂‰∏çÁî®ÊõøÊç¢‰∫Ü ) Ê¶ÇÁéá‰∏∫ k / i + 1 ÔºåÂÖ∂Ê¨°ÊòØÂõ†‰∏∫ÈöèÊú∫ÊõøÊç¢ÁöÑÊ±†Â≠ê‰∏≠ k ‰∏™ÂÖÉÁ¥†‰∏≠‰ªªÊÑè‰∏Ä‰∏™ÔºåÊâÄ‰ª•‰∏çÂπ∏Ë¢´ÊõøÊç¢ÁöÑÊ¶ÇÁéáÊòØ 1 / k ÔºåÊïÖ Ââç i ‰∏™ÂÖÉÁ¥† ( Ê±†‰∏≠ÂÖÉÁ¥† ) ‰∏≠‰ªª‰∏ÄË¢´ÊõøÊç¢ÁöÑÊ¶ÇÁéá = k / ( i + 1 ) * 1 / k = 1 / i + 1 Âàô ( Ê±†‰∏≠ÂÖÉÁ¥†‰∏≠ ) Ê≤°ÊúâË¢´ÊõøÊç¢ÁöÑÊ¶ÇÁéá‰∏∫ : 1 - 1 / ( i + 1 ) = i / i + 1 ÁªºÂêà‚ë† ‚ë° , ÈÄöËøá‰πòÊ≥ïËßÑÂàô ÂæóÂà∞Ââç i ‰∏™ÂÖÉÁ¥†Âá∫Áé∞Âú®ËìÑÊ∞¥Ê±†ÁöÑÊ¶ÇÁéá‰∏∫ k / i * i / ( i + 1 ) = k / i + 1 ÊïÖËØÅÊòéÊàêÁ´ã ‰º™‰ª£Á†Å Init : a reservoir with the size Ôºö k for i = k + 1 to N M = random ( 1 , i ); if ( M < k ) SWAP the Mth value and ith value end for Âä†ÊùÉÂàÜÂ∏ÉÂºèËìÑÊ∞¥Ê±†ÊäΩÊ†∑ ÊúâÊó∂ÂÄôÊàë‰ª¨ÁöÑËìÑÊ∞¥Ê±†‰∏≠ÁöÑÊï∞ÊçÆÊòØÊúâÊùÉÈáçÔºåÁÆóÊ≥ïÂ∏åÊúõÊï∞ÊçÆË¢´ÊäΩÊ†∑ÈÄâ‰∏≠ÁöÑÊ¶ÇÁéáÂíåËØ•Êï∞ÊçÆÁöÑÊùÉÈáçÊàêÊ≠£ÊØî„ÄÇ2005Âπ¥Pavlos S. EfraimidisÂíåPaul G. SpirakisÁöÑËÆ∫Êñá Weighted random sampling with a reservoir Êèê‰æõ‰∫ÜÂØπ‰∫éÂä†ÊùÉÁä∂ÊÄÅ‰∏ãËøô‰∏ÄÈóÆÈ¢òÁöÑËß£ÂÜ≥ÊñπÊ°à„ÄÇ‰ªñÁöÑËß£Ê≥ïÊó¢ÁÆÄÂçïÂèà‰ºòÈõÖÔºåÂü∫Êú¨ÊÄùÊÉ≥Âíå‰∏äÈù¢ÁöÑÂàÜÂ∏ÉÂºèËìÑÊ∞¥Ê±†ÊäΩÊ†∑‰∏ÄËá¥ÔºöÂØπ‰∫éÊØè‰∏™Êï∞ÊçÆËÆ°ÁÆó‰∏Ä‰∏™0-1ÁöÑÂÄºRÔºåÂπ∂Ê±ÇrÁöÑnÊ¨°ÊñπÊ†π‰Ωú‰∏∫ËØ•Êï∞ÊçÆÁöÑÊñ∞ÁöÑRÂÄº„ÄÇËøôÈáåÁöÑnÂ∞±ÊòØËØ•Êï∞ÊçÆÁöÑÊùÉÈáç„ÄÇÊúÄÁªàÁÆóÊ≥ïËøîÂõûÂâçk‰∏™RÂÄºÊúÄÈ´òÁöÑÊï∞ÊçÆÁÑ∂ÂêéËøîÂõû„ÄÇÊ†πÊçÆËÆ°ÁÆóËßÑÂàôÔºåÊùÉÈáçË∂äÂ§ßÁöÑÊï∞ÊçÆËÆ°ÁÆóÊâÄÂæóÁöÑRÂÄºË∂äÊé•Ëøë1ÔºåÊâÄ‰ª•Ë∂äÊúâÂèØËÉΩË¢´ËøîÂõû„ÄÇ Best practice pythonÂÆûÁé∞ÁöÑÊôÆÈÄöËìÑÊ∞¥Ê±†ÁÆóÊ≥ï„ÄÇ python version ### Definition for singly-linked list. ### class ListNode(object): ### def __init__(self, x): ### self.val = x ### self.next = None import random class Solution ( object ): def __init__ ( self , head ): \"\"\" @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. :type head: ListNode \"\"\" self . head = head self . k = 1 #ÈöèÊú∫ÈÄâÂá∫ÁöÑÊï∞Èáè def getRandom ( self ): \"\"\" Returns a random node's value. :rtype: int \"\"\" count = 0 node = self . head for _ in range ( k ): result . append ( node . val ) node = node . next while node : count += 1 #‰∏∫linklistÊï∞ÈáèËÆ°Êï∞ÔºåËßÜ‰∏∫i r = random . randint ( 1 , count ) if r <= self . k : #‰ª•k/iÁöÑÊ¶ÇÁéáÊù•ÈÄâÊã© result [ r ] = node . val #ËøôÈáåÊ≤°ÊúâÁî®‰∫§Êç¢Êìç‰ΩúÔºå‰ºöÊúâÊï∞ÊçÆ‰∏¢Â§± node = node . next return self . result ### Your Solution object will be instantiated and called as such: ### obj = Solution(head) ### param_1 = obj.getRandom() Mark: 362 ms ËøôÊòØÁª¥Âü∫ÁôæÁßë‰∏äÂÖ≥‰∫éÂä†ÊùÉËìÑÊ∞¥Ê±†ÁÆóÊ≥ïÁöÑRËØ≠Ë®ÄÂÆûÁé∞„ÄÇ In many applications sampling is required to be according to the weights that are assigned to each items available in set. For example, it might be required to sample queries in a search engine with weight as number of times they were performed so that the sample can be analyzed for overall impact on user experience. There are two ways to interpret weights assigned to each item in the set: 1. Let the weight of each item be $$ {\\displaystyle w_{i}} w_{i} $$ and sum of all weights be W. We can convert weight to probability of item getting selected in sample as $$ {\\displaystyle P_{i}=w_{i}/W} $$ . 2. Let the weight of two items i and j be $$ {\\displaystyle w_{i}} w_{i} and {\\displaystyle w_{j}} w_{j} $$ . Let the probability of item i getting selected in sample be $$ {\\displaystyle p_{i}} p_{i }$$ , then we give $$ {\\displaystyle p_{j}=\\min(1,p_{i}{\\frac {w_{j}}{w_{i}}})} {\\displaystyle p_{j}=\\min(1,p_{i}{\\frac {w_{j}}{w_{i}}})} $$ . Algorithm A-Res ( * S is a stream of items to sample , R will contain the result S.Current returns current item in stream S.Weight returns weight of current item in stream S.Next advances stream to next position The power operator is represented by &#94; min - priority - queue supports : Count -> number of items in priority queue Minimum () -> returns minimum key value of all items Extract - Min () -> Remove the item with minimum key Insert ( key , Item ) -> Adds item with specified key * ) ReservoirSample ( S[1.. ? ] , R[1..k] ) H = new min - priority - queue while S has data r = Random ( 0 , 1 ) &#94; ( 1 / S.Weight ) // important : inclusive range if H.Count < k H.Insert ( r , S.Current ) else if H.Minimum < r H.Extract - Min () H.Insert ( r , S.Current ) S.Next Additional ÂèÇËÄÉÊñáÁåÆÔºö 1. Reservoir sampling 2. ËìÑÊ∞¥Ê±†ÊäΩÊ†∑ÂèäÂÆûÁé∞ 3. Êï∞ÊçÆÂ∑•Á®ãÂ∏àÂøÖÁü•ÁÆóÊ≥ïÔºöËìÑÊ∞¥Ê±†ÊäΩÊ†∑","tags":"Python,R","title":"LeetCode - Linked List Random Node"},{"url":"pythonicde-fan-han-shu.html","text":"Description Âõ†‰∏∫python‰∏çÊîØÊåÅÈáçËΩΩÊñπÊ≥ïÊàñÂáΩÊï∞ÔºåÊâÄ‰ª•Êàë‰ª¨Êó†Ê≥ïÂÉèjavaÈÇ£Ê†∑Áî®‰∏çÂêåÁöÑÁ≠æÂêçÂÆö‰πâÊüê‰∏™ÊñπÊ≥ïÁöÑÂèò‰ΩìÊù•ÂÆûÁé∞Áî®‰∏çÂêåÁöÑÊñπÂºèÂ§ÑÁêÜ‰∏çÂêåÁöÑÊï∞ÊçÆÁ±ªÂûãÔºåÂØºËá¥Ëøô‰∏™Âå∫Âà´ÁöÑÊ†πÊú¨ÂéüÂõ†ÊòØpythonËØ≠Ë®ÄÁöÑÂä®ÊÄÅÊÄß„ÄÇ‰ΩÜ‰πüÊ≠£Âõ†ÂæóÁõä‰∫éÊ≠§ÔºåÂà©Áî®Âä®ÊÄÅÂèÇÊï∞Á±ªÂûã‰ª•ÂèäÂ≠óÂÖ∏ÂèÇÊï∞ÂàóË°®ÔºåÂú®python‰∏≠Êàë‰ª¨Â∏∏Â∏∏ÂèØ‰ª•ÊääÊñπÊ≥ïÂèòÊàê‰∏Ä‰∏™ÂàÜÊ¥æÂáΩÊï∞Ôºå‰ΩøÁî®‰∏Ä‰∏≤if/elif/elseË∞ÉÁî®‰∏ìÈó®ÁöÑÂáΩÊï∞Êù•ÂÆûÁé∞Á±ªjavaÈáçËΩΩÁöÑÂäüËÉΩ„ÄÇÁÑ∂ËÄåËøôÊ†∑Âπ∂‰∏ç‰æø‰∫éÊ®°ÂùóÁöÑÁî®Êà∑ÊãìÂ±ïÔºåËøòÊòæÂæóÂæàÊÑöË†¢ÔºöÂÆûÁé∞‰∏ÄÈïøÔºåÂàÜÊ¥æÂáΩÊï∞‰ºöÂèòÂæóÂæàÂ§ßÔºåËÄå‰∏îÂÆÉ‰∏éÂêÑ‰∏™‰∏ìÈó®ÂáΩÊï∞‰πãÈó¥ÁöÑËÄ¶Âêà‰πüÂæàÁ¥ßÂØÜ„ÄÇ Êàë‰ª¨ËøôÈáåÁöÑÊ≥õÂûãÂáΩÊï∞ÊòØÊåáÁî±‰∏ÄÁªÑ‰∏∫‰∏çÂêåÁ±ªÂûãÂèÇÊï∞ÊâßË°åÁõ∏‰ººÊìç‰ΩúÁöÑÂáΩÊï∞ÁªÑÊàêÁöÑÂáΩÊï∞ÔºåÂÖ∑‰ΩìË∞ÉÁî®Âì™‰∏Ä‰∏™ÂáΩÊï∞ÁöÑÂÆûÁé∞ÂèñÂÜ≥‰∫éÂàÜÂèëÁÆóÊ≥ïÂíåÂèÇÊï∞Á±ªÂûãÔºà‰πüÂç≥ÊòØpython‰∏≠ÁöÑÂèÇÊï∞ÂàóË°®Á±ªÂûãÈáçËΩΩÔºâ„ÄÇÂú®ËøôÈáåÊàë‰ª¨‰æã‰∏æ‰∫Ü Fluent Python ÈáåÁöÑsingledispathÂíå Python Cookbook ÈáåÁöÑÂà©Áî®ÂáΩÊï∞Ê≥®Ëß£ÂÆûÁé∞ÊñπÊ≥ïÈáçËΩΩÁöÑ‰æãÂ≠ê„ÄÇÊù•Â±ïÁé∞ÂáΩÊï∞ÈáçËΩΩËøô‰∏ÄÈùôÊÄÅÁ±ªÂûãÁâπÊÄßÂú®pythonËøô‰∏™Âä®ÊÄÅÁ±ªÂûãËØ≠Ë®Ä‰∏≠ÁöÑÂÆûÁé∞‰ª•ÂèäÂ±ÄÈôê„ÄÇÂØπ‰∫éËøô‰∏™ÁâπÊÄßÂÆûÁé∞ÁâµÊâØÂà∞‰∫ÜpythonÁöÑÂ§öÁßçÂÖÉÁâπÊÄßËÆ©ÂÆÉÊàê‰∏∫‰∫Ü‰∏Ä‰∏™ÂÆûÂú®ÊúâË∂£ÁöÑËØùÈ¢ò„ÄÇ PythonÂçïÂàÜÂèëÂô®ÔºàSingledispatchÔºâÊòØÂÆûÁé∞Ê≥õÂûãÂáΩÊï∞ÁöÑ‰∏ÄÁßçÂΩ¢ÂºèÔºåÁî±‰∏Ä‰∏™Âçï‰∏ÄÂèÇÊï∞Êù•ÂÜ≥ÂÆöÈÄâÊã©ÂíåË∞ÉÁî®Âì™‰∏™ÂáΩÊï∞„ÄÇÂú®Python3.4‰∏≠ÔºåsingledispathÊñπÊ≥ïÁ¨¨‰∏ÄÂá∫Áé∞Âú®functoolsÊ®°Âùó‰∏≠Ôºå‰Ω†ÂèØ‰ª•Âú® PEP 443 ‚Äî Single-dispatch generic function ÊâæÂà∞ÂÖ≥‰∫éÂÆÉÊõ¥Â§öÁâπÊÄßÁöÑ‰ªãÁªç„ÄÇ Âú® Python Cookbook ‰∏≠‰ªãÁªç‰∫Ü‰∏Ä‰∏™‰∏çÂÆåÁæé‰ΩÜÂèØË°åÁöÑÂà©Áî®ÂáΩÊï∞Ê≥®Ëß£ÊñπÂºèÂÆûÁé∞ÊñπÊ≥ïÈáçËΩΩÁöÑÊñπÊ≥ïÔºåÂàÜÂà´Áî®ÂÖÉÂáΩÊï∞Âíå‰∏ésingledispathÁ±ª‰ººÁöÑË£ÖÈ•∞Âô®ÂÆûÁé∞„ÄÇËøôÊòØ‰∏Ä‰∏™ÊØîËæÉÊ∑±ÂÖ•ÁöÑÂÖ≥‰∫éÂáΩÊï∞Ê≥®Ëß£ÁöÑÂ∫îÁî®„ÄÇ‰Ω†‰πüÂèØ‰ª•Âú®‰πãÂâçÁöÑÂçöÊñá‰∏≠ÊâæÂà∞‰∏Ä‰∫õÊØîËæÉ‰∏çÊ∑±ÂÖ•ÁöÑÂØπ‰∫éÂáΩÊï∞Ê≥®Ëß£ÁöÑ Â∫îÁî® „ÄÇ ‰ª£Á†ÅÁ§∫‰æã Singledispatch Python 3.4 Êñ∞Â¢ûÁöÑ functools.singledispatch Ë£ÖÈ•∞Âô®ÂèØ‰ª•ÊääÊï¥‰ΩìÊñπÊ°àÊãÜÂàÜÊàêÂ§ö‰∏™Ê®°ÂùóÔºåÁîöËá≥ÂèØ‰ª•‰∏∫‰Ω†Êó†Ê≥ï‰øÆÊîπÁöÑÁ±ªÊèê‰æõ‰∏ìÈó®ÁöÑÂáΩÊï∞„ÄÇ‰ΩøÁî® @singledispatch Ë£ÖÈ•∞ÁöÑÊôÆÈÄöÂáΩÊï∞‰ºöÂèòÊàêÊ≥õÂáΩÊï∞Ôºàgeneric functionÔºâÔºöÊ†πÊçÆÁ¨¨‰∏Ä‰∏™ÂèÇÊï∞ÁöÑÁ±ªÂûãÔºå‰ª•‰∏çÂêåÊñπÂºèÊâßË°åÁõ∏ÂêåÊìç‰ΩúÁöÑ‰∏ÄÁªÑÂáΩÊï∞„ÄÇ‰ª•‰∏ãÊòØfluent python‰∏≠ÂÖ≥‰∫ésingledispatchÁöÑÁ§∫‰æã„ÄÇ from functools import singledispatch from collections import abc import numbers import html @singledispatch # @singledispatch Ê†áËÆ∞Â§ÑÁêÜ object Á±ªÂûãÁöÑÂü∫ÂáΩÊï∞„ÄÇ def htmlize ( obj ): content = html . escape ( repr ( obj )) return '<pre> {} </pre>' . format ( content ) @htmlize . register ( str ) # ÂêÑ‰∏™‰∏ìÈó®ÂáΩÊï∞‰ΩøÁî® @¬´base_function¬ª.register(¬´type¬ª) Ë£ÖÈ•∞„ÄÇ def _ ( text ): # ‰∏ìÈó®ÂáΩÊï∞ÁöÑÂêçÁß∞Êó†ÂÖ≥Á¥ßË¶ÅÔºõ_ ÊòØ‰∏™‰∏çÈîôÁöÑÈÄâÊã©ÔºåÁÆÄÂçïÊòé‰∫Ü„ÄÇ content = html . escape ( text ) . replace ( ' \\n ' , '<br> \\n ' ) return '<p> {0} </p>' . format ( content ) @htmlize . register ( numbers . Integral ) # ‰∏∫ÊØè‰∏™ÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜÁöÑÁ±ªÂûãÊ≥®ÂÜå‰∏Ä‰∏™ÂáΩÊï∞„ÄÇnumbers.Integral ÊòØ int ÁöÑËôöÊãüË∂ÖÁ±ª„ÄÇ def _ ( n ): return '<pre> {0} (0x {0:x} )</pre>' . format ( n ) @htmlize . register ( tuple ) # ÂèØ‰ª•Âè†ÊîæÂ§ö‰∏™ register Ë£ÖÈ•∞Âô®ÔºåËÆ©Âêå‰∏Ä‰∏™ÂáΩÊï∞ÊîØÊåÅ‰∏çÂêåÁ±ªÂûã„ÄÇ @htmlize . register ( abc . MutableSequence ) def _ ( seq ): inner = '</li> \\n <li>' . join ( htmlize ( item ) for item in seq ) return '<ul> \\n <li>' + inner + '</li> \\n </ul>' singledispatch Êú∫Âà∂ÁöÑ‰∏Ä‰∏™ÊòæËëóÁâπÂæÅÊòØÔºå‰Ω†ÂèØ‰ª•Âú®Á≥ªÁªüÁöÑ‰ªª‰ΩïÂú∞ÊñπÂíå‰ªª‰ΩïÊ®°Âùó‰∏≠Ê≥®ÂÜå‰∏ìÈó®ÂáΩÊï∞„ÄÇÂ¶ÇÊûúÂêéÊù•Âú®Êñ∞ÁöÑÊ®°Âùó‰∏≠ÂÆö‰πâ‰∫ÜÊñ∞ÁöÑÁ±ªÂûãÔºåÂèØ‰ª•ËΩªÊùæÂú∞Ê∑ªÂä†‰∏Ä‰∏™Êñ∞ÁöÑ‰∏ìÈó®ÂáΩÊï∞Êù•Â§ÑÁêÜÈÇ£‰∏™Á±ªÂûã„ÄÇÊ≠§Â§ñÔºå‰Ω†ËøòÂèØ‰ª•‰∏∫‰∏çÊòØËá™Â∑±ÁºñÂÜôÁöÑÊàñËÄÖ‰∏çËÉΩ‰øÆÊîπÁöÑÁ±ªÊ∑ªÂä†Ëá™ÂÆö‰πâÂáΩÊï∞„ÄÇ Multidispatch ËøôÊòØ‰∏§‰∏™python cookbook‰∏≠Âà©Áî®annotationÂØπÂ§öÂèÇÊï∞ÊñπÊ≥ïÁöÑÈáçËΩΩÁöÑÁ§∫‰æã„ÄÇÂú®Á¨¨‰∏Ä‰∏™Á§∫‰æã‰∏≠Êàë‰ª¨Âà©Áî®ÂÖÉÁ±ªÊù•ÁîüÊàêÊîØÊåÅÂèÇÊï∞ÈáçËΩΩÁöÑÁ±ª„ÄÇÂú®__prepare__ÊñπÊ≥ï‰∏≠Â∞ÜÁ±ªÁöÑÂ≠óÂÖ∏ÂèòÊàêËá™ÂÆö‰πâÁöÑMultiDictÂ≠óÂÖ∏„ÄÇ ‰ΩøÁî®ÂÖÉÁ±ªÂÆûÁé∞ import inspect import types class MultiMethod : ''' Represents a single multimethod. ''' def __init__ ( self , name ): self . _methods = {} self . __name__ = name def register ( self , meth ): ''' Register a new method as a multimethod ''' sig = inspect . signature ( meth ) #Âà©Áî®inpsectÊ®°ÂùóÊù•Ëé∑ÂèñÂáΩÊï∞Á≠æÂêç # Build a type signature from the method's annotations types = [] for name , parm in sig . parameters . items (): if name == 'self' : continue if parm . annotation is inspect . Parameter . empty : raise TypeError ( 'Argument {} must be annotated with a type' . format ( name ) ) if not isinstance ( parm . annotation , type ): raise TypeError ( 'Argument {} annotation must be a type' . format ( name ) ) if parm . default is not inspect . Parameter . empty : self . _methods [ tuple ( types )] = meth types . append ( parm . annotation ) self . _methods [ tuple ( types )] = meth def __call__ ( self , * args ): ''' Call a method based on type signature of the arguments ''' types = tuple ( type ( arg ) for arg in args [ 1 :]) meth = self . _methods . get ( types , None ) if meth : return meth ( * args ) else : raise TypeError ( 'No matching method for types {} ' . format ( types )) def __get__ ( self , instance , cls ): ''' Descriptor method needed to make calls work in a class ''' if instance is not None : return types . MethodType ( self , instance ) else : return self class MultiDict ( dict ): ''' Special dictionary to build multimethods in a metaclass ''' def __setitem__ ( self , key , value ): if key in self : # If key already exists, it must be a multimethod or callable current_value = self [ key ] if isinstance ( current_value , MultiMethod ): current_value . register ( value ) else : mvalue = MultiMethod ( key ) #Ë£ÖÈ•∞Á¨¶Êù•ÊéßÂà∂mvalueË°å‰∏∫ mvalue . register ( current_value ) mvalue . register ( value ) super () . __setitem__ ( key , mvalue ) else : super () . __setitem__ ( key , value ) class MultipleMeta ( type ): ''' Metaclass that allows multiple dispatch of methods ''' def __new__ ( cls , clsname , bases , clsdict ): return type . __new__ ( cls , clsname , bases , dict ( clsdict )) @classmethod def __prepare__ ( cls , clsname , bases ): return MultiDict () ‰∏∫‰∫Ü‰ΩøÁî®Ëøô‰∏™Á±ªÔºå‰Ω†ÂèØ‰ª•ÂÉè‰∏ãÈù¢ËøôÊ†∑ÂÜôÔºö class Spam ( metaclass = MultipleMeta ): def bar ( self , x : int , y : int ): print ( 'Bar 1:' , x , y ) def bar ( self , s : str , n : int = 0 ): print ( 'Bar 2:' , s , n ) ### Example: overloaded __init__ import time class Date ( metaclass = MultipleMeta ): def __init__ ( self , year : int , month : int , day : int ): self . year = year self . month = month self . day = day def __init__ ( self ): t = time . localtime () self . __init__ ( t . tm_year , t . tm_mon , t . tm_mday ) ÊµãËØïÁªìÊûú >>> s = Spam () >>> s . bar ( 2 , 3 ) Bar 1 : 2 3 >>> s . bar ( 'hello' ) Bar 2 : hello 0 >>> s . bar ( 'hello' , 5 ) Bar 2 : hello 5 >>> s . bar ( 2 , 'hello' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"multiple.py\" , line 42 , in __call__ raise TypeError ( 'No matching method for types {} ' . format ( types )) TypeError : No matching method for types ( < class ' int '>, <class ' str '>) >>> # Overloaded __init__ >>> d = Date ( 2012 , 12 , 21 ) >>> # Get today's date >>> e = Date () >>> e . year 2012 >>> e . month 12 >>> e . day 3 Ë£ÖÈ•∞Âô®ÂÆûÁé∞ ‰Ωú‰∏∫‰ΩøÁî®ÂÖÉÁ±ªÂíåÊ≥®Ëß£ÁöÑ‰∏ÄÁßçÊõø‰ª£ÊñπÊ°àÔºåÂèØ‰ª•ÈÄöËøáÊèèËø∞Âô®Êù•ÂÆûÁé∞Á±ª‰ººÁöÑÊïàÊûú„ÄÇ import types class multimethod : def __init__ ( self , func ): self . _methods = {} self . __name__ = func . __name__ self . _default = func def match ( self , * types ): def register ( func ): ndefaults = len ( func . __defaults__ ) if func . __defaults__ else 0 for n in range ( ndefaults + 1 ): self . _methods [ types [: len ( types ) - n ]] = func return self return register def __call__ ( self , * args ): types = tuple ( type ( arg ) for arg in args [ 1 :]) meth = self . _methods . get ( types , None ) if meth : return meth ( * args ) else : return self . _default ( * args ) def __get__ ( self , instance , cls ): if instance is not None : return types . MethodType ( self , instance ) else : return self ‰∏∫‰∫Ü‰ΩøÁî®ÊèèËø∞Âô®ÁâàÊú¨Ôºå‰Ω†ÈúÄË¶ÅÂÉè‰∏ãÈù¢ËøôÊ†∑ÂÜôÔºö class Spam : @multimethod def bar ( self , * args ): # Default method called if no match raise TypeError ( 'No matching method for bar' ) @bar . match ( int , int ) def bar ( self , x , y ): print ( 'Bar 1:' , x , y ) @bar . match ( str , int ) def bar ( self , s , n = 0 ): print ( 'Bar 2:' , s , n ) Áº∫Èô∑ Êú¨ËäÇÁöÑÂÆûÁé∞‰∏≠ÁöÑ‰∏ªË¶ÅÊÄùË∑ØÂÖ∂ÂÆûÊòØÂæàÁÆÄÂçïÁöÑ„ÄÇ MutipleMeta ÂÖÉÁ±ª‰ΩøÁî®ÂÆÉÁöÑ __prepare__() ÊñπÊ≥ï Êù•Êèê‰æõ‰∏Ä‰∏™‰Ωú‰∏∫ MultiDict ÂÆû‰æãÁöÑËá™ÂÆö‰πâÂ≠óÂÖ∏„ÄÇËøô‰∏™Ë∑üÊôÆÈÄöÂ≠óÂÖ∏‰∏ç‰∏ÄÊ†∑ÁöÑÊòØÔºå MultiDict ‰ºöÂú®ÂÖÉÁ¥†Ë¢´ËÆæÁΩÆÁöÑÊó∂ÂÄôÊ£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®ÔºåÂ¶ÇÊûúÂ≠òÂú®ÁöÑËØùÔºåÈáçÂ§çÁöÑÂÖÉÁ¥†‰ºöÂú® MultiMethod ÂÆû‰æã‰∏≠ÂêàÂπ∂„ÄÇ MultiMethod ÂÆû‰æãÈÄöËøáÊûÑÂª∫‰ªéÁ±ªÂûãÁ≠æÂêçÂà∞ÂáΩÊï∞ÁöÑÊò†Â∞ÑÊù•Êî∂ÈõÜÊñπÊ≥ï„ÄÇ Âú®Ëøô‰∏™ÊûÑÂª∫ËøáÁ®ã‰∏≠ÔºåÂáΩÊï∞Ê≥®Ëß£Ë¢´Áî®Êù•Êî∂ÈõÜËøô‰∫õÁ≠æÂêçÁÑ∂ÂêéÊûÑÂª∫Ëøô‰∏™Êò†Â∞Ñ„ÄÇ Ëøô‰∏™ËøáÁ®ãÂú® MultiMethod.register() ÊñπÊ≥ï‰∏≠ÂÆûÁé∞„ÄÇ ËøôÁßçÊò†Â∞ÑÁöÑ‰∏Ä‰∏™ÂÖ≥ÈîÆÁâπÁÇπÊòØÂØπ‰∫éÂ§ö‰∏™ÊñπÊ≥ïÔºåÊâÄÊúâÂèÇÊï∞Á±ªÂûãÈÉΩÂøÖÈ°ªË¶ÅÊåáÂÆöÔºåÂê¶ÂàôÂ∞±‰ºöÊä•Èîô„ÄÇ ‰∏∫‰∫ÜËÆ© MultiMethod ÂÆû‰æãÊ®°Êãü‰∏Ä‰∏™Ë∞ÉÁî®ÔºåÂÆÉÁöÑ call () ÊñπÊ≥ïË¢´ÂÆûÁé∞‰∫Ü„ÄÇ Ëøô‰∏™ÊñπÊ≥ï‰ªéÊâÄÊúâÊéíÈô§ self ÁöÑÂèÇÊï∞‰∏≠ÊûÑÂª∫‰∏Ä‰∏™Á±ªÂûãÂÖÉÁªÑÔºåÂú®ÂÜÖÈÉ®map‰∏≠Êü•ÊâæËøô‰∏™ÊñπÊ≥ïÔºå ÁÑ∂ÂêéË∞ÉÁî®Áõ∏Â∫îÁöÑÊñπÊ≥ï„ÄÇ‰∏∫‰∫ÜËÉΩËÆ© MultiMethod ÂÆû‰æãÂú®Á±ªÂÆö‰πâÊó∂Ê≠£Á°ÆÊìç‰ΩúÔºå get ()` ÊòØÂøÖÈ°ªÂæóÂÆûÁé∞ÁöÑ„ÄÇ ÂÆÉË¢´Áî®Êù•ÊûÑÂª∫Ê≠£Á°ÆÁöÑÁªëÂÆöÊñπÊ≥ï„ÄÇ ‰∏çËøáÊú¨ËäÇÁöÑÂÆûÁé∞ËøòÊúâ‰∏Ä‰∫õÈôêÂà∂ÔºåÂÖ∂‰∏≠‰∏Ä‰∏™ÊòØÂÆÉ‰∏çËÉΩ‰ΩøÁî®ÂÖ≥ÈîÆÂ≠óÂèÇÊï∞„ÄÇ ÂêåÊ†∑ÂØπ‰∫éÁªßÊâø‰πüÊòØÊúâÈôêÂà∂ÁöÑÔºå‰æãÂ¶ÇÔºåÁ±ª‰ºº‰∏ãÈù¢ËøôÁßç‰ª£Á†ÅÂ∞±‰∏çËÉΩÊ≠£Â∏∏Â∑•‰ΩúÔºö class A : pass class B ( A ): pass class C : pass class Spam ( metaclass = MultipleMeta ): def foo ( self , x : A ): print ( 'Foo 1:' , x ) def foo ( self , x : C ): print ( 'Foo 2:' , x ) ÂéüÂõ†ÊòØÂõ†‰∏∫ x:A Ê≥®Ëß£‰∏çËÉΩÊàêÂäüÂåπÈÖçÂ≠êÁ±ªÂÆû‰æãÔºàÊØîÂ¶ÇBÁöÑÂÆû‰æãÔºâÔºåÂ¶Ç‰∏ãÔºö >>> s = Spam () >>> a = A () >>> s . foo ( a ) Foo 1 : < __main__ . A object at 0x1006a5310 > >>> c = C () >>> s . foo ( c ) Foo 2 : < __main__ . C object at 0x1007a1910 > >>> b = B () >>> s . foo ( b ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"multiple.py\" , line 44 , in __call__ raise TypeError ( 'No matching method for types {} ' . format ( types )) TypeError : No matching method for types ( < class ' __main__ . B '>,) Additional","tags":"Python","title":"PythonicÁöÑÊ≥õÂáΩÊï∞"},{"url":"python-memoryview-and-annotation-ideas.html","text":"Description Memoryview (ÂÜÖÂ≠òËßÜÂõæ)ÊòØ‰∏Ä‰∏™ÂÜÖÁΩÆÁ±ªÔºåÂÆÉËÉΩËÆ©Áî®Êà∑Âú®‰∏çÂ§çÂà∂ÂÜÖÂÆπÁöÑÊÉÖÂÜµ‰∏ãÊìç‰ΩúÂêå‰∏Ä‰∏™Êï∞ÁªÑÁöÑ‰∏çÂêåÂàáÁâá„ÄÇmemoryview ÁöÑÊ¶ÇÂøµÂèóÂà∞‰∫Ü NumPy ÁöÑÂêØÂèëÔºàÂèÇËßÅ 2.9.3 ËäÇÔºâ„ÄÇTravis Oliphant ÊòØ NumPy ÁöÑ‰∏ªË¶Å‰ΩúËÄÖÔºå‰ªñÂú®ÂõûÁ≠î\" When should a memoryview be used?\" [link](http://stackoverflow.com/questions/4845418/when-should-a-memoryview-be-used/ÔºâËøô‰∏™ÈóÆÈ¢òÊó∂ÊòØËøôÊ†∑ËØ¥ÁöÑÔºö ÂÜÖÂ≠òËßÜÂõæÂÖ∂ÂÆûÊòØÊ≥õÂåñÂíåÂéªÊï∞Â≠¶ÂåñÁöÑ NumPy Êï∞ÁªÑ„ÄÇÂÆÉËÆ©‰Ω†Âú®‰∏çÈúÄË¶ÅÂ§çÂà∂ÂÜÖÂÆπÁöÑÂâçÊèê‰∏ãÔºåÂú®Êï∞ÊçÆÁªìÊûÑ‰πãÈó¥ÂÖ±‰∫´ÂÜÖÂ≠ò„ÄÇÂÖ∂‰∏≠Êï∞ÊçÆÁªìÊûÑÂèØ‰ª•ÊòØ‰ªª‰ΩïÂΩ¢ÂºèÔºåÊØîÂ¶Ç PIL ÂõæÁâá„ÄÅSQLite Êï∞ÊçÆÂ∫ìÂíå NumPy ÁöÑÊï∞ÁªÑÔºåÁ≠âÁ≠â„ÄÇËøô‰∏™ÂäüËÉΩÂú®Â§ÑÁêÜÂ§ßÂûãÊï∞ÊçÆÈõÜÂêàÁöÑÊó∂ÂÄôÈùûÂ∏∏ÈáçË¶Å„ÄÇ memoryview.cast ÁöÑÊ¶ÇÂøµË∑üÊï∞ÁªÑÊ®°ÂùóÁ±ª‰ººÔºåËÉΩÁî®‰∏çÂêåÁöÑÊñπÂºèËØªÂÜôÂêå‰∏ÄÂùóÂÜÖÂ≠òÊï∞ÊçÆÔºåËÄå‰∏îÂÜÖÂÆπÂ≠óËäÇ‰∏ç‰ºöÈöèÊÑèÁßªÂä®„ÄÇËøôÂê¨‰∏äÂéªÂèàË∑ü C ËØ≠Ë®Ä‰∏≠Á±ªÂûãËΩ¨Êç¢ÁöÑÊ¶ÇÂøµÂ∑Æ‰∏çÂ§ö„ÄÇmemoryview.cast ‰ºöÊääÂêå‰∏ÄÂùóÂÜÖÂ≠òÈáåÁöÑÂÜÖÂÆπÊâìÂåÖÊàê‰∏Ä‰∏™ÂÖ®Êñ∞ÁöÑ memoryview ÂØπË±°Áªô‰Ω†„ÄÇ Python 3 Êèê‰æõ‰∫Ü‰∏ÄÁßçÂè•Ê≥ïÔºåÁî®‰∫é‰∏∫ÂáΩÊï∞Â£∞Êòé‰∏≠ÁöÑÂèÇÊï∞ÂíåËøîÂõûÂÄºÈôÑÂä†ÂÖÉÊï∞ÊçÆ„ÄÇ ÂèÇËÄÉÊñáÁåÆ2 ‰∏≠ÊèèËø∞‰∫ÜpythonÂºïÂÖ•annotationsÁöÑ‰∏ÄÁßçËß£Èáä„ÄÇ Python ÂØπÊ≥®Ëß£ÊâÄÂÅöÁöÑÂîØ‰∏ÄÁöÑ‰∫ãÊÉÖÊòØÔºåÊääÂÆÉ‰ª¨Â≠òÂÇ®Âú®ÂáΩÊï∞ÁöÑ annotations Â±ûÊÄßÈáå„ÄÇ‰ªÖÊ≠§ËÄåÂ∑≤ÔºåPython ‰∏çÂÅöÊ£ÄÊü•„ÄÅ‰∏çÂÅöÂº∫Âà∂„ÄÅ‰∏çÂÅöÈ™åËØÅÔºå‰ªÄ‰πàÊìç‰ΩúÈÉΩ‰∏çÂÅö„ÄÇÊç¢Âè•ËØùËØ¥ÔºåÊ≥®Ëß£ÂØπ Python Ëß£ÈáäÂô®Ê≤°Êúâ‰ªª‰ΩïÊÑè‰πâ„ÄÇÊ≥®Ëß£Âè™ÊòØÂÖÉÊï∞ÊçÆÔºåÂèØ‰ª•‰æõ IDE„ÄÅÊ°ÜÊû∂ÂíåË£ÖÈ•∞Âô®Á≠âÂ∑•ÂÖ∑‰ΩøÁî®„ÄÇÂç≥‰æøÊ≤°ÊúâÂº∫Âà∂ËØ≠‰πâÔºåÊàë‰ª¨‰æùÁÑ∂ÂèØ‰ª•Âà©Áî®Ê≥®Ëß£Êù•ËßÑËåÉÂáΩÊï∞ËæìÂÖ•„ÄÇ ‰ΩøÁî®MemoryviewÂØºÂÖ•Êñá‰ª∂Â≠óÁ¨¶ÊµÅ Âú®ËøôÈáåÊàë‰ª¨ÊØîËæÉ‰∫Ü‰∏âÁßçËØªÂèñÂ≠óËäÇÊµÅÁöÑÊñπÂºè„ÄÇÂêé‰∏§ÁßçÊñπÊ≥ïËÉΩÂáèÂ∞ë‰∏ÄÊ¨°Êï∞ÊçÆÁöÑÊã∑Ë¥ùÔºå‰ΩÜ‰ª§‰∫∫ÊÉäËÆ∂ÁöÑÊòØÔºå‰ΩøÁî®memoryviewÂπ∂Ê≤°ÊúâÊèêÈ´òËØªÂèñÁ®ãÂ∫èÁöÑÊïàÁéáÂíåÈÄüÂ∫¶„ÄÇ Â¶ÇÊûúË¶ÅËøõË°åÊú¨Âú∞ÊµãËØïÁöÑËØùÔºåËØ∑Â∞ÜFILENAMEÊîπ‰∏∫‰Ω†Êú¨Âú∞ÁéØÂ¢É‰∏≠ÁöÑÂ§ßÊñá‰ª∂ÁöÑË∑ØÂæÑ„ÄÇ ‰ª£Á†ÅÔºö import os from time import time ### Â§ßÊñá‰ª∂Ë∑ØÂæÑ FILENAME = r 'C:\\Users\\chu060\\Downloads\\ubuntu-16.04.2-desktop-i386.iso' def test_load_file_copy (): \"\"\"‰ΩøÁî®ÊôÆÈÄöÁöÑËØªÂèñÂ≠óËäÇÊµÅÁöÑÊñπÂºèÔºåËØ•ÊñπÂºè‰ºöËøõË°å‰∏ÄÊ¨°Êã∑Ë¥ù\"\"\" f = open ( FILENAME , 'rb' ) buf = bytearray ( f . read ()) f . close () return buf [: 100 ] def test_load_file_mv (): \"\"\"memoryviewÊµãËØï\"\"\" f = open ( FILENAME , 'rb' ) buf = bytearray ( os . path . getsize ( FILENAME )) mv = memoryview ( buf ) f . readinto ( mv ) f . close () return buf [: 100 ] def test_load_file_ba (): \"\"\"Êó†memoryviewÔºå‰ΩøÁî®bytearray\"\"\" f = open ( FILENAME , 'rb' ) buf = bytearray ( os . path . getsize ( FILENAME )) f . readinto ( buf ) f . close () return buf [: 100 ] def load_tester ( func , n = 3 ): \"\"\"ËøõË°åÊµãËØïÂπ∂ËæìÂá∫ÁªìÊûú\"\"\" print ( '=' * 50 ) start = time () for i in range ( n ): result = func () if i == 0 : print ( result ) print ( 'try {test_times} times, {name} avg running time: {avg_time} ' . format ( test_times = n , name = func . __name__ , avg_time = str (( time () - start ) / n ))) ### Ëé∑ÂèñÊâÄÊúâÂæÖÊµãÂáΩÊï∞ test_funcs = [ globals ()[ name ] for name in globals () if name . startswith ( 'test' )] ### ËøõË°åÊµãËØï,Ê≠§Â§ÑÂèñÂçÅÊ¨°ÊµãËØïÁöÑÂπ≥ÂùáÂÄº for func in test_funcs : load_tester ( func , 10 ) source file ËøêË°åÁªìÊûú‰∏∫Ôºö ================================================== bytearray(b'3\\xed\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x9 0\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x903\\xed\\xfa\\x8e\\xd5\\xbc\\x 00|\\xfb\\xfcf1\\xdbf1\\xc9fSfQ\\x06W\\x8e\\xdd\\x8e\\xc5R\\xbe\\x00|\\xbf\\x00\\x06\\xb9\\x00\\x 01\\xf3\\xa5\\xeaK\\x06\\x00\\x00R\\xb4A\\xbb\\xaaU1\\xc90\\xf6\\xf9\\xcd\\x13r\\x16\\x81\\xfbU\\x aau\\x10\\x83\\xe1\\x01t') try 10 times, test_load_file_ba avg running time: 0.9056999921798706 ================================================== bytearray(b'3\\xed\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x9 0\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x903\\xed\\xfa\\x8e\\xd5\\xbc\\x 00|\\xfb\\xfcf1\\xdbf1\\xc9fSfQ\\x06W\\x8e\\xdd\\x8e\\xc5R\\xbe\\x00|\\xbf\\x00\\x06\\xb9\\x00\\x 01\\xf3\\xa5\\xeaK\\x06\\x00\\x00R\\xb4A\\xbb\\xaaU1\\xc90\\xf6\\xf9\\xcd\\x13r\\x16\\x81\\xfbU\\x aau\\x10\\x83\\xe1\\x01t') try 10 times, test_load_file_copy avg running time: 1.3784000158309937 ================================================== bytearray(b'3\\xed\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x9 0\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x903\\xed\\xfa\\x8e\\xd5\\xbc\\x 00|\\xfb\\xfcf1\\xdbf1\\xc9fSfQ\\x06W\\x8e\\xdd\\x8e\\xc5R\\xbe\\x00|\\xbf\\x00\\x06\\xb9\\x00\\x 01\\xf3\\xa5\\xeaK\\x06\\x00\\x00R\\xb4A\\xbb\\xaaU1\\xc90\\xf6\\xf9\\xcd\\x13r\\x16\\x81\\xfbU\\x aau\\x10\\x83\\xe1\\x01t') try 10 times, test_load_file_mv avg running time: 0.9180000066757202 ‰ΩøÁî®annotationsËøõË°åÂèÇÊï∞Ê£ÄÊü• Êàë‰ª¨ÂèØ‰ª•ÁÆÄÂçïÂ∞Üannotations(Ê≥®Ëß£)ÂΩìÊàêÂáΩÊï∞ÂèÇÊï∞ËØ¥ÊòéÊñáÊ°£„ÄÇÊ≥®Ëß£‰ºöË¢´ÂÇ®Â≠òÂú®ÂáΩÊï∞ÁöÑ__annotations__Â±ûÊÄß‰∏≠ÔºåÂõ†Ê≠§Êàë‰ª¨‰πüÂèØ‰ª•Âà©Áî®Ëøô‰∏™Â≠óÂÖ∏Êù•ÂÅöÊõ¥Â§öÁöÑ‰∫ãÊÉÖÔºöÊØîÂ¶ÇÂèÇÊï∞Á±ªÂûã„ÄÅÊúâÊïàÊÄßÁöÑÊ£ÄÈ™å„ÄÇ ‰ª£Á†ÅÔºö def validate ( func , locals ): for var , test in func . __annotations__ . items (): value = locals [ var ] msg = 'Var: {0} \\t Value: {1} \\t Test: {2.__name__} ' . format ( var , value , test ) assert test ( value ), msg def is_int ( x ): return isinstance ( x , int ) def between ( lo , hi ): def _between ( x ): return lo <= x <= hi return _between def f ( x : between ( 3 , 10 ), y : is_int ): validate ( f , locals ()) print ( x , y ) ÁªìÊûúÔºö >>> f(0, 31.1) Traceback (most recent call last): ... AssertionError: Var: y Value: 31.1 Test: is_int Additional ÂèÇËÄÉÊñáÁåÆ: 1. Less Copies in Python with the Buffer Protocol and memoryviews 2. Memoryview Q&A","tags":"Python","title":"Python Memoryview and Annotation Ideas"},{"url":"python-descriptor-behavior.html","text":"Description ÊèèËø∞Á¨¶ÊòØÂØπÂ§ö‰∏™Â±ûÊÄßËøêÁî®Áõ∏ÂêåÂ≠òÂèñÈÄªËæëÁöÑ‰∏ÄÁßçÊñπÂºè„ÄÇ‰æãÂ¶ÇÔºåDjango ORM Âíå SQL Alchemy Á≠â ORM ‰∏≠ÁöÑÂ≠óÊÆµÁ±ªÂûãÊòØÊèèËø∞Á¨¶ÔºåÊääÊï∞ÊçÆÂ∫ìËÆ∞ÂΩï‰∏≠Â≠óÊÆµÈáåÁöÑÊï∞ÊçÆ‰∏é Python ÂØπË±°ÁöÑÂ±ûÊÄßÂØπÂ∫îËµ∑Êù•„ÄÇ ÊèèËø∞Á¨¶ÊòØÂÆûÁé∞‰∫ÜÁâπÂÆöÂçèËÆÆÁöÑÁ±ªÔºåËøô‰∏™ÂçèËÆÆÂåÖÊã¨ get „ÄÅ set Âíå delete ÊñπÊ≥ï„ÄÇproperty Á±ªÂÆûÁé∞‰∫ÜÂÆåÊï¥ÁöÑÊèèËø∞Á¨¶ÂçèËÆÆ„ÄÇÈÄöÂ∏∏ÔºåÂèØ‰ª•Âè™ÂÆûÁé∞ÈÉ®ÂàÜÂçèËÆÆ„ÄÇÂÖ∂ÂÆûÔºåÊàë‰ª¨Âú®ÁúüÂÆûÁöÑ‰ª£Á†Å‰∏≠ËßÅÂà∞ÁöÑÂ§ßÂ§öÊï∞ÊèèËø∞Á¨¶Âè™ÂÆûÁé∞‰∫Ü get Âíå set ÊñπÊ≥ïÔºåËøòÊúâÂæàÂ§öÂè™ÂÆûÁé∞‰∫ÜÂÖ∂‰∏≠ÁöÑ‰∏Ä‰∏™„ÄÇ ÊèèËø∞Á¨¶ÊòØ Python ÁöÑÁã¨ÊúâÁâπÂæÅÔºå‰∏ç‰ªÖÂú®Â∫îÁî®Â±Ç‰∏≠‰ΩøÁî®ÔºåÂú®ËØ≠Ë®ÄÁöÑÂü∫Á°ÄËÆæÊñΩ‰∏≠‰πüÊúâÁî®Âà∞„ÄÇÈô§‰∫ÜÁâπÊÄß‰πãÂ§ñÔºå‰ΩøÁî®ÊèèËø∞Á¨¶ÁöÑ Python ÂäüËÉΩËøòÊúâÊñπÊ≥ïÂèä classmethod Âíå staticmethod Ë£ÖÈ•∞Âô®„ÄÇÁêÜËß£ÊèèËø∞Á¨¶ÊòØÁ≤æÈÄö Python ÁöÑÂÖ≥ÈîÆ„ÄÇ Êú¨ÊñáÂú®ÁÆÄË¶Å‰ªãÁªçÊèèËø∞Á¨¶ÁöÑÂü∫Á°Ä‰∏äÊé¢ËÆ®ÊèèËø∞Á¨¶Âú®python‰∏≠ÁöÑÊòæÈöêÊÄß„ÄÇ ÊèèËø∞Á¨¶ÁßçÁ±ª Âú®Ê≠£ÂºèÊé¢ËÆ®ÊèèËø∞Á¨¶Âú®python‰∏≠ÁöÑÊòæÈöêÊÄßÂâçÔºåÂÖà‰∫ÜËß£‰∏ã‰∏âÁßçÊèèËø∞Á¨¶„ÄÇ Ë¶ÜÁõñÂûãÊèèËø∞Á¨¶ ÂÆûÁé∞ set ÊñπÊ≥ïÁöÑÊèèËø∞Á¨¶Â±û‰∫éË¶ÜÁõñÂûãÊèèËø∞Á¨¶ÔºåÂõ†‰∏∫ËôΩÁÑ∂ÊèèËø∞Á¨¶ÊòØÁ±ªÂ±ûÊÄßÔºå‰ΩÜÊòØÂÆûÁé∞ set ÊñπÊ≥ïÁöÑËØùÔºå‰ºöË¶ÜÁõñÂØπÂÆû‰æãÂ±ûÊÄßÁöÑËµãÂÄºÊìç‰Ωú„ÄÇ Ê≤°Êúâ get ÊñπÊ≥ïÁöÑË¶ÜÁõñÂûãÊèèËø∞Á¨¶ ÈÄöÂ∏∏ÔºåË¶ÜÁõñÂûãÊèèËø∞Á¨¶Êó¢‰ºöÂÆûÁé∞ set ÊñπÊ≥ïÔºå‰πü‰ºöÂÆûÁé∞ get ÊñπÊ≥ïÔºå‰∏çËøá‰πüÂèØ‰ª•Âè™ÂÆûÁé∞ set ÊñπÊ≥ïÔºåÊ≠§Êó∂ÔºåÂè™ÊúâÂÜôÊìç‰ΩúÁî±ÊèèËø∞Á¨¶Â§ÑÁêÜ„ÄÇÈÄöËøáÂÆû‰æãËØªÂèñÊèèËø∞Á¨¶‰ºöËøîÂõûÊèèËø∞Á¨¶ÂØπË±°Êú¨Ë∫´ÔºåÂõ†‰∏∫Ê≤°ÊúâÂ§ÑÁêÜËØªÊìç‰ΩúÁöÑ get ÊñπÊ≥ï„ÄÇÂ¶ÇÊûúÁõ¥Êé•ÈÄöËøáÂÆû‰æãÁöÑ dict Â±ûÊÄßÂàõÂª∫ÂêåÂêçÂÆû‰æãÂ±ûÊÄßÔºå‰ª•ÂêéÂÜçËÆæÁΩÆÈÇ£‰∏™Â±ûÊÄßÊó∂Ôºå‰ªç‰ºöÁî± set ÊñπÊ≥ïÊèíÊâãÊé•ÁÆ°Ôºå‰ΩÜÊòØËØªÂèñÈÇ£‰∏™Â±ûÊÄßÁöÑËØùÔºåÂ∞±‰ºöÁõ¥Êé•‰ªéÂÆû‰æã‰∏≠ËøîÂõûÊñ∞Ëµã‰∫àÁöÑÂÄºÔºåËÄå‰∏ç‰ºöËøîÂõûÊèèËø∞Á¨¶ÂØπË±°„ÄÇ‰πüÂ∞±ÊòØËØ¥ÔºåÂÆû‰æãÂ±ûÊÄß‰ºöÈÅÆÁõñÊèèËø∞Á¨¶Ôºå‰∏çËøáÂè™ÊúâËØªÊìç‰ΩúÊòØÂ¶ÇÊ≠§„ÄÇ ÈùûË¶ÜÁõñÂûãÊèèËø∞Á¨¶ Ê≤°ÊúâÂÆûÁé∞ set ÊñπÊ≥ïÁöÑÊèèËø∞Á¨¶ÊòØÈùûË¶ÜÁõñÂûãÊèèËø∞Á¨¶„ÄÇÂ¶ÇÊûúËÆæÁΩÆ‰∫ÜÂêåÂêçÁöÑÂÆû‰æãÂ±ûÊÄßÔºåÊèèËø∞Á¨¶‰ºöË¢´ÈÅÆÁõñÔºåËá¥‰ΩøÊèèËø∞Á¨¶Êó†Ê≥ïÂ§ÑÁêÜÈÇ£‰∏™ÂÆû‰æãÁöÑÈÇ£‰∏™Â±ûÊÄß„ÄÇÊñπÊ≥ïÊòØ‰ª•ÈùûË¶ÜÁõñÂûãÊèèËø∞Á¨¶ÂÆûÁé∞ÁöÑ„ÄÇ PythonÂ±ûÊÄßÊü•ÊâæÁ≠ñÁï• ‰ºòÂÖàÊâæÂà∞PythonËá™Âä®‰∫ßÁîüÁöÑÂ±ûÊÄß„ÄÇ Êü•Êâæobj. class . dict ÔºåÂ¶ÇÊûúattrÂ≠òÂú®Âπ∂‰∏îÊòØË¶ÜÁõñÂûãÊèèËø∞Á¨¶ÔºåËøîÂõûË¶ÜÁõñÂûãÊèèËø∞Á¨¶ÁöÑ__get__ÊñπÊ≥ïÁöÑÁªìÊûúÔºåÂ¶ÇÊûúÊ≤°ÊúâÁªßÁª≠Âú®obj. class ÁöÑÁà∂Á±ª‰ª•ÂèäÁ•ñÂÖàÁ±ª‰∏≠ÂØªÊâæË¶ÜÁõñÂûãÊèèËø∞Á¨¶„ÄÇ Âú®obj. dict ‰∏≠Êü•ÊâæÔºåËøô‰∏ÄÊ≠•ÂàÜ‰∏§ÁßçÊÉÖÂÜµÔºåÁ¨¨‰∏ÄÁßçÊÉÖÂÜµÊòØobjÊòØ‰∏Ä‰∏™ÊôÆÈÄöÂÆû‰æãÔºåÊâæÂà∞Â∞±Áõ¥Êé•ËøîÂõûÔºåÊâæ‰∏çÂà∞ËøõË°å‰∏ã‰∏ÄÊ≠•„ÄÇÁ¨¨‰∫åÁßçÊÉÖÂÜµÊòØobjÊòØ‰∏Ä‰∏™Á±ªÔºå‰æùÊ¨°Âú®objÂíåÂÆÉÁöÑÁà∂Á±ª„ÄÅÁ•ñÂÖàÁ±ªÁöÑ__dict__‰∏≠Êü•ÊâæÔºåÂ¶ÇÊûúÊâæÂà∞‰∏Ä‰∏™ÊèèËø∞Á¨¶Â∞±ËøîÂõûÊèèËø∞Á¨¶ÁöÑ__get__ÊñπÊ≥ïÁöÑÁªìÊûúÔºåÂê¶ÂàôÁõ¥Êé•ËøîÂõûattr„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÔºåËøõË°å‰∏ã‰∏ÄÊ≠•„ÄÇ Âú®obj. class . dict ‰∏≠Êü•ÊâæÔºåÂ¶ÇÊûúÊâæÂà∞‰∫Ü‰∏Ä‰∏™ÊèèËø∞Á¨¶(ËøôÈáåÁöÑÊèèËø∞Á¨¶‰∏ÄÂÆöÊòØÈùûË¶ÜÁõñÂûãÊèèËø∞Á¨¶)ÔºåËøîÂõûÊèèËø∞Á¨¶ÁöÑ__get__ÊñπÊ≥ïÁöÑÁªìÊûú„ÄÇÂ¶ÇÊûúÊâæÂà∞‰∏Ä‰∏™ÊôÆÈÄöÂ±ûÊÄßÔºåÁõ¥Êé•ËøîÂõûÂ±ûÊÄßÂÄº„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÁªßÁª≠Âú®obj. class ÁöÑÁà∂Á±ª‰ª•ÂèäÁ•ñÂÖàÁ±ª‰∏≠ÂØªÊâæÈùûË¶ÜÁõñÂûãÊèèËø∞Á¨¶„ÄÇ Âæà‰∏çÂπ∏ÔºåPythonÁªà‰∫éÂèó‰∏ç‰∫Ü„ÄÇÂú®Ëøô‰∏ÄÊ≠•ÔºåÂÆÉraise AttributeError „ÄÇ ‰ª£Á†ÅÈ™åËØÅ Êé•‰∏ãÊù•Êàë‰ª¨ÁºñÂÜôÁ§∫‰æã‰ª£Á†ÅÊù•ÂØπ‰ª•‰∏äÁ≠ñÁï•ËøõË°åÈ™åËØÅ„ÄÇ \"\"\" Ë¶ÜÁõñÂûãÊèèËø∞Á¨¶: >>> obj = Model() >>> obj.__dict__['over'] = 'obj instance property over' >>> obj.over # doctest: +ELLIPSIS Overriding.__get__() invoked with args: self = <descriptorkinds.Overriding object at 0x...> instance = <descriptorkinds.Model object at 0x...> owner = <class 'descriptorkinds.Model'> >>> Model.over # doctest: +ELLIPSIS Overriding.__get__() invoked with args: self = <descriptorkinds.Overriding object at 0x...> instance = None owner = <class 'descriptorkinds.Model'> >>> sub_obj = SubClass() >>> sub_obj.__dict__['over'] = 'sub_obj instance property over' >>> sub_obj.over # doctest: +ELLIPSIS Overriding.__get__() invoked with args: self = <descriptorkinds.Overriding object at 0x...> instance = <descriptorkinds.SubClass object at 0x...> owner = <class 'descriptorkinds.SubClass'> >>> SubClass.over # doctest: +ELLIPSIS Overriding.__get__() invoked with args: self = <descriptorkinds.Overriding object at 0x...> instance = None owner = <class 'descriptorkinds.SubClass'> #Ë°å‰∏∫ÂÆåÂÖ®Á¨¶ÂêàÁ≠ñÁï•2„ÄÇÈ¢ùÂ§ñÁöÑÔºåËøôÈáåÊµãËØï‰∫ÜËé∑ÂèñÁ±ªÂ±ûÊÄßÊó∂‰º†ÂÖ•ÂèÇÊï∞ÁöÑÂÄº„ÄÇ Ê≤°Êúâ __get__ ÊñπÊ≥ïÁöÑË¶ÜÁõñÂûãÊèèËø∞Á¨¶: >>> obj.__dict__['over_no_get'] = 'obj instance property over_no_get' >>> obj.over_no_get # doctest: +ELLIPSIS 'obj instance property over_no_get' >>> sub_obj.over_no_get # doctest: +ELLIPSIS <descriptorkinds.OverridingNoGet object at 0x...> >>> sub_obj.__dict__['over_no_get'] = 'sub_obj instance property over_no_get' >>> sub_obj.over_no_get # doctest: +ELLIPSIS 'sub_obj instance property over_no_get' #Ë°å‰∏∫Á¨¶ÂêàÁ≠ñÁï•4„ÄÇÂÖ∂Ë°å‰∏∫Êõ¥ÂÉèÈùûË¶ÜÁõñÂûãÊèèËø∞Á¨¶„ÄÇ‰ΩÜÊó†Ê≥ïÁõ¥Êé•‰ΩøÁî®obj.over_no_getÁöÑÊñπÂºèÁªôÂÆû‰æãÂ±ûÊÄßËµãÂÄº„ÄÇ ÈùûË¶ÜÁõñÂûãÊèèËø∞Á¨¶Ôºö >>> obj.non_over # doctest: +ELLIPSIS NonOverriding.__get__() invoked with args: self = <descriptorkinds.NonOverriding object at 0x...> instance = <descriptorkinds.Model object at 0x...> owner = <class 'descriptorkinds.Model'> >>> obj.non_over = 'obj instance property non_over' >>> obj.non_over # doctest: +ELLIPSIS 'obj instance property non_over' >>> sub_obj.non_over # doctest: +ELLIPSIS NonOverriding.__get__() invoked with args: self = <descriptorkinds.NonOverriding object at 0x...> instance = <descriptorkinds.SubClass object at 0x...> owner = <class 'descriptorkinds.SubClass'> >>> sub_obj.__dict__['non_over'] = 'sub_obj instance property non_over' >>> sub_obj.non_over # doctest: +ELLIPSIS 'sub_obj instance property non_over' #Ë°å‰∏∫Á¨¶ÂêàÁ≠ñÁï•4„ÄÇ \"\"\" ### BEGIN DESCRIPTORKINDS def print_args ( name , * args ): # <1> cls_name = args [ 0 ] . __class__ . __name__ arg_names = [ 'self' , 'instance' , 'owner' ] if name == 'set' : arg_names [ - 1 ] = 'value' print ( ' {} .__ {} __() invoked with args:' . format ( cls_name , name )) for arg_name , value in zip ( arg_names , args ): print ( ' {:8} = {} ' . format ( arg_name , value )) class Overriding : # <2> \"\"\"a.k.a. data descriptor or enforced descriptor\"\"\" def __get__ ( self , instance , owner ): print_args ( 'get' , self , instance , owner ) # <3> def __set__ ( self , instance , value ): print_args ( 'set' , self , instance , value ) class OverridingNoGet : # <4> \"\"\"an overriding descriptor without ``__get__``\"\"\" def __set__ ( self , instance , value ): print_args ( 'set' , self , instance , value ) class NonOverriding : # <5> \"\"\"a.k.a. non-data or shadowable descriptor\"\"\" def __get__ ( self , instance , owner ): print_args ( 'get' , self , instance , owner ) class Model : # <6> over = Overriding () over_no_get = OverridingNoGet () non_over = NonOverriding () def spam ( self ): # <7> print ( 'Model.spam() invoked with arg:' ) print ( ' self =' , self ) class SubClass ( Model ): def spam ( self ): print ( 'SubClass.spam() invoked with arg:' ) print ( ' self =' , self ) Âè¶Â§ñÔºåÂú®Á±ª‰∏≠ÂÆö‰πâÁöÑÂáΩÊï∞Â±û‰∫éÁªëÂÆöÊñπÊ≥ïÔºàbound methodÔºâÔºåÂõ†‰∏∫Áî®Êà∑ÂÆö‰πâÁöÑÂáΩÊï∞ÈÉΩÊúâ get ÊñπÊ≥ïÔºåÊâÄ‰ª•‰æùÈôÑÂà∞Á±ª‰∏äÊó∂ÔºåÂ∞±Áõ∏ÂΩì‰∫éÊèèËø∞Á¨¶„ÄÇ \"\"\" ### BEGIN FUNC_DESCRIPTOR_DEMO >>> word = Text('forward') >>> word # <1> Text('forward') >>> word.reverse() # <2> Text('drawrof') >>> Text.reverse(Text('backward')) # <3> Text('drawkcab') >>> type(Text.reverse), type(word.reverse) # <4> (<class 'function'>, <class 'method'>) >>> list(map(Text.reverse, ['repaid', (10, 20, 30), Text('stressed')])) # <5> ['diaper', (30, 20, 10), Text('desserts')] >>> Text.reverse.__get__(word) # <6> <bound method Text.reverse of Text('forward')> >>> Text.reverse.__get__(None, Text) # <7> <function Text.reverse at 0x101244e18> >>> word.reverse # <8> <bound method Text.reverse of Text('forward')> >>> word.reverse.__self__ # <9> Text('forward') >>> word.reverse.__func__ is Text.reverse # <10> True ### END FUNC_DESCRIPTOR_DEMO \"\"\" ### BEGIN FUNC_DESCRIPTOR_EX import collections class Text ( collections . UserString ): def __repr__ ( self ): return 'Text( {!r} )' . format ( self . data ) def reverse ( self ): return self [:: - 1 ] ### END FUNC_DESCRIPTOR_EX ÊÄªÁªì ÊèèËø∞Á¨¶ÁöÑ‰ΩúÁî®ÊñπÂºèÂèØÁî®‰ª•‰∏ãÂáΩÊï∞Ë°®Á§∫Ôºö x = C () x . foo ==> if hasattr ( C , 'foo' ): d = C . foo ; D = d . __class__ if hasattr ( D , '__get__' ) and ( hasattr ( D , '__set__' ) or 'foo' not in x . __dict__ ): return D . __get__ ( d , x , C ) return x . __dict__ [ 'foo' ] # or from C, &c Additional ÊèèËø∞Á¨¶Áî®Ê≥ïÂª∫ËÆÆÔºö 1.‰ΩøÁî®ÁâπÊÄß‰ª•‰øùÊåÅÁÆÄÂçï ÂÜÖÁΩÆÁöÑ property Á±ªÂàõÂª∫ÁöÑÂÖ∂ÂÆûÊòØË¶ÜÁõñÂûãÊèèËø∞Á¨¶Ôºå set ÊñπÊ≥ïÂíå get ÊñπÊ≥ïÈÉΩÂÆûÁé∞‰∫ÜÔºåÂç≥‰æø‰∏çÂÆö‰πâËÆæÂÄºÊñπÊ≥ï‰πüÊòØÂ¶ÇÊ≠§„ÄÇÁâπÊÄßÁöÑ set ÊñπÊ≥ïÈªòËÆ§ÊäõÂá∫ AttributeError: can't set attributeÔºåÂõ†Ê≠§ÂàõÂª∫Âè™ËØªÂ±ûÊÄßÊúÄÁÆÄÂçïÁöÑÊñπÂºèÊòØ‰ΩøÁî®ÁâπÊÄßÔºåËøôËÉΩÈÅøÂÖç‰∏ã‰∏ÄÊù°ÊâÄËø∞ÁöÑÈóÆÈ¢ò„ÄÇ 2.Âè™ËØªÊèèËø∞Á¨¶ÂøÖÈ°ªÊúâ set ÊñπÊ≥ï Â¶ÇÊûú‰ΩøÁî®ÊèèËø∞Á¨¶Á±ªÂÆûÁé∞Âè™ËØªÂ±ûÊÄßÔºåË¶ÅËÆ∞‰ΩèÔºå get Âíå set ‰∏§‰∏™ÊñπÊ≥ïÂøÖÈ°ªÈÉΩÂÆö‰πâÔºåÂê¶ÂàôÔºåÂÆû‰æãÁöÑÂêåÂêçÂ±ûÊÄß‰ºöÈÅÆÁõñÊèèËø∞Á¨¶„ÄÇÂè™ËØªÂ±ûÊÄßÁöÑ set ÊñπÊ≥ïÂè™ÈúÄÊäõÂá∫ AttributeError ÂºÇÂ∏∏ÔºåÂπ∂Êèê‰æõÂêàÈÄÇÁöÑÈîôËØØÊ∂àÊÅØ„ÄÇ 3.Áî®‰∫éÈ™åËØÅÁöÑÊèèËø∞Á¨¶ÂèØ‰ª•Âè™Êúâ set ÊñπÊ≥ï ÂØπ‰ªÖÁî®‰∫éÈ™åËØÅÁöÑÊèèËø∞Á¨¶Êù•ËØ¥Ôºå set ÊñπÊ≥ïÂ∫îËØ•Ê£ÄÊü• value ÂèÇÊï∞Ëé∑ÂæóÁöÑÂÄºÔºåÂ¶ÇÊûúÊúâÊïàÔºå‰ΩøÁî®ÊèèËø∞Á¨¶ÂÆû‰æãÁöÑÂêçÁß∞‰∏∫ÈîÆÔºåÁõ¥Êé•Âú®ÂÆû‰æãÁöÑ dict Â±ûÊÄß‰∏≠ËÆæÁΩÆ„ÄÇËøôÊ†∑Ôºå‰ªéÂÆû‰æã‰∏≠ËØªÂèñÂêåÂêçÂ±ûÊÄßÁöÑÈÄüÂ∫¶ÂæàÂø´ÔºåÂõ†‰∏∫‰∏çÁî®ÁªèËøá get ÊñπÊ≥ïÂ§ÑÁêÜ„ÄÇ 4 ‰ªÖÊúâ get ÊñπÊ≥ïÁöÑÊèèËø∞Á¨¶ÂèØ‰ª•ÂÆûÁé∞È´òÊïàÁºìÂ≠ò Â¶ÇÊûúÂè™ÁºñÂÜô‰∫Ü get ÊñπÊ≥ïÔºåÈÇ£‰πàÂàõÂª∫ÁöÑÊòØÈùûË¶ÜÁõñÂûãÊèèËø∞Á¨¶„ÄÇËøôÁßçÊèèËø∞Á¨¶ÂèØÁî®‰∫éÊâßË°åÊüê‰∫õËÄóË¥πËµÑÊ∫êÁöÑËÆ°ÁÆóÔºåÁÑ∂Âêé‰∏∫ÂÆû‰æãËÆæÁΩÆÂêåÂêçÂ±ûÊÄßÔºåÁºìÂ≠òÁªìÊûú„ÄÇÂêåÂêçÂÆû‰æãÂ±ûÊÄß‰ºöÈÅÆÁõñÊèèËø∞Á¨¶ÔºåÂõ†Ê≠§ÂêéÁª≠ËÆøÈóÆ‰ºöÁõ¥Êé•‰ªéÂÆû‰æãÁöÑ dict Â±ûÊÄß‰∏≠Ëé∑ÂèñÂÄºÔºåËÄå‰∏ç‰ºöÂÜçËß¶ÂèëÊèèËø∞Á¨¶ÁöÑ get ÊñπÊ≥ï„ÄÇ 5.ÈùûÁâπÊÆäÁöÑÊñπÊ≥ïÂèØ‰ª•Ë¢´ÂÆû‰æãÂ±ûÊÄßÈÅÆÁõñ Áî±‰∫éÂáΩÊï∞ÂíåÊñπÊ≥ïÂè™ÂÆûÁé∞‰∫Ü get ÊñπÊ≥ïÔºåÂÆÉ‰ª¨‰∏ç‰ºöÂ§ÑÁêÜÂêåÂêçÂÆû‰æãÂ±ûÊÄßÁöÑËµãÂÄºÊìç‰Ωú„ÄÇÂõ†Ê≠§ÔºåÂÉè my_obj.the_method = 7 ËøôÊ†∑ÁÆÄÂçïËµãÂÄº‰πãÂêéÔºåÂêéÁª≠ÈÄöËøáËØ•ÂÆû‰æãËÆøÈóÆ the_method ÂæóÂà∞ÁöÑÊòØÊï∞Â≠ó 7‚Äî‚Äî‰ΩÜÊòØ‰∏çÂΩ±ÂìçÁ±ªÊàñÂÖ∂‰ªñÂÆû‰æã„ÄÇÁÑ∂ËÄåÔºåÁâπÊÆäÊñπÊ≥ï‰∏çÂèóËøô‰∏™ÈóÆÈ¢òÁöÑÂΩ±Âìç„ÄÇËß£ÈáäÂô®Âè™‰ºöÂú®Á±ª‰∏≠ÂØªÊâæÁâπÊÆäÁöÑÊñπÊ≥ïÔºå‰πüÂ∞±ÊòØËØ¥Ôºårepr(x) ÊâßË°åÁöÑÂÖ∂ÂÆûÊòØ x. class . repr (x)ÔºåÂõ†Ê≠§ x ÁöÑ repr Â±ûÊÄßÂØπ repr(x) ÊñπÊ≥ïË∞ÉÁî®Ê≤°ÊúâÂΩ±Âìç„ÄÇÂá∫‰∫éÂêåÊ†∑ÁöÑÂéüÂõ†ÔºåÂÆû‰æãÁöÑ getattr Â±ûÊÄß‰∏ç‰ºöÁ†¥ÂùèÂ∏∏ËßÑÁöÑÂ±ûÊÄßËÆøÈóÆËßÑÂàô„ÄÇ","tags":"Python","title":"Python Descriptor Behavior"},{"url":"python-coroutine-example-rock-paper-scissors.html","text":"Description Êú¨‰ª£Á†ÅÊù•Ëá™Ian WardÁöÑJupyter Notebook -- \"Iterables, Iterators, and Generators\" ÊïôÁ®ãÔºåÂÆûÁé∞‰∫ÜÂâ™ÂàÄÁü≥Â§¥Â∏ÉÁöÑÊ∏∏Êàè„ÄÇ È¢ÑÊøÄÂçèÁ®ã The flow is always the same when working with generators. a generator object is created by the caller the caller starts the generator the generator passes data to the caller (or signals the end of the sequence) the caller passes data to the generator repeat from (3) For generators that are driven by input to .send() no data is transferred in the first 3 steps above. This is a decorator that arranges for .next() to be called once immediately after a generator is created. This will turn a generator function into a function that returns a generator immediately ready to receive data (step 4). def advance_generator_once ( original_fn ): \"decorator to advance a generator once immediately after it is created\" def actual_call ( * args , ** kwargs ): gen = original_fn ( * args , ** kwargs ) assert gen . next () is None return gen return actual_call ÂÆû‰æãÂçèÁ®ã As shown, one of the ways to pass a message to a generator is with .send(). This interface allows you to pass a single object to a generator. For this object we can pass tuples, dicts or anything else we choose. You decide the protocol for your generator by documenting the types and values of objects you will send from caller to generator and yield from generator to caller. Tuples are perfect for a generator that needs two objects each time, e.g. a player number and a key press. This is a Rock-Paper-Scissors game where each player's play is passed in separately, and once both players have played the result of the game is yielded. Players can change their mind choose a different play if the other player hasn't chosen yet. Games will continue indefinitately. This generator uses a common pattern of storing the result that will be yielded in a local variable so that there are fewer yield statements in the generator function. Having fewer yield statements makes it easier to understand where it is possible for execution to be paused within the generator function. The outer while loop runs once for each full game. The inner while loop collects input from the users until the game result can be decided. @advance_generator_once def rock_paper_scissors (): \"\"\" coroutine for playing rock-paper-scissors yields: 'invalid key': invalid input was sent ('win', player, choice0, choice1): when a player wins ('tie', None, choice0, choice1): when there is a tie None: when waiting for more input accepts to .send(): (player, key): player is 0 or 1, key is a character in 'rps' \"\"\" valid = 'rps' wins = 'rs' , 'sp' , 'pr' result = None while True : chosen = [ None , None ] while None in chosen : player , play = yield result result = None if play in valid : chosen [ player ] = play else : result = 'invalid key' if chosen [ 0 ] + chosen [ 1 ] in wins : result = ( 'win' , 0 ) + tuple ( chosen ) elif chosen [ 1 ] + chosen [ 0 ] in wins : result = ( 'win' , 1 ) + tuple ( chosen ) else : result = ( 'tie' , None ) + tuple ( chosen ) Additional ÂèÇËÄÉÊñáÁåÆ: 1. Ê∫êÊïôÁ®ã","tags":"Python","title":"Python Coroutine Example -- Rock Paper Scissors"},{"url":"python-coroutine-example-game-of-life.html","text":"Description Êú¨ÊñáÊâÄÂàó‰ª£Á†ÅÂÆûÁé∞‰∫Ü John Conway ÂèëÊòéÁöÑ\"ÁîüÂëΩÊ∏∏Êàè\"Ôºàhttps://en.wikipedia.org/wiki/Conway%27s_Game_of_LifeÔºâÔºå‰ΩøÁî®ÂçèÁ®ãÁÆ°ÁêÜÊ∏∏ÊàèËøêË°åËøáÁ®ã‰∏≠ÂêÑ‰∏™ÁªÜËÉûÁöÑÁä∂ÊÄÅ„ÄÇ Ê∫êËá™Brett Slatkin ÂÜôÁöÑ„ÄäEffective PythonÔºöÁºñÂÜôÈ´òË¥®Èáè Python ‰ª£Á†ÅÁöÑ 59 ‰∏™ÊúâÊïàÊñπÊ≥ï„Äã‰∏Ä‰π¶„ÄÇ ‰ª£Á†ÅÂèäÊ≥®Èáä from collections import namedtuple ALIVE = '*' EMPTY = '-' TICK = object () Query = namedtuple ( 'Query' , 'y x' ) Transition = namedtuple ( 'Transition' , 'y x state' ) def count_neighbors ( y , x ): \"\"\" Ëé∑ÂèñÈÇªÂ±ÖÁä∂ÊÄÅÁöÑÂ≠êÂçèÁ®ã„ÄÇ ËøîÂõûÂ≠òÊ¥ªÈÇªÂ±ÖÁöÑÊï∞ÈáèÁªôstep_cellÁöÑneighborÂèòÈáè„ÄÇ \"\"\" n_ = yield Query ( y + 1 , x + 0 ) # North ne = yield Query ( y + 1 , x + 1 ) # Northeast e_ = yield Query ( y + 0 , x + 1 ) # East se = yield Query ( y - 1 , x + 1 ) # Southeast s_ = yield Query ( y - 1 , x + 0 ) # South sw = yield Query ( y - 1 , x - 1 ) # Southwest w_ = yield Query ( y + 0 , x - 1 ) # West nw = yield Query ( y + 1 , x - 1 ) # Northwest neighbor_states = [ n_ , ne , e_ , se , s_ , sw , w_ , nw ] count = 0 for state in neighbor_states : if state == ALIVE : count += 1 return count def game_logic ( state , neighbors ): \"\"\" ÁªÜËÉûËΩ¨Êç¢ÁöÑÊù°‰ª∂„ÄÇ \"\"\" if state == ALIVE : if neighbors < 2 : return EMPTY # Die: Too few elif neighbors > 3 : return EMPTY # Die: Too many else : if neighbors == 3 : return ALIVE # Regenerate return state def step_cell ( y , x ): \"\"\" ÂÖàÊäõÂá∫ÁõÆÊ†áÁªÜËÉûËá™Ë∫´ÔºåÂÜçÈÄê‰∏™ÊäõÂá∫ÈÇªÂ±Ö„ÄÇ Ëé∑Âæó‰ª•‰∏äÊâÄÊúâÁªÜËÉûÁöÑÁä∂ÊÄÅ‰πãÂêéÂÜçÊ†πÊçÆÁªÜËÉûËΩ¨Êç¢Êù°‰ª∂ÊäõÂá∫ÁõÆÊ†áÁªÜËÉû Âú®‰∏ã‰∏Ä‰∏ñ‰ª£ÁöÑÁä∂ÊÄÅ„ÄÇ \"\"\" state = yield Query ( y , x ) neighbors = yield from count_neighbors ( y , x ) next_state = game_logic ( state , neighbors ) yield Transition ( y , x , next_state ) def simulate ( height , width ): \"\"\" ‰∏∫girdÁöÑÊØè‰∏™ÂÖÉÁ¥†ÊäõÂá∫ÂÖ∂Ëá™Ë∫´ÂèäÂÖ∂ÈÇªÂ±ÖÁªôÂÆ¢Êà∑Á®ãÂ∫è„ÄÇ TICK‰∏∫ÁªàÊ≠¢Êù°‰ª∂„ÄÇ \"\"\" while True : for y in range ( height ): for x in range ( width ): yield from step_cell ( y , x ) yield TICK class Grid ( object ): \"\"\" ÁªÜËÉûÁîüÊ¥ªÁöÑÂú∞Êñπ„ÄÇÂÆûÁé∞‰∫ÜgetitemÂíåsetitemÊñπÊ≥ïÊñπ‰æølive_a_generationÊñπÊ≥ïÊìç‰Ωú„ÄÇ \"\"\" def __init__ ( self , height , width ): self . height = height self . width = width self . rows = [] for _ in range ( self . height ): self . rows . append ([ EMPTY ] * self . width ) def __str__ ( self ): output = '' for row in self . rows : for cell in row : output += cell output += ' \\n ' return output def __getitem__ ( self , position ): y , x = position return self . rows [ y % self . height ][ x % self . width ] def __setitem__ ( self , position , state ): y , x = position self . rows [ y % self . height ][ x % self . width ] = state def live_a_generation ( grid , sim ): \"\"\" ‰∏Ä‰∏ñ‰ª£ÁöÑÁîüÂëΩÊ®°Êãü„ÄÇ \"\"\" progeny = Grid ( grid . height , grid . width ) item = next ( sim ) #TICK‰∏∫‰∏Ä‰∏ñ‰ª£ÁöÑÊ®°ÊãüÁöÑÁªìÊùü‰ø°Âè∑„ÄÇ while item is not TICK : #Â¶ÇÊûúÂçèÁ®ãÊäõÂá∫ÁöÑÊòØqueryÔºåÂàô‰º†ÂÖ•Ëøô‰∏Ä‰∏ñ‰ª£ËØ•queryÂØπÂ∫îÁªÜËÉûÁöÑÂ≠òÊ¥ªÊÉÖÂÜµ #Â¶ÇÊûúÊòØtransitionÂàôË°®Á§∫ÂØπÊüê‰∏ÄÁªÜËÉûÁöÑËΩ¨Êç¢Áä∂ÊÄÅÂà§Êñ≠Â∑≤ÂÆåÊàêÔºåÊîπÂèòÂÖ∂Â≠òÊ¥ªÊÉÖÂÜµ if isinstance ( item , Query ): state = grid [ item . y , item . x ] item = sim . send ( state ) else : # Must be a Transition progeny [ item . y , item . x ] = item . state item = next ( sim ) return progeny class ColumnPrinter ( object ): \"\"\" Â∞ÜÊµãËØïÁªìÊûúÊâìÂç∞Âá∫Êù•„ÄÇ columnsÁöÑÊØè‰∏™ÂÖÉÁ¥†ÊòØÊØèÊ¨°Ê®°ÊãüÂêéÁöÑÁªìÊûúgrid„ÄÇ \"\"\" def __init__ ( self ): self . columns = [] def append ( self , data ): self . columns . append ( data ) def __str__ ( self ): row_count = 1 for data in self . columns : row_count = max ( row_count , len ( data . splitlines ()) + 1 ) rows = [ '' ] * row_count print ( rows ) for j in range ( row_count ): for i , data in enumerate ( self . columns ): line = data . splitlines ()[ max ( 0 , j - 1 )] if j == 0 : rows [ j ] += str ( i ) . center ( len ( line )) else : rows [ j ] += line if ( i + 1 ) < len ( self . columns ): rows [ j ] += ' | ' return ' \\n ' . join ( rows ) def main (): \"\"\" ÊµãËØï‰ª£Á†Å„ÄÇ ÂàùÂßãÁîüÊàêÁöÑgrid‰∏∫Ôºö ---*----- ----*---- --***---- --------- --------- \"\"\" grid = Grid ( 5 , 9 ) grid [ 0 , 3 ] = ALIVE grid [ 1 , 4 ] = ALIVE grid [ 2 , 2 ] = ALIVE grid [ 2 , 3 ] = ALIVE grid [ 2 , 4 ] = ALIVE columns = ColumnPrinter () sim = simulate ( grid . height , grid . width ) for i in range ( 10 ): columns . append ( str ( grid )) grid = live_a_generation ( grid , sim ) print ( columns ) if __name__ == \"__main__\" : main () Additional ÂèÇËÄÉÊñáÁåÆ: 1. Âéü‰π¶Á§∫‰æã 2. Âéü‰π¶‰ª£Á†Å","tags":"Python","title":"Python Coroutine Example -- Game of life"},{"url":"flunet-python-167-coroutine-understading.html","text":"Description Êè¥ÂºïËá™„ÄäFluent Python„Äã16.7ËäÇ‰∏≠ÂÖ≥‰∫éË∞ÉÁî®ÊñπÈÄöËøáyield fromÂßîÊ¥æÁîüÊàêÂô®Ë∞ÉÁî®Â≠êÁîüÊàêÂô®ÁöÑ‰æãÂ≠ê„ÄÇÂõ†‰∏∫‰∏Ä‰∏™‰ª£Á†ÅÁªÜËäÇÈÄ†Êàê‰∫ÜÂØπ‰∫éÂßîÊ¥æÁîüÊàêÂô®ÁêÜËß£‰∏äÁöÑÂõ∞ÈöæÔºåÂõ†Ê≠§Âü∫‰∫é‰∏™‰∫∫ÁöÑÁêÜËß£ÂÅöÂá∫Áõ∏Â∫îÂú∞‰øÆÊîπÊù•‰ºòÂåñËØ•ÊÆµ‰ª£Á†Å„ÄÇ Âéü‰æã from collections import namedtuple Result = namedtuple ( 'Result' , 'count average' ) ### the subgenerator def averager (): # <1> total = 0.0 count = 0 average = None while True : term = yield # <2> if term is None : # <3> break total += term count += 1 average = total / count return Result ( count , average ) # <4> ### the delegating generator def grouper ( results , key ): # <5># <6> while True : results [ key ] = yield from averager () # <7> ### the client code, a.k.a. the caller def main ( data ): # <8> results = {} for key , values in data . items (): group = grouper ( results , key ) # <9> next ( group ) # <10> for value in values : group . send ( value ) # <11> group . send ( None ) # important! <12> #print(results) # uncomment to debug report ( results ) ### output report def report ( results ): for key , result in sorted ( results . items ()): group , unit = key . split ( ';' ) print ( ' {:2} {:5} averaging {:.2f}{} ' . format ( result . count , group , result . average , unit )) data = { 'girls;kg' : [ 40.9 , 38.5 , 44.3 , 42.2 , 45.2 , 41.7 , 44.5 , 38.0 , 40.6 , 44.5 ], 'girls;m' : [ 1.6 , 1.51 , 1.4 , 1.3 , 1.41 , 1.39 , 1.33 , 1.46 , 1.45 , 1.43 ], 'boys;kg' : [ 39.0 , 40.8 , 43.2 , 40.8 , 43.1 , 38.6 , 41.4 , 40.6 , 36.3 ], 'boys;m' : [ 1.38 , 1.5 , 1.32 , 1.25 , 1.37 , 1.48 , 1.25 , 1.49 , 1.46 ], } ‰∏éÁ§∫‰æã 16-13 ‰∏≠ÁöÑ averager ÂçèÁ®ã‰∏ÄÊ†∑„ÄÇËøôÈáå‰Ωú‰∏∫Â≠êÁîüÊàêÂô®‰ΩøÁî®„ÄÇ main ÂáΩÊï∞‰∏≠ÁöÑÂÆ¢Êà∑‰ª£Á†ÅÂèëÈÄÅÁöÑÂêÑ‰∏™ÂÄºÁªëÂÆöÂà∞ËøôÈáåÁöÑ term ÂèòÈáè‰∏ä„ÄÇ Ëá≥ÂÖ≥ÈáçË¶ÅÁöÑÁªàÊ≠¢Êù°‰ª∂„ÄÇÂ¶ÇÊûú‰∏çËøô‰πàÂÅöÔºå‰ΩøÁî® yield from Ë∞ÉÁî®Ëøô‰∏™ÂçèÁ®ãÁöÑÁîüÊàêÂô®‰ºöÊ∞∏ËøúÈòªÂ°û„ÄÇ ËøîÂõûÁöÑ Result ‰ºöÊàê‰∏∫ grouper ÂáΩÊï∞‰∏≠ yield from Ë°®ËææÂºèÁöÑÂÄº„ÄÇ grouper ÊòØÂßîÊ¥æÁîüÊàêÂô®„ÄÇ Ëøô‰∏™Âæ™ÁéØÊØèÊ¨°Ëø≠‰ª£Êó∂‰ºöÊñ∞Âª∫‰∏Ä‰∏™ averager ÂÆû‰æãÔºõÊØè‰∏™ÂÆû‰æãÈÉΩÊòØ‰Ωú‰∏∫ÂçèÁ®ã‰ΩøÁî®ÁöÑÁîüÊàêÂô®ÂØπË±°„ÄÇ grouper ÂèëÈÄÅÁöÑÊØè‰∏™ÂÄºÈÉΩ‰ºöÁªèÁî± yield from Â§ÑÁêÜÔºåÈÄöËøáÁÆ°ÈÅì‰º†Áªô averager ÂÆû‰æã„ÄÇgrouper ‰ºöÂú® yield from Ë°®ËææÂºèÂ§ÑÊöÇÂÅúÔºåÁ≠âÂæÖ averager ÂÆû‰æãÂ§ÑÁêÜÂÆ¢Êà∑Á´ØÂèëÊù•ÁöÑÂÄº„ÄÇaverager ÂÆû‰æãËøêË°åÂÆåÊØïÂêéÔºåËøîÂõûÁöÑÂÄºÁªëÂÆöÂà∞ results[key] ‰∏ä„ÄÇwhile Âæ™ÁéØ‰ºö‰∏çÊñ≠ÂàõÂª∫ averager ÂÆû‰æãÔºåÂ§ÑÁêÜÊõ¥Â§öÁöÑÂÄº„ÄÇ main ÂáΩÊï∞ÊòØÂÆ¢Êà∑Á´Ø‰ª£Á†ÅÔºåÁî® PEP 380 ÂÆö‰πâÁöÑÊúØËØ≠Êù•ËØ¥ÔºåÊòØ\"Ë∞ÉÁî®Êñπ\"„ÄÇËøôÊòØÈ©±Âä®‰∏ÄÂàáÁöÑÂáΩÊï∞„ÄÇ group ÊòØË∞ÉÁî® grouper ÂáΩÊï∞ÂæóÂà∞ÁöÑÁîüÊàêÂô®ÂØπË±°Ôºå‰º†Áªô grouper ÂáΩÊï∞ÁöÑÁ¨¨‰∏Ä‰∏™ÂèÇÊï∞ÊòØ resultsÔºåÁî®‰∫éÊî∂ÈõÜÁªìÊûúÔºõÁ¨¨‰∫å‰∏™ÂèÇÊï∞ÊòØÊüê‰∏™ÈîÆ„ÄÇgroup ‰Ωú‰∏∫ÂçèÁ®ã‰ΩøÁî®„ÄÇ È¢ÑÊøÄ group ÂçèÁ®ã„ÄÇ ÊääÂêÑ‰∏™ value ‰º†Áªô grouper„ÄÇ‰º†ÂÖ•ÁöÑÂÄºÊúÄÁªàÂà∞Ëææ averager ÂáΩÊï∞‰∏≠ term = yield ÈÇ£‰∏ÄË°åÔºõgrouper Ê∞∏Ëøú‰∏çÁü•ÈÅì‰º†ÂÖ•ÁöÑÂÄºÊòØ‰ªÄ‰πà„ÄÇ Êää None ‰º†ÂÖ• grouperÔºåÂØºËá¥ÂΩìÂâçÁöÑ averager ÂÆû‰æãÁªàÊ≠¢Ôºå‰πüËÆ© grouper ÁªßÁª≠ËøêË°åÔºåÂÜçÂàõÂª∫‰∏Ä‰∏™ averager ÂÆû‰æãÔºåÂ§ÑÁêÜ‰∏ã‰∏ÄÁªÑÂÄº„ÄÇ Á§∫‰æã 16-17 ‰∏≠ÊúÄÂêé‰∏Ä‰∏™Ê†áÂè∑ÂâçÈù¢Êúâ‰∏™Ê≥®Èáä‚Äî‚Äî\"ÈáçË¶ÅÔºÅ\"ÔºåÂº∫Ë∞ÉËøôË°å‰ª£Á†ÅÔºàgroup.send(None)ÔºâËá≥ÂÖ≥ÈáçË¶ÅÔºöÁªàÊ≠¢ÂΩìÂâçÁöÑ averager ÂÆû‰æãÔºåÂºÄÂßãÊâßË°å‰∏ã‰∏Ä‰∏™„ÄÇÂ¶ÇÊûúÊ≥®ÈáäÊéâÈÇ£‰∏ÄË°åÔºåËøô‰∏™ËÑöÊú¨‰∏ç‰ºöËæìÂá∫‰ªª‰ΩïÊä•Âëä„ÄÇÊ≠§Êó∂ÔºåÊää main ÂáΩÊï∞Èù†ËøëÊú´Â∞æÁöÑ print(results) ÈÇ£Ë°åÁöÑÊ≥®ÈáäÂéªÊéâÔºå‰Ω†‰ºöÂèëÁé∞Ôºåresults Â≠óÂÖ∏ÊòØÁ©∫ÁöÑ„ÄÇ Ê∫êÁ†Å ÁêÜËß£‰∏éÂãòËØØ Ê≥®Ëß£ 6 Ë°®Á§∫Âú®ÂßîÊ¥æÁîüÊàêÂô®‰∏≠Â∞Ü‰ºöÂæ™ÁéØÂàõÂª∫averagerËø≠‰ª£Âô®„ÄÇËøô‰∏ÄÁÇπËÆ©ÊàëÂú®ÁêÜËß£Ëµ∑Êù•‰∫ßÁîü‰∫ÜÊûÅÂ§ßÁöÑÂõ∞ÊÉë„ÄÇÂõ†‰∏∫‰ª•Êàë‰πãËßÅÂØπÂ∫îÊØè‰∏™keyÔºåÂßîÊâòËø≠‰ª£Âô®Âè™‰ºöÂú®‰∏Ä‰∏™Â≠êËø≠‰ª£Âô®‰∏≠ÈÅçÂéÜÂπ∂ËÆ°ÁÆóÂπ≥ÂùáÂÄº„ÄÇ ÈÅÇÊàë‰ª¨Â∞Üwhile TrueËØ≠Âè•ÂéªÊéâÔºåÂΩìmainÂáΩÊï∞ÁöÑforÂæ™ÁéØÂÜÖÁªôÂßîÊâòËø≠‰ª£Âô®send NoneÁöÑÊó∂ÂÄô‰æø‰ºöÊäõÂá∫StopIterationÂºÇÂ∏∏„ÄÇ ‰πãÂêéÂ∞ÜgrouperÁîüÊàêÂô®ÊîπÂÜôÊàêÂ¶Ç‰∏ã‰æøÂèØÊàêÂäüËøêË°å„ÄÇ def grouper ( results , key ): results [ key ] = yield from averager () yield Âú®ËøôÈáåÊé•ÂèóÂà∞None‰πãÂêéÂ≠êËø≠‰ª£Âô®averagerËø≠‰ª£Âô®‰πüËÉΩÊàêÂäüËøîÂÄºResultÔºåÂßîÊâòËø≠‰ª£Âô®Âú®Á¨¨‰∫å‰∏™yieldÂ§ÑÈòªÂ°ûÊâÄ‰ª•‰∏ç‰ºöÊäõÂá∫StopIterationÂºÇÂ∏∏„ÄÇ ÂΩìÁÑ∂‰πüÂèØ‰ª•Â∞ÜwhileËØ≠Âè•ÂéªÊéâÂêéÂú®mainÂáΩÊï∞Âä†ÂÖ•ÂºÇÂ∏∏Â§ÑÁêÜÊù•ÊçïËé∑StopIterationÂºÇÂ∏∏ÔºåËøôÊ†∑ËøòËÉΩÁü•ÈÅìÊØè‰∏™Â≠êËø≠‰ª£Âô®ÂÅúÊ≠¢ÁöÑÊó∂Èó¥„ÄÇ def main ( data ): results = {} for key , values in data . items (): group = grouper ( results , key ) next ( group ) for value in values : group . send ( value ) try : group . send ( None ) except StopIteration as ex : print ( 'end of child iterater' ) ÂÅáÂ¶Ç‰ΩøÁî®Ê∫êÁ®ãÂ∫èÁöÑwhile trueËøôÊÆµ‰ª£Á†ÅÁöÑËØùÔºåÂØπ‰∫éÊØè‰∏™keyÂ≠êËø≠‰ª£Âô®‰ºöÁîüÊàê‰∏§ÈÅçÔºåÂΩìÁÑ∂Á¨¨‰∫åÈÅçÁöÑÂ≠êËø≠‰ª£Âô®ÊòØ‰∏ç‰ºö‰ΩøÁî®ÁöÑ„ÄÇ ‰∏ãÈù¢ÁÆÄË¶ÅËØ¥ÊòéÁ§∫‰æãÁöÑËøê‰ΩúÊñπÂºèÔºåËøò‰ºöËØ¥ÊòéÊää main ÂáΩÊï∞‰∏≠Ë∞ÉÁî® group.send(None) ÈÇ£‰∏ÄË°å‰ª£Á†ÅÔºàÂ∏¶Êúâ\"ÈáçË¶ÅÔºÅ\"Ê≥®ÈáäÁöÑÈÇ£‰∏ÄË°åÔºâÂéªÊéâ‰ºöÂèëÁîü‰ªÄ‰πà‰∫ã„ÄÇ Â§ñÂ±Ç for Âæ™ÁéØÊØèÊ¨°Ëø≠‰ª£‰ºöÊñ∞Âª∫‰∏Ä‰∏™ grouper ÂÆû‰æãÔºåËµãÂÄºÁªô group ÂèòÈáèÔºõgroup ÊòØÂßîÊ¥æÁîüÊàêÂô®„ÄÇ Ë∞ÉÁî® next(group)ÔºåÈ¢ÑÊøÄÂßîÊ¥æÁîüÊàêÂô® grouperÔºåÊ≠§Êó∂ËøõÂÖ• while True Âæ™ÁéØÔºåË∞ÉÁî®Â≠êÁîüÊàêÂô® averager ÂêéÔºåÂú® yield from Ë°®ËææÂºèÂ§ÑÊöÇÂÅú„ÄÇ ÂÜÖÂ±Ç for Âæ™ÁéØË∞ÉÁî® group.send(value)ÔºåÁõ¥Êé•ÊääÂÄº‰º†ÁªôÂ≠êÁîüÊàêÂô® averager„ÄÇÂêåÊó∂ÔºåÂΩìÂâçÁöÑ grouper ÂÆû‰æãÔºàgroupÔºâÂú® yield from Ë°®ËææÂºèÂ§ÑÊöÇÂÅú„ÄÇ ÂÜÖÂ±ÇÂæ™ÁéØÁªìÊùüÂêéÔºågroup ÂÆû‰æã‰æùÊóßÂú® yield from Ë°®ËææÂºèÂ§ÑÊöÇÂÅúÔºåÂõ†Ê≠§Ôºågrouper ÂáΩÊï∞ÂÆö‰πâ‰Ωì‰∏≠‰∏∫ results[key] ËµãÂÄºÁöÑËØ≠Âè•ËøòÊ≤°ÊúâÊâßË°å„ÄÇ Â¶ÇÊûúÂ§ñÂ±Ç for Âæ™ÁéØÁöÑÊú´Â∞æÊ≤°Êúâ group.send(None)ÔºåÈÇ£‰πà averager Â≠êÁîüÊàêÂô®Ê∞∏Ëøú‰∏ç‰ºöÁªàÊ≠¢ÔºåÂßîÊ¥æÁîüÊàêÂô® group Ê∞∏Ëøú‰∏ç‰ºöÂÜçÊ¨°ÊøÄÊ¥ªÔºåÂõ†Ê≠§Ê∞∏Ëøú‰∏ç‰ºö‰∏∫ results[key] ËµãÂÄº„ÄÇ Â§ñÂ±Ç for Âæ™ÁéØÈáçÊñ∞Ëø≠‰ª£Êó∂‰ºöÊñ∞Âª∫‰∏Ä‰∏™ grouper ÂÆû‰æãÔºåÁÑ∂ÂêéÁªëÂÆöÂà∞ group ÂèòÈáè‰∏ä„ÄÇÂâç‰∏Ä‰∏™ grouper ÂÆû‰æãÔºà‰ª•ÂèäÂÆÉÂàõÂª∫ÁöÑÂ∞öÊú™ÁªàÊ≠¢ÁöÑ averager Â≠êÁîüÊàêÂô®ÂÆû‰æãÔºâË¢´ÂûÉÂúæÂõûÊî∂Á®ãÂ∫èÂõûÊî∂„ÄÇ Additional ÂèÇËÄÉÊñáÁåÆ: 1. ÊµÅÁïÖÁöÑpython","tags":"Python","title":"Flunet Python 16.7 coroutine understading"},{"url":"linklist-problems-summary.html","text":"Description ÈìæË°®ÈóÆÈ¢òÊòØÁªèÂ∏∏‰ºöÈÅáÂà∞ÁöÑÊï∞ÊçÆÁªìÊûÑÈóÆÈ¢ò„ÄÇËØ•Á±ªÈóÆÈ¢òÁöÑÈöæÁÇπ‰∏ªË¶ÅÈõÜ‰∏≠ÂÜçÂçïÂêëÈÅçÂéÜ‰ª•ÂèäÈìæË°®ÊúâÁéØÁöÑÊÉÖÂÜµ‰∏ã„ÄÇÂæàÂ§öÈìæË°®ÈóÆÈ¢òÂè™Ë¶ÅÂà©Áî®‰∏§‰∏™ÈÄüÂ∫¶‰∏ç‰∏ÄÁöÑÊåáÈíàÊù•ÂÆåÊàêÂçïÂêëÈÅçÂéÜÂ∞±ÂèØ‰ª•ÁÆÄÂåñÈóÆÈ¢ò„ÄÅÂáèÂ∞ëÂ§çÊùÇÂ∫¶„ÄÇÊú¨ÊñáÂü∫‰∫é‰∏Ä‰∫õÂ∏∏ËßÅÁöÑÈìæË°®ÈóÆÈ¢òÊù•ÂàÜÊûêÊØîËæÉËâØÂ•ΩÁöÑÊñπÊ°à‰ª•ÂèäpythonÂÆûÁé∞„ÄÇ ÂáÜÂ§áÂ∑•‰Ωú Âú®Ëß£ÂÜ≥ÈóÆÈ¢ò‰πãÂâçÔºåÊàë‰ª¨ÂÖàË¶ÅÂÆö‰πâËøôÊ¨°‰ΩøÁî®ÁöÑÈìæË°®ÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇ Âú®Ê≠§Êàë‰ª¨ÂÆö‰πâ‰∫Ü‰∏Ä‰∏™ÊôÆÈÄöÁöÑvalueÂíånextÊåáÈíàÁöÑÈìæË°®ÁªìÊûÑÔºåÂπ∂ÈáçÂÜô‰∫Ü__len__È≠îÊúØÊñπÊ≥ïÊù•ËÆ°ÁÆóÊó†ÁéØÈìæË°®Ëá™Ë∫´ÁöÑÈïøÂ∫¶ÔºåÊ∑ªÂä†‰∫ÜtraversalÊñπÊ≥ïÊù•Â∏ÆÂä©Êàë‰ª¨ÈÅçÂéÜÈìæË°®È™åËØÅÁªìËÆ∫„ÄÇ Âú®SampleLinklistÁ±ª‰∏≠Êàë‰ª¨ÂÆö‰πâ‰∫Ü‰∏Ä‰∫õÈìæË°®Á§∫‰æãÊù•ËæÖÂä©Êàë‰ª¨È™åËØÅÁªìËÆ∫„ÄÇ ### -*- coding: utf-8 -*- class Linklist ( object ): def __init__ ( self , value , next ): self . value = value self . next = next def traversal ( self ): \"\"\" ÈÅçÂéÜËØ•ËäÇÁÇπÂºÄÂßãÁöÑÈìæË°® :return: \"\"\" print ( self . value ) if self . next : self . next . traversal () def __bool__ ( self ): \"\"\" Áî®‰∫é‰πãÂêéÁöÑif LinklistÂà§Êñ≠ :return: \"\"\" return True def __len__ ( self ): \"\"\" :return: Êó†ÁéØÈìæË°®ÁöÑÈïøÂ∫¶ \"\"\" count = 0 node = self while node is not None : node = node . next count += 1 return count class SampleLinklist ( object ): def __init__ ( self ): # ÂàõÂª∫‰∏Ä‰∏™ÂÄº‰∏∫0-19ÁöÑÈìæË°®Êï∞ÁªÑ nodelist = [ Linklist ( i , None ) for i in range ( 20 )] # 0-6‰∏∫Êó†ÁéØÂçïÈìæË°®Ôºõ7-11‰∏∫ÊúâÁéØÂçïÈìæË°®ÔºàÂÖ•Âè£‰∏∫8ÔºâÔºõ # 12-14‰∫§‰∫éÊó†ÁéØÂçïÈìæË°®(ÂÖ•Âè£‰∏∫5)Ôºõ15-19‰∫§‰∫éÊúâÁéØÈìæË°®ÔºàÂÖ•Âè£‰∏∫9ÔºâÔºõ for key , value in enumerate ( nodelist ): if key != 6 and key != 11 and key != 14 and key != 19 : value . next = nodelist [ key + 1 ] elif key == 11 : value . next = nodelist [ 8 ] elif key == 14 : value . next = nodelist [ 5 ] elif key == 19 : value . next = nodelist [ 9 ] #Êó†ÁéØÂçïÈìæË°® self . normal_linklist = nodelist [ 0 ] #ÊúâÁéØÂçïÈìæË°®ÔºàÂÖ•Âè£‰∏∫8Ôºâ self . loop_linklist = nodelist [ 7 ] #‰∏énormal_linklist‰∫§‰∫é5 self . intersect_normal_linklist = ( nodelist [ 0 ], nodelist [ 12 ]) # ‰∏énloop_linklist‰∫§‰∫é9 self . intersect_loop_linklist = ( nodelist [ 7 ], nodelist [ 15 ]) Ëß£ÂÜ≥ÈóÆÈ¢ò Âú®O(1)Êó∂Èó¥Âà†Èô§ÈìæË°®ËäÇÁÇπ È¢òÁõÆÊèèËø∞Ôºö ÁªôÂÆöÈìæË°®ÁöÑÂ§¥ÊåáÈíàÂíå‰∏Ä‰∏™ËäÇÁÇπÊåáÈíàÔºåÂú®O(1)Êó∂Èó¥Âà†Èô§ËØ•ËäÇÁÇπ„ÄÇ ÂàÜÊûêÔºö Êú¨È¢ò‰∏é„ÄäÁºñÁ®ã‰πãÁæé„Äã‰∏äÁöÑ„Äå‰ªéÊó†Â§¥ÂçïÈìæË°®‰∏≠Âà†Èô§ËäÇÁÇπ„ÄçÁ±ª‰ºº„ÄÇ‰∏ªË¶ÅÊÄùÊÉ≥ÈÉΩÊòØ„ÄåÁã∏Áå´Êç¢Â§™Â≠ê„ÄçÔºåÂç≥Áî®‰∏ã‰∏Ä‰∏™ËäÇÁÇπÊï∞ÊçÆË¶ÜÁõñË¶ÅÂà†Èô§ÁöÑËäÇÁÇπÔºåÁÑ∂ÂêéÂà†Èô§‰∏ã‰∏Ä‰∏™ËäÇÁÇπ„ÄÇ‰ΩÜÊòØÂ¶ÇÊûúËäÇÁÇπÊòØÂ∞æËäÇÁÇπÊó∂ÔºåpythonÊó†Ê≥ïÁõ¥Êé•Âú®ÂÜÖÂ≠ò‰∏≠Âà†Èô§‰º†ÂÖ•ÂáΩÊï∞ÁöÑÂØπË±°ÔºåÊöÇÊó∂ËøòÊ≤°ÊâæÂà∞ÂäûÊ≥ïËß£ÂÜ≥„ÄÇ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def delete_specified_node ( node ): assert ( node != None ) if node . next != None : storeNode = node . next node . value = node . next . value node . next = node . next . next ÂèçËΩ¨ÂçïÈìæË°® È¢òÁõÆÊèèËø∞Ôºö ËæìÂÖ•‰∏Ä‰∏™ÂçïÂêëÈìæË°®ÔºåËæìÂá∫ÈÄÜÂ∫èÂèçËΩ¨ÂêéÁöÑÈìæË°®„ÄÇ ÂàÜÊûêÔºö ÈìæË°®ÁöÑËΩ¨ÁΩÆÊòØ‰∏Ä‰∏™ÂæàÂ∏∏ËßÅ„ÄÅÂæàÂü∫Á°ÄÁöÑÊï∞ÊçÆÁªìÊûÑÈ¢ò‰∫Ü„ÄÇÊàë‰ª¨Âú®ËøôÈáåËøêÁî®‰∫ÜÈÄíÂΩíÁÆóÊ≥ïÔºåÂ∞ÜÂ∞æËäÇÁÇπÂÜíÊ≥°ËøîÂõûÔºåÁÑ∂ÂêéÂØπÊØè‰∏™ËäÇÁÇπÁöÑÊåáÈíàÂèçÁΩÆ„ÄÇ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def revert_linklist ( node ): if not node or not node . next : # ËøîÂõûÈìæË°®Â∞æËäÇÁÇπ‰∏∫ÔºåÊó¢ÂèçËΩ¨ÂêéÈìæË°®Â§¥ÁªìÁÇπ return node # ÊöÇÂ≠òÂ§¥ÁªìÁÇπ header = revert_linklist ( node . next ) node . next . next = node node . next = None return header ÊâæÂà∞ÂçïÈìæË°®ÂÄíÊï∞Á¨¨k‰∏™ËäÇÁÇπ È¢òÁõÆÊèèËø∞Ôºö ËæìÂÖ•‰∏Ä‰∏™ÂçïÂêëÈìæË°®ÔºåËæìÂá∫ËØ•ÈìæË°®‰∏≠ÂÄíÊï∞Á¨¨k‰∏™ËäÇÁÇπÔºåÈìæË°®ÁöÑÂÄíÊï∞Á¨¨0‰∏™ËäÇÁÇπ‰∏∫ÈìæË°®ÁöÑÂ∞æÊåáÈíà„ÄÇ ÂàÜÊûêÔºö ËÆæÁΩÆ‰∏§‰∏™ÊåáÈíà p1„ÄÅp2ÔºåÈ¶ñÂÖà p1 Âíå p2 ÈÉΩÊåáÂêë headÔºåÁÑ∂Âêé p2 ÂêëÂâçËµ∞ k Ê≠•ÔºåËøôÊ†∑ p1 Âíå p2 ‰πãÈó¥Â∞±Èó¥Èöî k ‰∏™ËäÇÁÇπÔºåÊúÄÂêé p1 Âíå p2 ÂêåÊó∂ÂêëÂâçÁßªÂä®ÔºåÁõ¥Ëá≥ p2 Ëµ∞Âà∞ÈìæË°®Êú´Â∞æ„ÄÇ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def find_last_nth ( header , n ): if not header or n < 0 : return None # Â∞ÜfastÂíåslowÊåáÈíàËÆæËá≥ÈìæË°®Ëµ∑ÁÇπ fast = slow = header # Â∞ÜfastËµ∞n‰∏™ËäÇÁÇπ while fast . next and n > 0 : fast = fast . next n -= 1 # nÂ§ß‰∫éÈìæË°®ÈïøÂ∫¶ÁöÑÊÉÖÂÜµ if n > 0 : return None while fast . next : fast = fast . next slow = slow . next return slow ÊâæÂà∞ÂçïÈìæË°®‰∏≠Èó¥ËäÇÁÇπ È¢òÁõÆÊèèËø∞Ôºö Ê±ÇÈìæË°®ÁöÑ‰∏≠Èó¥ËäÇÁÇπÔºåÂ¶ÇÊûúÈìæË°®ÁöÑÈïøÂ∫¶‰∏∫ÂÅ∂Êï∞ÔºåËøîÂõû‰∏≠Èó¥‰∏§‰∏™ËäÇÁÇπÁöÑ‰ªªÊÑè‰∏Ä‰∏™ÔºåËã•‰∏∫Â•áÊï∞ÔºåÂàôËøîÂõû‰∏≠Èó¥ËäÇÁÇπ„ÄÇ ÂàÜÊûêÔºö Ê≠§È¢òÁöÑËß£ÂÜ≥ÊÄùË∑ØÂíåÁ¨¨3È¢ò„ÄåÊ±ÇÈìæË°®ÁöÑÂÄíÊï∞Á¨¨ k ‰∏™ËäÇÁÇπ„ÄçÂæàÁõ∏‰ºº„ÄÇÂèØ‰ª•ÂÖàÊ±ÇÈìæË°®ÁöÑÈïøÂ∫¶Ôºå ÁÑ∂ÂêéËÆ°ÁÆóÂá∫‰∏≠Èó¥ËäÇÁÇπÊâÄÂú®ÈìæË°®È°∫Â∫èÁöÑ‰ΩçÁΩÆ„ÄÇ‰ΩÜÊòØÂ¶ÇÊûúË¶ÅÊ±ÇÂè™ËÉΩÊâ´Êèè‰∏ÄÈÅçÈìæË°®ÔºåÂ¶Ç‰ΩïËß£ÂÜ≥Âë¢Ôºü ÊúÄÈ´òÊïàÁöÑËß£Ê≥ïÂíåÁ¨¨3È¢ò‰∏ÄÊ†∑ÔºåÈÄöËøá‰∏§‰∏™ÊåáÈíàÊù•ÂÆåÊàê„ÄÇÁî®‰∏§‰∏™ÊåáÈíà‰ªéÈìæË°®Â§¥ËäÇÁÇπÂºÄÂßãÔºå‰∏Ä‰∏™ÊåáÈíàÊØèÊ¨°ÂêëÂêéÁßªÂä®‰∏§Ê≠•Ôºå‰∏Ä‰∏™ÊØèÊ¨°ÁßªÂä®‰∏ÄÊ≠•ÔºåÁõ¥Âà∞Âø´ÊåáÈíàÁßªÂà∞Âà∞Â∞æËäÇÁÇπÔºåÈÇ£‰πàÊÖ¢ÊåáÈíàÂç≥ÊòØÊâÄÊ±Ç„ÄÇ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def find_mid ( header ): if not header : return None # Â∞ÜfastÂíåslowÊåáÈíàËÆæËá≥ÈìæË°®Ëµ∑ÁÇπ fast = slow = header while fast and fast . next : #fastÈÄüÂ∫¶‰∏∫slow‰∏§ÂÄç fast = fast . next . next slow = slow . next return slow Âà§Êñ≠ÂçïÈìæË°®ÊòØÂê¶ÊúâÁéØ È¢òÁõÆÊèèËø∞Ôºö ËæìÂÖ•‰∏Ä‰∏™ÂçïÂêëÈìæË°®ÔºåÂà§Êñ≠ÈìæË°®ÊòØÂê¶ÊúâÁéØ„ÄÇÂ¶ÇÊûúÈìæË°®Â≠òÂú®ÁéØÔºåÂ¶Ç‰ΩïÊâæÂà∞ÁéØÁöÑÂÖ•Âè£ÁÇπÔºü ÂàÜÊûêÔºö ÈÄöËøá‰∏§‰∏™ÊåáÈíàÔºåÂàÜÂà´‰ªéÈìæË°®ÁöÑÂ§¥ËäÇÁÇπÂá∫ÂèëÔºå‰∏Ä‰∏™ÊØèÊ¨°ÂêëÂêéÁßªÂä®‰∏ÄÊ≠•ÔºåÂè¶‰∏Ä‰∏™ÁßªÂä®‰∏§Ê≠•Ôºå‰∏§‰∏™ÊåáÈíàÁßªÂä®ÈÄüÂ∫¶‰∏ç‰∏ÄÊ†∑ÔºåÂ¶ÇÊûúÂ≠òÂú®ÁéØÔºåÈÇ£‰πà‰∏§‰∏™ÊåáÈíà‰∏ÄÂÆö‰ºöÂú®ÁéØÈáåÁõ∏ÈÅá„ÄÇÊåâÁÖß p2 ÊØèÊ¨°‰∏§Ê≠•Ôºåp1 ÊØèÊ¨°‰∏ÄÊ≠•ÁöÑÊñπÂºèËµ∞ÔºåÂèëÁé∞ p2 Âíå p1 ÈáçÂêàÔºåÁ°ÆÂÆö‰∫ÜÂçïÂêëÈìæË°®ÊúâÁéØË∑Ø‰∫Ü„ÄÇÊé•‰∏ãÊù•ÔºåËÆ©p2ÂõûÂà∞ÈìæË°®ÁöÑÂ§¥ÈÉ®ÔºåÈáçÊñ∞Ëµ∞ÔºåÊØèÊ¨°Ê≠•Èïø‰∏çÊòØËµ∞2‰∫ÜÔºåËÄåÊòØËµ∞1ÔºåÈÇ£‰πàÂΩì p1 Âíå p2 ÂÜçÊ¨°Áõ∏ÈÅáÁöÑÊó∂ÂÄôÔºåÂ∞±ÊòØÁéØË∑ØÁöÑÂÖ•Âè£‰∫Ü„ÄÇ‰∏∫‰ªÄ‰πàÔºüÔºöÂÅáÂÆöËµ∑ÁÇπÂà∞ÁéØÂÖ•Âè£ÁÇπÁöÑË∑ùÁ¶ª‰∏∫ aÔºåp1 Âíå p2 ÁöÑÁõ∏‰∫§ÁÇπM‰∏éÁéØÂÖ•Âè£ÁÇπÁöÑË∑ùÁ¶ª‰∏∫bÔºåÁéØË∑ØÁöÑÂë®Èïø‰∏∫LÔºåÂΩì p1 Âíå p2 Á¨¨‰∏ÄÊ¨°Áõ∏ÈÅáÁöÑÊó∂ÂÄôÔºåÂÅáÂÆö p1 Ëµ∞‰∫Ü n Ê≠•„ÄÇÈÇ£‰πàÊúâÔºöp1Ëµ∞ÁöÑË∑ØÂæÑÔºö a+b Ôºù nÔºõp2Ëµ∞ÁöÑË∑ØÂæÑÔºö a+b+k L = 2 nÔºõ p2 ÊØî p1 Â§öËµ∞‰∫ÜkÂúàÁéØË∑ØÔºåÊÄªË∑ØÁ®ãÊòØp1ÁöÑ2ÂÄçÊ†πÊçÆ‰∏äËø∞ÂÖ¨ÂºèÂèØ‰ª•ÂæóÂà∞ k*L=a+b=nÊòæÁÑ∂ÔºåÂ¶ÇÊûú‰ªéÁõ∏ÈÅáÁÇπMÂºÄÂßãÔºåp1 ÂÜçËµ∞ n Ê≠•ÁöÑËØùÔºåËøòÂèØ‰ª•ÂÜçÂõûÂà∞Áõ∏ÈÅáÁÇπÔºåÂêåÊó∂p2‰ªéÂ§¥ÂºÄÂßãËµ∞ÁöÑËØùÔºåÁªèËøánÊ≠•Ôºå‰πü‰ºöËææÂà∞Áõ∏ÈÅáÁÇπM„ÄÇÊòæÁÑ∂Âú®Ëøô‰∏™Ê≠•È™§ÂΩì‰∏≠ p1 Âíå p2Âè™ÊúâÂâç a Ê≠•Ëµ∞ÁöÑË∑ØÂæÑ‰∏çÂêåÔºåÊâÄ‰ª•ÂΩì p1 Âíå p2 ÂÜçÊ¨°ÈáçÂêàÁöÑÊó∂ÂÄôÔºåÂøÖÁÑ∂ÊòØÂú®ÈìæË°®ÁöÑÁéØË∑ØÂÖ•Âè£ÁÇπ‰∏ä„ÄÇ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def is_loop ( header ): if not header : return False fast = slow = header while fast and fast . next : fast = fast . next . next slow = slow . next # ÊâæÂà∞‰∏§Ê≠•Èïø‰∫§Ê±áÁÇπ if fast == slow : break if fast != slow : return None # Â∞ÜfastÂèëÈÖçÂõûËµ∑ÁÇπ fast = header #ÂΩì‰∏§ËäÇÁÇπÂÜçÊ¨°Áõ∏ÈÅáÁöÑÊó∂ÂÄôÂàô‰∏∫ÁéØÂÖ•Âè£ while not fast == slow : fast = fast . next slow = slow . next return fast Âà§Êñ≠‰∏§‰∏™ÂçïÈìæË°®ÊòØÂê¶Áõ∏‰∫§ È¢òÁõÆÊèèËø∞Ôºö ÁªôÂá∫‰∏§‰∏™ÈìæË°®ÁöÑÂ§¥ÊåáÈíàÔºåÂà§Êñ≠ÂÖ∂ÊòØÂê¶Áõ∏‰∫§„ÄÇ ÂàÜÊûêÔºö Â¶ÇÊûú‰∏§‰∏™Êó†ÁéØÈìæË°®Áõ∏‰∫§ÔºåÂàôÂÖ∂Â∞æÊåáÈíà‰∏ÄÂÆöÁõ∏ÂêåÔºõÂ¶ÇÊûú‰∏§‰∏™ÊúâÁéØÈìæË°®Áõ∏‰∫§ÔºåÂàô‰∏§‰∏™ÈìæË°®ÈÉΩÊúâÂÖ±Âêå‰∏Ä‰∏™ÁéØÔºåÂç≥ÁéØ‰∏äÁöÑ‰ªªÊÑè‰∏Ä‰∏™ËäÇÁÇπÈÉΩÂ≠òÂú®‰∫é‰∏§‰∏™ÈìæË°®‰∏ä„ÄÇÂõ†Ê≠§ÔºåÂ∞±ÂèØ‰ª•Âà§Êñ≠‰∏ÄÈìæË°®‰∏ä‰ø©ÊåáÈíàÁõ∏ÈÅáÁöÑÈÇ£‰∏™ËäÇÁÇπÔºåÂú®‰∏çÂú®Âè¶‰∏ÄÊù°ÈìæË°®‰∏ä„ÄÇ ### -*- coding: utf-8 -*- from linklist import SampleLinklist from whether_linklist_has_loop import is_loop def is_intersect ( header1 , header2 ): if not header1 or not header2 : return False if not is_loop ( header1 ) and not is_loop ( header2 ): # ‰∏§‰∏™Êó†ÁéØÈìæË°®ÁöÑÂ∞æËäÇÁÇπÊòØÂê¶Áõ∏Á≠âÂÜ≥ÂÆö‰∫ÜÂÆÉ‰ª¨ÊòØÂê¶Áõ∏‰∫§ while header1 : header1 = header1 . next while header2 : header2 = header2 . next return True if header1 == header2 else False elif not is_loop ( header1 ) or not is_loop ( header2 ): return False else : # ‰∏§‰∏™Â∏¶ÁéØÈìæË°®ÁöÑÂÖ•Âè£ÂøÖÁÑ∂Âú®ÂÆÉ‰ª¨ÁöÑÁéØÂÜÖ intersect1 = is_loop ( header1 ) intersect2 = is_loop ( header2 ) node = intersect2 . next # Â¶ÇÊûú‰ªªÊÑèÈìæË°®ÁéØ‰∏≠ÊúâÂè¶‰∏ÄÂàóË°®ÁöÑËäÇÁÇπÂàôÁõ∏‰∫§ while node != intersect2 : if node == intersect1 : return True node = node . next return False ÊâæÂà∞ÈìæË°®Áõ∏‰∫§ÁÇπ È¢òÁõÆÊèèËø∞Ôºö Â¶ÇÊûú‰∏§‰∏™ÂçïÈìæË°®Áõ∏‰∫§ÔºåÊÄé‰πàÊ±ÇÂá∫‰ªñ‰ª¨Áõ∏‰∫§ÁöÑÁ¨¨‰∏Ä‰∏™ËäÇÁÇπÂë¢Ôºü ÂàÜÊûêÔºö ÂΩì‰∏§ÈìæË°®Êó†ÁéØÊó∂ÔºåÂàôÂèØÈááÁî®ÂØπÈΩêÁöÑÊÄùÊÉ≥„ÄÇËÆ°ÁÆó‰∏§‰∏™ÈìæË°®ÁöÑÈïøÂ∫¶ L1 , L2ÔºåÂàÜÂà´Áî®‰∏§‰∏™ÊåáÈíà p1 , p2 ÊåáÂêë‰∏§‰∏™ÈìæË°®ÁöÑÂ§¥ÔºåÁÑ∂ÂêéÂ∞ÜËæÉÈïøÈìæË°®ÁöÑ p1ÔºàÂÅáËÆæ‰∏∫ p1ÔºâÂêëÂêéÁßªÂä®L2 - L1‰∏™ËäÇÁÇπÔºåÁÑ∂ÂêéÂÜçÂêåÊó∂ÂêëÂêéÁßªÂä®p1 , p2ÔºåÁõ¥Âà∞ p1 = p2„ÄÇÁõ∏ÈÅáÁöÑÁÇπÂ∞±ÊòØÁõ∏‰∫§ÁöÑÁ¨¨‰∏Ä‰∏™ËäÇÁÇπ„ÄÇÂΩì‰∏§ÈìæË°®ÊúâÁéØÊó∂ÔºåÂ¶ÇÊûú‰∏™ÁéØÂÖ•Âè£Áõ∏Á≠âÔºåÂàôÂèØÁúãÊàê‰ª•ÁéØÂÖ•Âè£‰∏∫Â∞æËäÇÁÇπÁöÑÊó†ÁéØÊÉÖÂÜµ„ÄÇÂ¶ÇÊûú‰∏çÁ≠âÔºåÂàôÈ¶ñÂÖ¨ÂÖ±ËäÇÁÇπ‰∏∫‰∏§‰∏™ÂÖ•Âè£ËæÉËøëÁöÑÈÇ£‰∏™„ÄÇ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def find_intersect_first_common ( header1 , header2 ): len1 = len ( header1 ) len2 = len ( header2 ) if len1 > len2 : for i in range ( len1 - len2 ): header1 = header1 . next else : for i in range ( len2 - len1 ): header2 = header2 . next while header1 : if header1 == header2 : return header1 header1 = header1 . next header2 = header2 . next return None Ê∫êÁ†Å‰∏ãËΩΩ Additional ÂèÇËÄÉÊñáÁåÆ: 1. Èù¢ËØïÁ≤æÈÄâÔºöÈìæË°®ÈóÆÈ¢òÈõÜÈî¶ 2. ÊµÅÁïÖÁöÑpython","tags":"Python","title":"Linklist Problems Summary"},{"url":"leetcode-next-greater-element-ii.html","text":"Description Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number. Example 1: Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2. Note: The length of given array won't exceed 10000. Source link Best practice TBD C++ version -- TBD Mark: 0ms ‰ΩøÁî®Ê†àÊù•Âà§Êñ≠ÂêÑ‰∏™ÂÖÉÁ¥†next greaterÁöÑÂÖÉÁ¥†„ÄÇÁî®1Ëá≥2nÂ∫èÂè∑‰ª•ÂèäÂèñ‰ΩôÁöÑÊñπÊ≥ïÊù•ÈÅçÂéÜ‰∏§ÈÅçÂàóË°®ÔºåÊ®°ÊãüÂæ™ÁéØÊï∞ÁªÑÁöÑÊÉÖÂÜµ python version class Solution ( object ): def nextGreaterElements ( self , nums ): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" length = len ( nums ) stack , res = [], [ - 1 ] * length for i in range ( length * 2 ): #Â¶ÇÊûúÂá∫Áé∞Â§ß‰∫éÊ†àÈ°∂Â∫èÂè∑ÂæóÂÖÉÁ¥†ÂÄºÁöÑÂÖÉÁ¥†Êó∂Ôºå #Â∞±ÂèØ‰ª•ÁñØÁãÇÂá∫ÊéâÊâÄÊúâÂ∞è‰∫éËØ•ÂÖÉÁ¥†ÁöÑÊâÄÊúâÂÖÉÁ¥†Â∫èÂè∑ while stack and ( nums [ stack [ - 1 ]] < nums [ i % length ]): res [ stack . pop ()] = nums [ i % length ] #‰ªÖ‰ªÖÂ∞ÜÊØè‰∏™ÂÖÉÁ¥†ÁöÑÂ∫èÂè∑ÂÖ•Ê†à‰∏ÄÊ¨° if i < length : stack . append ( i ) return res Mark: 275ms Additional","tags":"Python","title":"LeetCode - Next Greater Element II"},{"url":"leetcode-database-problems-summary.html","text":"Description Here is a summary of LeetCode Database section. Source link Âà†Èô§ÈáçÂ§çÊï∞ÊçÆ Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id. +----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+------------------+ Id is the primary key column for this table. For example, after running your query, the above Person table should have the following rows: +----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | +----+------------------+ Âà†Èô§ÈáçÂ§çÊï∞ÊçÆÊòØÈùûÂ∏∏ÊôÆÈÅçÂíåÂü∫Á°ÄÁöÑÊìç‰Ωú„ÄÇÈ¶ñÂÖàÊàë‰ª¨ÂèØ‰ª•Áî®ËøûÊé•Ëá™Ë∫´‰ª•ÂèäwhereÊù°‰ª∂ËøáÊª§Êù•ÂÆåÊàê„ÄÇ delete p1 from Person p1,Person p2 where p1.Email=p2.Email and p1.id>p2.id Áî®Â≠êÊü•ËØ¢ÂíåminÈÄâÂá∫ÊØè‰∏™ÂêåÂêçÁªÑ‰∏≠ÊúÄÂ∞èÁöÑidÂè∑ÔºåÂà†Èô§Èô§‰∫ÜËøô‰∫õid‰ª•Â§ñÁöÑË°å„ÄÇ delete from Person where id not in (select b.id from (select min(id) as id from Person group by Email) b) ÊéíÂ∫èÈóÆÈ¢ò Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no \"holes\" between ranks. +----+-------+ | Id | Score | +----+-------+ | 1 | 3.50 | | 2 | 3.65 | | 3 | 4.00 | | 4 | 3.85 | | 5 | 4.00 | | 6 | 3.65 | +----+-------+ For example, given the above Scores table, your query should generate the following report (order by highest score): +-------+------+ | Score | Rank | +-------+------+ | 4.00 | 1 | | 4.00 | 1 | | 3.85 | 2 | | 3.65 | 3 | | 3.65 | 3 | | 3.50 | 4 | +-------+------+ ËøôÈáåÁî®ÁªìÊûúÈõÜ‰∏≠Â§ß‰∫éÁ≠â‰∫éÂΩìÂâçscoreÁöÑdistinctË°åÊï∞Êù•Ë°®Á§∫ÊüêÂàÜÊï∞Âú®Êï¥‰∏™ÁªìÊûúÈõÜ‰∏≠ÁöÑÂ∫èÂàó„ÄÇ select s.Score, (select count(*) from (select distinct Score from Scores) s2 where s2.Score>=s.Score) Rank from Scores s order by Rank asc ÂàÜÁªÑÊØîËæÉÈóÆÈ¢ò The Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (‚Äòcompleted', ‚Äòcancelled_by_driver', ‚Äòcancelled_by_client'). +----+-----------+-----------+---------+--------------------+----------+ | Id | Client_Id | Driver_Id | City_Id | Status |Request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ The Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‚Äòclient', ‚Äòdriver', ‚Äòpartner'). +----------+--------+--------+ | Users_Id | Banned | Role | +----------+--------+--------+ | 1 | No | client | | 2 | Yes | client | | 3 | No | client | | 4 | No | client | | 10 | No | driver | | 11 | No | driver | | 12 | No | driver | | 13 | No | driver | +----------+--------+--------+ Write a SQL query to find the cancellation rate of requests made by unbanned clients between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places. +------------+-------------------+ | Day | Cancellation Rate | +------------+-------------------+ | 2013-10-01 | 0.33 | | 2013-10-02 | 0.00 | | 2013-10-03 | 0.50 | +------------+-------------------+ Â∞ÜÊï∞ÊçÆÈõÜ‰ª•Êó∂Èó¥ÂàÜÁªÑÔºåÂà©Áî®case when Êù•Âà§Êñ≠ÊòØÂê¶ËÆ°ÂÖ•ÂèñÊ∂àËÆ¢ÂçïÊï∞„ÄÇ‰πüÂèØ‰ª•Áî®ifËØ≠Âè•„ÄÇ select t.Request_at as Day, round((sum(case when t.Status in (\"cancelled_by_driver\",\"cancelled_by_client\") then 1 else 0 end)/count(*)),2) as \"Cancellation Rate\" from Trips t inner join Users u on t.Client_Id =u.Users_Id where u.Banned <> \"Yes\" and t.Request_at between \"2013-10-01\" and \"2013-10-03\" group by t.Request_at The Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Henry | 80000 | 2 | | 3 | Sam | 60000 | 2 | | 4 | Max | 90000 | 1 | | 5 | Janet | 69000 | 1 | | 6 | Randy | 85000 | 1 | +----+-------+--------+--------------+ The Department table holds all departments of the company. +----+----------+ | Id | Name | +----+----------+ | 1 | IT | | 2 | Sales | +----+----------+ Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | IT | Randy | 85000 | | IT | Joe | 70000 | | Sales | Henry | 80000 | | Sales | Sam | 60000 | +------------+----------+--------+ Âèñtop3ÁöÑÂàÜÁªÑÊï∞ÊçÆÂíåÂèñÊúÄÂ§ßÂàÜÁªÑsalaryÊúâÊâÄ‰∏çÂêå„ÄÇÂêéËÄÖÂèØ‰ª•Áî®where salary in Ôºàselect max(salary) ..group by ÔºâÂ≠êÊü•ËØ¢ËØ≠Âè•Êù•ÂÆûÁé∞„ÄÇ ËøôÈáåËøêÁî®‰∫ÜÊéíÂ∫èÈóÆÈ¢ò‰∏≠ÁöÑÊÄùÊÉ≥„ÄÇÂ∞ÜÂΩìÂâçsalary‰∏éÂêå‰∏Ägroup‰∏≠ÔºàË°®Áé∞‰∏∫departmentidÁõ∏Á≠âÔºâÔºåÂ§ß‰∫éÁ≠â‰∫éÂΩìÂâçdistinctÁöÑsalaryÁöÑÊï∞Èáè‰Ωú‰∏∫ËØ•salaryÁöÑrank„ÄÇÂÖ∂‰ªñÈôêÂà∂Êù°‰ª∂Â∞±ËøéÂàÉËÄåËß£‰∫Ü„ÄÇ select d.Name Department, e1.Name Employee, e1.Salary from Employee e1 join Department d on e1.DepartmentId = d.Id where 3 > (select count(distinct(e2.Salary)) from Employee e2 where e2.Salary > e1.Salary and e1.DepartmentId = e2.DepartmentId );","tags":"SQL","title":"LeetCode - Database Problems Summary"},{"url":"leetcode-construct-the-rectangle.html","text":"Description For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page's area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: The area of the rectangular web page you designed must equal to the given target area. The width W should not be larger than the length L, which means L >= W. The difference between length L and width W should be as small as possible. You need to output the length L and the width W of the web page you designed in sequence. Example: Input : 4 Output : [ 2 , 2 ] Explanation : The target area is 4 , and all the possible ways to construct it are [ 1 , 4 ], [ 2 , 2 ], [ 4 , 1 ]. But according to requirement 2 , [ 1 , 4 ] is illegal ; according to requirement 3 , [ 4 , 1 ] is not optimal compared to [ 2 , 2 ]. So the length L is 2 , and the width W is 2 . Note: 1. The given area won't exceed 10,000,000 and is a positive integer 2. The web page's width and length you designed must be positive integers. Source link Best practice ÂÖ∂ÂÆûÂæàÁÆÄÂçïÔºåÊîæ‰∏äÊù•ÊòØÂõ†‰∏∫ËÆ∞ÂΩï‰∏Ä‰∏ãpythonÂíåcÂêÑËá™‰∏çÂêåÁöÑËß£ÂÜ≥ÊñπÂºè„ÄÇÁÑ∂ÂêécÁöÑ0msÂÆûÂú®ÊòØÂ§™Â§∏Âº†‰∫Ü„ÄÇ C++ version class Solution { public : vector < int > constructRectangle ( int area ) { int ceil = floor ( sqrt ( area )); while ( area % ceil != 0 ) { -- ceil ; } return vector < int > ({ area / ceil , ceil }); } }; Mark: 0ms python version import math class Solution ( object ): def constructRectangle ( self , area ): \"\"\" :type area: int :rtype: List[int] \"\"\" for i in range ( math . floor ( math . sqrt ( area )), 0 , - 1 ): if area % i == 0 : return [ int ( area / i ), i ] Mark: 46ms Additional","tags":"C,Python","title":"LeetCode - Construct the Rectangle"},{"url":"leetcode-move-zeroes.html","text":"Description Given an array nums , write a function to move all 0 's to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12] , after calling your function, nums should be [1, 3, 12, 0, 0] . Note: 1. You must do this in-place without making a copy of the array. 2. Minimize the total number of operations. Source link Best practice ÊØèÂΩìÈÅáÂà∞‰∏Ä‰∏™0‰ΩçÂ∞±Â∞Ü‰πãÂêéÁöÑÊï∞Â≠óÂêëÂâçÁßªÂä®x‰ΩçÔºàx‰∏∫ÈÅáÂà∞ÁöÑ0ÁöÑ‰∏™Êï∞ÔºâÔºåÊúÄÂêéÂ∞ÜÂêéx‰ΩçÁΩÆ‰∏∫0„ÄÇ C++ version class Solution { public : void moveZeroes ( vector < int >& nums ) { int count = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ){ if ( nums [ i ] == 0 ){ ++ count ; } else { nums [ i - count ] = nums [ i ]; } } for ( int i = 0 ; i < count ; ++ i ){ nums [ nums . size () - 1 - i ] = 0 ; } } }; Mark: 16ms Áî®‰∏Ä‰∏™ÂèòÈáèjÊù•ËÆ∞ÂΩïÈùû0‰ΩçÂ∫îÂú®ÁöÑ‰ΩçÁΩÆÔºåÊúÄÂêéÂ§ÑÁêÜÊú´ÁΩÆ0‰Ωç„ÄÇ python version class Solution ( object ): def moveZeroes ( self , nums ): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" j = 0 for item in nums : if item != 0 : nums [ j ] = item j += 1 for index in range ( j , len ( nums )): nums [ index ] = 0 Mark: 59ms Additional","tags":"C,Python","title":"LeetCode - Move Zeroes"},{"url":"leetcode-add-one-row-to-tree.html","text":"Description Given the root of a binary tree, then value v and depth d , you need to add a row of nodes with value v at the given depth d . The root node is at depth 1. The adding rule is: given a positive integer depth d , for each NOT null tree nodes N in depth d-1 , create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1: Input : A binary tree as following : 4 / \\ 2 6 / \\ / 3 1 5 v = 1 d = 2 Output : 4 / \\ 1 1 / \\ 2 6 / \\ / 3 1 5 Example 2: Input : A binary tree as following : 4 / 2 / \\ 3 1 v = 1 d = 3 Output : 4 / 2 / \\ 1 1 / \\ 3 1 Note: 1. The given d is in range [1, maximum depth of the given tree + 1]. 2. The given binary tree has at least one tree node. Source link Best practice È¢òÁõÆ‰∏≠d=1Êó∂ÂÆû‰∏∫‰∏ÄÁßçÁâπÊÆäÊÉÖÂÜµ‚Äî‚Äî‚Äî‚ÄîÊï¥È¢óÊ†ëÂèò‰∏∫Â∑¶Â≠êÊ†ë„ÄÇÁõ∏‰ººÁöÑÂΩìd=0Êó∂Êï¥Ê£µÊ†ëÁõ∏Â∫î‰ºöÂèòÊàêÂè≥Â≠êÊ†ëÂòõ„ÄÇ‰ª•Ê≠§Êé®ÁêÜÂèØ‰ª•Âæó‰ª•‰∏ãÁªàÊûÅËß£ÂÜ≥ÊñπÊ≥ï„ÄÇÂ∞Üd=0Âíåd=1‰Ωú‰∏∫ÈÄíÂΩíÁªàÊ≠¢Êù°‰ª∂‰ªéËÄåÂ∞Üd=1ÁöÑÁâπÊÆäÊÉÖÂÜµÊ¶ÇÂåñÔºåÂèàÁúÅÂéª‰∫ÜhelperÂáΩÊï∞„ÄÇ C++ version class Solution { public : TreeNode * addOneRow ( TreeNode * root , int v , int d ) { if ( d == 0 || d == 1 ) { TreeNode * newroot = new TreeNode ( v ); ( d ? newroot -> left : newroot -> right ) = root ; return newroot ; } if ( root && d >= 2 ) { root -> left = addOneRow ( root -> left , v , d > 2 ? d - 1 : 1 ); root -> right = addOneRow ( root -> right , v , d > 2 ? d - 1 : 0 ); } return root ; } }; Mark: 16ms Ëøô‰∏™pythonÁâàÊú¨ÊòæÂæóÈùûÂ∏∏‰∏çpythonic„ÄÇhelperÂáΩÊï∞Â¢ûÂä†‰∫Ü‰∏Ä‰∏™ÈïøÂ∫¶ÂèÇÊï∞ËÆ∞ÂΩï‰∫ÜÈÄíÂΩíÊ†ëÊ∑±Â∫¶ÔºåÂÖ∂ÂÆûÂèØ‰ª•Áî®‰ΩøÂèÇÊï∞dÈÄíÂáèÁöÑÊñπÂºèÊù•‰º†ÈÄíÊ∑±Â∫¶„ÄÇ python version ### Definition for a binary tree node. ### class TreeNode(object): ### def __init__(self, x): ### self.val = x ### self.left = None ### self.right = None class Solution : def addOneRow ( self , root , v , d ): \"\"\" :type root: TreeNode :type v: int :type d: int :rtype: TreeNode \"\"\" if d == 1 : a = TreeNode ( v ) a . left = root return a return self . helper ( root , v , d , 1 ) def helper ( self , node , v , d , dep ): if not node : return if dep == d - 1 : a = TreeNode ( v ) b = TreeNode ( v ) a . left = node . left b . right = node . right node . left = a node . right = b self . helper ( node . left , v , d , dep + 1 ) self . helper ( node . right , v , d , dep + 1 ) return node Mark: 82ms Additional","tags":"C,Python","title":"LeetCode - Add One Row to Tree"},{"url":"leetcode-array-nesting.html","text":"Description A zero-indexed array A consisting of N different integers is given. The array contains all integers in the range [0, N - 1]. Sets S[K] for 0 <= K < N are defined as follows: S[K] = { A[K], A[A[K]], A[A[A[K]]], ... }. Sets S[K] are finite for each K and should NOT contain duplicates. Write a function that given an array A consisting of N integers, return the size of the largest set S[K] for this array. Example 1: Input : A = [ 5,4,0,3,1,6,2 ] Output : 4 Explanation : A [ 0 ] = 5 , A [ 1 ] = 4 , A [ 2 ] = 0 , A [ 3 ] = 3 , A [ 4 ] = 1 , A [ 5 ] = 6 , A [ 6 ] = 2. One of the longest S [ K ] : S [ 0 ] = { A [ 0 ] , A [ 5 ] , A [ 6 ] , A [ 2 ] } = { 5 , 6 , 2 , 0 } Note: 1. N is an integer within the range [1, 20,000]. 2. The elements of A are all distinct. 3. Each element of array A is an integer within the range [0, N-1]. Source link Best practice ËøôÈáåÁî®Âà∞‰∫Ü‰∏Ä‰∏™‰πãÂâçÁî®ËøáÁöÑÂÖ•Ê†àÈÅçÂéÜÊñπÂºèÔºåÂèñmaxÊó∂ÂÄôÁöÑËøêÁÆóËøòÂèØ‰ª•ËøõË°å‰ºòÂåñ„ÄÇ Python version 1 class Solution ( object ): def arrayNesting ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" length = len ( nums ) def helper ( stack ): for item in stack : #ÂøΩÁï•Ë¢´Ê†áËÆ∞ÁöÑÂÖÉÁ¥† if nums [ item ] < length : stack . append ( nums [ item ]) #Â∞ÜÊâÄÊúâÈÅçÂéÜËøáÁöÑÂÖÉÁ¥†ÁöÑÂ∫èÂè∑+lengthÂÅöÂîØ‰∏ÄÊ†áËÆ∞ nums [ item ] += length return len ( stack ) - 1 #ÈÅçÂéÜÊâÄÊúâÊú™Ë¢´Ê†áËÆ∞ÁöÑÂÖÉÁ¥† return max ([ helper ([ item ]) for item in nums if item < length ]) Mark: 85ms ËøôÊòØ‰∏Ä‰∏™ÊØîËæÉÊôÆÈÄÇÊÄßÁöÑÊñπÊ≥ïÔºåÂàõÂª∫‰∏Ä‰∏™ËÆ∞ÂΩïÂàóË°®„ÄÇ python version 2 class Solution ( object ): def arrayNesting ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" ans , step , n = 0 , 0 , len ( nums ) seen = [ False ] * n for i in range ( n ): while not seen [ i ]: seen [ i ] = True i , step = nums [ i ], step + 1 ans = max ( ans , step ) step = 0 return ans Mark: 85ms Additional","tags":"Python","title":"LeetCode - Array Nesting"},{"url":"leetcode-construct-string-from-binary-tree.html","text":"Description You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair \"()\". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input : Binary tree : [ 1 , 2 , 3 , 4 ] 1 / \\ 2 3 / 4 Output : \"1(2(4))(3)\" Explanation : Originallay it needs to be \"1(2(4)())(3()())\" , but you need to omit all the unnecessary empty parenthesis pairs . And it will be \"1(2(4))(3)\" . Example 2: Input : Binary tree : [ 1 , 2 , 3 , null , 4 ] 1 / \\ 2 3 \\ 4 Output : \"1(2()(4))(3)\" Explanation : Almost the same as the first example , except we can ' t omit the first parenthesis pair to break the one - to - one mapping relationship between the input and the output . Source link Best practice ÈÄíÂΩíÊñπÊ≥ï„ÄÇ C++ version class Solution { public : string tree2str ( TreeNode * t ) { if ( ! t ) return \"\" ; if ( ! t -> left &&! t -> right ) return to_string ( t -> val ); if ( ! t -> left ) return to_string ( t -> val ) + \"()(\" + tree2str ( t -> right ) + \")\" ; if ( ! t -> right ) return to_string ( t -> val ) + \"(\" + tree2str ( t -> left ) + \")\" ; return to_string ( t -> val ) + \"(\" + tree2str ( t -> left ) + \")(\" + tree2str ( t -> right ) + \")\" ; } }; Mark: 12ms python version class Solution ( object ): def tree2str ( self , t ): \"\"\" :type t: TreeNode :rtype: str \"\"\" if not t : return \"\" leftstring = \"( {} )\" . format ( self . tree2str ( t . left )) if t . left or ( not t . left and t . right ) else \"\" rightstring = \"( {} )\" . format ( self . tree2str ( t . right )) if t . right else \"\" return \" {}{}{} \" . format ( t . val , leftstring , rightstring ) Mark: 88ms Additional","tags":"C,Python","title":"LeetCode - Construct String from Binary Tree"},{"url":"leetcode-sort-characters-by-frequency.html","text":"Description Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input : \"tree\" Output : \"eert\" Explanation : 'e' appears twice while 'r' and 't' both appear once . So 'e' must appear before both 'r' and 't' . Therefore \"eetr\" is also a valid answer . Example 2: Input : \"cccaaa\" Output : \"cccaaa\" Explanation : Both 'c' and 'a' appear three times , so \"aaaccc\" is also a valid answer . Note that \"cacaca\" is incorrect , as the same characters must be together . Example 3: Input : \"Aabb\" Output : \"bbAa\" Explanation : \"bbaA\" is also a valid answer , but \"Aabb\" is incorrect . Note that 'A' and 'a' are treated as two different characters . Source link Best practice ‰ΩøÁî®ÈòüÂàó„ÄÇ C++ version class Solution { public : string frequencySort ( string s ) { vector < int > m ( 256 , 0 ); priority_queue < pair < int , char > > pq ; for ( int i = 0 ; i < s . length (); i ++ ) m [ s [ i ]] ++ ; for ( int i = 0 ; i < 256 ; i ++ ) pq . push ( make_pair ( m [ i ], i )); string ans ; while ( pq . size ()){ ans . append ( pq . top (). first , pq . top (). second ); pq . pop (); } return ans ; } }; Mark: 12ms pythonÁâàÊú¨‰ΩøÁî®‰∫ÜsortedÂáΩÊï∞Âπ∂ÈÄöËøáopteratorÂ∫ìÁöÑitemgetterÂáΩÊï∞Êù•ÊèêÈ´òÊ£ÄÁ¥¢Â≠óÂÖ∏ÊïàÁéá„ÄÇstring‰πòÊ≥ïÂàôÊòØpythonÁöÑÂè¶‰∏Ä‰∏™ÁâπÊÄß„ÄÇ python version from operator import itemgetter class Solution ( object ): def frequencySort ( self , s ): \"\"\" :type s: str :rtype: str \"\"\" dct = {} result = \"\" for item in s : dct [ item ] = dct . get ( item , 0 ) + 1 for item in sorted ( dct . items (), key = itemgetter ( 1 ), reverse = True ): result += item [ 0 ] * item [ 1 ] return result Mark: 76ms Additional","tags":"C,Python","title":"LeetCode - Sort Characters by Frequency"},{"url":"complex-number-multiplication.html","text":"Description Given two strings representing two complex numbers. You need to return a string representing their multiplication. Note $$i&#94;2 = -1$$ according to the definition. Example 1: Input: \"1+1i\", \"1+1i\" Output: \"0+2i\" Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i. Example 2: Input: \"1+-1i\", \"1+-1i\" Output: \"0+-2i\" Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i. Note: 1. The input strings will not have extra blank. 2. The input strings will be given in the form of a+bi , where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form. Source link Best practice Âú®c++‰∏≠‰ΩøÁî®StringstreamÊù•ÊèêÂèñÂ≠óÁ¨¶‰∏≤‰∏≠ÁöÑ‰ø°ÊÅØ„ÄÇ C++ version class Solution { public : string complexNumberMultiply ( string a , string b ) { int ra , ia , rb , ib ; char buff ; stringstream aa ( a ), bb ( b ), ans ; aa >> ra >> buff >> ia >> buff ; bb >> rb >> buff >> ib >> buff ; ans << ra * rb - ia * ib << \"+\" << ra * ib + rb * ia << \"i\" ; return ans . str (); } }; Mark: Python version -- use re class Solution ( object ): def complexNumberMultiply ( self , a , b ): \"\"\" :type a: str :type b: str :rtype: str \"\"\" pattern = re . compile ( r '([\\-0-9]*)\\+([\\-0-9]*)i' ) la = [ int ( item ) for item in pattern . search ( a ) . groups ()] lb = [ int ( item ) for item in pattern . search ( b ) . groups ()] lc = [ la [ 0 ] * lb [ 0 ] - la [ 1 ] * lb [ 1 ], la [ 0 ] * lb [ 1 ] + la [ 1 ] * lb [ 0 ]] return ' {} + {} i' . format ( * lc ) Mark: 36ms Additional","tags":"C,Python","title":"Complex Number Multiplication"},{"url":"leetcode-merge-two-binary-trees.html","text":"Description Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: Input : Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 Output : Merged tree : 3 / \\ 4 5 / \\ \\ 5 4 7 Note: The merging process must start from the root nodes of both trees. Source link Best practice Áî®ÈÄíÂΩíÁöÑÊñπÊ≥ïÊù•ÂêàÂπ∂‰∏§Ê†ëÔºöÂ¶ÇÊûú‰∏ÄÊ†ë‰ªªÊÑèËäÇÁÇπ‰∏çÂ≠òÂú®ÂàôËøîÂõûÂè¶‰∏Ä‰∏™Ê†ëÁöÑËäÇÁÇπÔºàÂ¶ÇÊûúÈÉΩ‰∏∫Á©∫ÂàôËøîÂõû‰∏Ä‰∏™Á©∫ËäÇÁÇπÔºåÂæàÂêàÁêÜÔºâ„ÄÇÂ¶ÇÊûúÈÉΩÂ≠òÂú®ÂàôÁîüÊàêÊñ∞ËäÇÁÇπÂÖ∂ÂÄº‰∏∫‰∏§Ê†ëËäÇÁÇπÂÄºÂæóÂíå„ÄÇ TreeNode *node =new TreeNode(t1->val + t2->val); ËøîÂõû‰∏Ä‰∏™TreeNodeÊåáÈíà„ÄÇ C++ version class Solution { public : TreeNode * mergeTrees ( TreeNode * t1 , TreeNode * t2 ) { if ( ! t1 ) return t2 ; if ( ! t2 ) return t1 ; TreeNode * node = new TreeNode ( t1 -> val + t2 -> val ); node -> left = mergeTrees ( t1 -> left , t2 -> left ); node -> right = mergeTrees ( t1 -> right , t2 -> right ); return node ; } }; Mark: 10ms Additional","tags":"C","title":"LeetCode - Merge Two Binary Trees"},{"url":"leetcode-single-number-iii.html","text":"Description Given an array of numbers nums , in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: Given nums = [1, 2, 1, 3, 2, 5]``, return ``[3, 5] . Note: The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? Source link Best practice Once again, we need to use XOR to solve this problem. But this time, we need to do it in two passes: In the first pass, we XOR all elements in the array, and get the XOR of the two numbers we need to find. Note that since the two numbers are distinct, so there must be a set bit (that is, the bit with value '1') in the XOR result. Find out an arbitrary set bit (for example, the rightmost set bit). In the second pass, we divide all numbers into two groups, one with the aforementioned bit set, another with the aforementinoed bit unset. Two different numbers we need to find must fall into thte two distrinct groups. XOR numbers in each group, we can find a number in either group. C++ version class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { // Pass 1 : //Get the XOR of the two numbers we need to find int diff = accumulate ( nums . begin (), nums . end (), 0 , bit_xor < int > ()); // Get its last set bit diff &= - diff ; // Pass 2 : vector < int > rets = { 0 , 0 }; // this vector stores the two numbers we will return for ( int num : nums ) { if (( num & diff ) == 0 ) // the bit is not set { rets [ 0 ] &#94;= num ; } else // the bit is set { rets [ 1 ] &#94;= num ; } } return rets ; } }; Python version class Solution ( object ): def singleNumber ( self , nums ): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" diff = reduce ( lambda x , y : x &#94; y , nums ) diff &= - diff a = b = 0 for item in nums : if item & diff : a &#94;= item else : b &#94;= item return [ a , b ] Mark: 49ms Additional","tags":"C","title":"LeetCode - Single Number III"},{"url":"python-dan-li-shi-xian-de-ji-chong-fang-shi.html","text":"Python Singleton Metaclass Decorator category: Python make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. Description Âçï‰æãÊ®°Âºè Ôºå‰πüÂè´ ÂçïÂ≠êÊ®°Âºè ÔºåÊòØ‰∏ÄÁßçÂ∏∏Áî®ÁöÑËΩØ‰ª∂ËÆæËÆ°Ê®°Âºè„ÄÇÂú®Â∫îÁî®Ëøô‰∏™Ê®°ÂºèÊó∂ÔºåÂçï‰æãÂØπË±°ÁöÑÁ±ªÂøÖÈ°ª‰øùËØÅÂè™Êúâ‰∏Ä‰∏™ÂÆû‰æãÂ≠òÂú®„ÄÇËÆ∏Â§öÊó∂ÂÄôÊï¥‰∏™Á≥ªÁªüÂè™ÈúÄË¶ÅÊã•Êúâ‰∏Ä‰∏™ÁöÑÂÖ®Â±ÄÂØπË±°ÔºåËøôÊ†∑ÊúâÂà©‰∫éÊàë‰ª¨ÂçèË∞ÉÁ≥ªÁªüÊï¥‰ΩìÁöÑË°å‰∏∫„ÄÇÊØîÂ¶ÇÂú®Êüê‰∏™ÊúçÂä°Âô®Á®ãÂ∫è‰∏≠ÔºåËØ•ÊúçÂä°Âô®ÁöÑÈÖçÁΩÆ‰ø°ÊÅØÂ≠òÊîæÂú®‰∏Ä‰∏™Êñá‰ª∂‰∏≠ÔºåËøô‰∫õÈÖçÁΩÆÊï∞ÊçÆÁî±‰∏Ä‰∏™Âçï‰æãÂØπË±°Áªü‰∏ÄËØªÂèñÔºåÁÑ∂ÂêéÊúçÂä°ËøõÁ®ã‰∏≠ÁöÑÂÖ∂‰ªñÂØπË±°ÂÜçÈÄöËøáËøô‰∏™Âçï‰æãÂØπË±°Ëé∑ÂèñËøô‰∫õÈÖçÁΩÆ‰ø°ÊÅØ„ÄÇËøôÁßçÊñπÂºèÁÆÄÂåñ‰∫ÜÂú®Â§çÊùÇÁéØÂ¢É‰∏ãÁöÑÈÖçÁΩÆÁÆ°ÁêÜ„ÄÇ ÂÆûÁé∞Âçï‰æãÊ®°ÂºèÁöÑÊÄùË∑ØÊòØÔºö‰∏Ä‰∏™Á±ªËÉΩËøîÂõûÂØπË±°‰∏Ä‰∏™ÂºïÁî®(Ê∞∏ËøúÊòØÂêå‰∏Ä‰∏™)Âíå‰∏Ä‰∏™Ëé∑ÂæóËØ•ÂÆû‰æãÁöÑÊñπÊ≥ïÔºàÂøÖÈ°ªÊòØÈùôÊÄÅÊñπÊ≥ïÔºåÈÄöÂ∏∏‰ΩøÁî®getInstanceËøô‰∏™ÂêçÁß∞ÔºâÔºõÂΩìÊàë‰ª¨Ë∞ÉÁî®Ëøô‰∏™ÊñπÊ≥ïÊó∂ÔºåÂ¶ÇÊûúÁ±ªÊåÅÊúâÁöÑÂºïÁî®‰∏ç‰∏∫Á©∫Â∞±ËøîÂõûËøô‰∏™ÂºïÁî®ÔºåÂ¶ÇÊûúÁ±ª‰øùÊåÅÁöÑÂºïÁî®‰∏∫Á©∫Â∞±ÂàõÂª∫ËØ•Á±ªÁöÑÂÆû‰æãÂπ∂Â∞ÜÂÆû‰æãÁöÑÂºïÁî®Ëµã‰∫àËØ•Á±ª‰øùÊåÅÁöÑÂºïÁî®ÔºõÂêåÊó∂Êàë‰ª¨ËøòÂ∞ÜËØ•Á±ªÁöÑÊûÑÈÄ†ÂáΩÊï∞ÂÆö‰πâ‰∏∫ÁßÅÊúâÊñπÊ≥ïÔºåËøôÊ†∑ÂÖ∂‰ªñÂ§ÑÁöÑ‰ª£Á†ÅÂ∞±Êó†Ê≥ïÈÄöËøáË∞ÉÁî®ËØ•Á±ªÁöÑÊûÑÈÄ†ÂáΩÊï∞Êù•ÂÆû‰æãÂåñËØ•Á±ªÁöÑÂØπË±°ÔºåÂè™ÊúâÈÄöËøáËØ•Á±ªÊèê‰æõÁöÑÈùôÊÄÅÊñπÊ≥ïÊù•ÂæóÂà∞ËØ•Á±ªÁöÑÂîØ‰∏ÄÂÆû‰æã„ÄÇ Âçï‰æãÊ®°ÂºèÂú®Â§öÁ∫øÁ®ãÁöÑÂ∫îÁî®Âú∫Âêà‰∏ãÂøÖÈ°ªÂ∞èÂøÉ‰ΩøÁî®„ÄÇÂ¶ÇÊûúÂΩìÂîØ‰∏ÄÂÆû‰æãÂ∞öÊú™ÂàõÂª∫Êó∂ÔºåÊúâ‰∏§‰∏™Á∫øÁ®ãÂêåÊó∂Ë∞ÉÁî®ÂàõÂª∫ÊñπÊ≥ïÔºåÈÇ£‰πàÂÆÉ‰ª¨ÂêåÊó∂Ê≤°ÊúâÊ£ÄÊµãÂà∞ÂîØ‰∏ÄÂÆû‰æãÁöÑÂ≠òÂú®Ôºå‰ªéËÄåÂêåÊó∂ÂêÑËá™ÂàõÂª∫‰∫Ü‰∏Ä‰∏™ÂÆû‰æãÔºåËøôÊ†∑Â∞±Êúâ‰∏§‰∏™ÂÆû‰æãË¢´ÊûÑÈÄ†Âá∫Êù•Ôºå‰ªéËÄåËøùÂèç‰∫ÜÂçï‰æãÊ®°Âºè‰∏≠ÂÆû‰æãÂîØ‰∏ÄÁöÑÂéüÂàô„ÄÇ Ëß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢òÁöÑÂäûÊ≥ïÊòØ‰∏∫ÊåáÁ§∫Á±ªÊòØÂê¶Â∑≤ÁªèÂÆû‰æãÂåñÁöÑÂèòÈáèÊèê‰æõ‰∏Ä‰∏™‰∫íÊñ•ÈîÅ(ËôΩÁÑ∂ËøôÊ†∑‰ºöÈôç‰ΩéÊïàÁéá)„ÄÇ Implementation newÊñπÊ≥ï newÊñπÊ≥ï class Singleton ( object ): def __new__ ( cls , * args , ** kw ): if not hasattr ( cls , '_instance' ): orig = super ( Singleton , cls ) cls . _instance = orig . __new__ ( cls , * args , ** kw ) return cls . _instance class MyClass ( Singleton ): a = 1 metaclassÊñπÊ≥ï Ë¶ÜÁõñ init Á±ª class Singleton ( type ): def __init__ ( cls , * args , ** kwargs ): cls . __instance = None super () . __init__ ( * args , ** kwargs ) def __call__ ( cls , * args , ** kwargs ): if cls . __instance is None : cls . __instance = super () . __call__ ( * args , ** kwargs ) return cls . __instance class Spam ( metaclass = Singleton ): def __init__ ( self ): print ( 'Creating Spam' ) a = Spam () b = Spam () print ( a is b ) Ë¶ÜÁõñ new Á±ª class Singleton ( type ): def __new__ ( cls , name , base , dct ): dct [ '_instance' ] = None return super () . __new__ ( cls , name , base , dct ) def __call__ ( cls , * args , ** kwargs ): if cls . _instance is None : cls . _instance = super () . __call__ ( * args , ** kwargs ) return cls . _instance class Spam ( metaclass = Singleton ): def __init__ ( self ): print ( 'Creating Spam' ) a = Spam () b = Spam () print ( a is b ) decoratorÊñπÊ≥ï def singleton ( cls , * args , ** kw ): instances = {} def getinstance (): if cls not in instances : instances [ cls ] = cls ( * args , ** kw ) return instances [ cls ] return getinstance @singleton class MyClass : ... importÊñπÊ≥ï ### mysingleton.py class My_Singleton ( object ): def foo ( self ): pass my_singleton = My_Singleton () ### to use from mysingleton import my_singleton my_singleton . foo () Additional","tags":"posts","title":"Python Âçï‰æãÂÆûÁé∞ÁöÑÂá†ÁßçÊñπÂºè"},{"url":"leetcode-minimum-moves-to-equal-array-elements-ii.html","text":"Description Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. You may assume the array's length is at most 10,000 . Example: ** Input : ** [ 1 , 2 , 3 ] ** Output : ** 2 ** Explanation : ** Only two moves are needed ( remember each move increments or decrements one element ): [ 1 , 2 , 3 ] => [ 2 , 2 , 3 ] => [ 2 , 2 , 2 ] Source link Best practice ÊàëÂíãËßâÂæóÊò®Â§©ÁöÑÊØîËæÉÂ§çÊùÇ„ÄÇ ÈúÄË¶ÅÁî®Âà∞algorithmsÂ∫ìÁöÑsortÂáΩÊï∞„ÄÇ‰∏≠Èó¥Â∫èÂè∑ÁöÑÊï∞ÁöÑÂÄº‰∏∫Êï∞ÂàóÁöÑÁõÆÊ†áÂèòÂåñÂÄº„ÄÇMinimum movesÁ≠â‰∫éÊâÄÊúâÂÖÉÁ¥†‰∏éËØ•ÁõÆÊ†áÂèòÂåñÂÄºÁöÑÂ∑ÆÂÄº‰πãÂíå„ÄÇ C++ class Solution { public : int minMoves2 ( vector < int >& nums ) { sort ( nums . begin (), nums . end ()); int mid = nums [ floor ( nums . size () / 2 )]; int result = 0 ; for ( auto i : nums ) { result += abs ( i - mid ); } return result ; } }; Mark: 19ms Additional","tags":"C","title":"LeetCode - Minimum Moves to Equal Array Elements II"},{"url":"leetcode-minimum-index-sum-of-two-lists.html","text":"Description Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum . If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer. Example 1: Input: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"] Output: [\"Shogun\"] Explanation: The only restaurant they both like is \"Shogun\". Example 2: Input: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"KFC\", \"Shogun\", \"Burger King\"] Output: [\"Shogun\"] Explanation: The restaurant they both like and have the least index sum is \"Shogun\" with index sum 1 (0+1). Note: 1. The length of both lists will be in the range of [1, 1000]. 2. The length of strings in both lists will be in the range of [1, 30]. 3. The index is starting from 0 to the list length minus 1. 4. No duplicates in both lists. Source link Best practice È¶ñÂÖà‰ª•Á¨¨‰∏Ä‰∏™ÂàóË°®Âª∫‰∏Ä‰∏™‰ª•index‰∏∫keyÔºåstring‰∏∫itemÁöÑÂìàÂ∏åË°®„ÄÇ ÁÑ∂ÂêéÈÅçÂéÜÁ¨¨‰∫å‰∏™ÂàóË°®ÔºåÂΩì‰∏§‰∏™ÂàóË°®ÁöÑindexÂíåÊØî‰πãÂâçÂ∞èÊó∂Âà∑Êñ∞ËæìÂá∫ÂàóË°®ÔºåÁõ∏Á≠âÊó∂Âú®ËæìÂá∫ÂàóË°®ÂêéÊ∑ªÂä†Á¨¨‰∫å‰∏™ÂàóË°®ÁúüÁöÑstring„ÄÇ C++ : hash table class Solution { public : int max_int = 2147483647 ; vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > result ; unordered_map < string , int > hashtable ; int count1 = list1 . size (); int count2 = list2 . size (); for ( int i = 0 ; i < count1 ; i ++ ) { hashtable [ list1 [ i ]] = i ; } for ( int i = 0 ; i < count2 ; i ++ ) { int j = hashtable . count ( list2 [ i ]) > 0 ? hashtable [ list2 [ i ]] : - 1 ; if ( j != - 1 && i + j <= max_int ) { if ( i + j < max_int ) { result . clear (); max_int = i + j ; } result . push_back ( list2 [ i ]); } } return result ; } }; Mark: 92ms Additional","tags":"C","title":"LeetCode - Minimum Index Sum of Two Lists"},{"url":"leetcode-invert-binary-tree.html","text":"Description Invert a binary tree. 4 / \\ 2 7 / \\ / \\ 1 3 6 9 to 4 / \\ 7 2 / \\ / \\ 9 6 3 1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can't invert a binary tree on a whiteboard so fuck off. Source link Best practice ÂæàÂÆπÊòìÂ∞±ËÉΩÊÉ≥Âà∞Áî®ÈÄíÂΩíÁöÑÊñπÂºèÔºåÂÆûÈôÖ‰∏ÄÂÅöÈùûÂ∏∏ÁÆÄÂçï„ÄÇË¢´Ëøô‰∏™ËÄÅÂì•ÊÄºÁöÑË∞∑Ê≠åÂÜÖÂøÉ‰∏ÄÂÆöÊÑüÂà∞ÂæàÂßîÂ±àÂêß„ÄÇ C++ -- recursion class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( root != NULL ) { invertTree ( root -> left ); invertTree ( root -> right ); swap ( root -> left , root -> right ); } return root ; } }; Mark: 3ms ËøôÊòØ‰∏Ä‰∏™Áî®ÈòüÂàóÂÇ®Â≠ò‰∫åÂèâÊ†ëËäÇÁÇπÁöÑÈùûÈÄíÂΩíÁÆóÊ≥ïÔºåÂèØËÉΩ‰ºöÊØîËæÉÂø´‰∏ÄÁÇπÂêß„ÄÇ C++ -- queue class Solution { public : TreeNode * invertTree ( TreeNode * root ) { queue < TreeNode *> record ; record . push ( root ); while ( ! record . empty ()){ TreeNode * node = record . front (); record . pop (); if ( node != NULL ){ record . push ( node -> left ); record . push ( node -> right ); swap ( node -> left , node -> right ); } } return root ; } }; Mark: 0ms Additional","tags":"C","title":"LeetCode - Invert binary tree"},{"url":"zong-jie-ru-he-yong-wei-yun-suan-lai-jian-dan-gao-xiao-di-jie-jue-wen-ti.html","text":"Question Calculate the sum of two integers a and b, but you are not allowed to use the operator + and - . Example: Given a = 1 and b = 2, return 3. Source link ÁÆÄ‰ªã ‰ΩçËøêÁÆóÊòØÊåáÁî®ÁÆóÊ≥ïÊù•Êìç‰ΩúÊØîÁâπÊàñËÄÖÂÖ∂‰ªñÂ∞è‰∫é‰∏Ä‰∏™Â≠óÊØçÁöÑÊï∞ÊçÆ. Â∏∏ËßÅÁöÑÈúÄË¶ÅÂà©Áî®‰ΩçËøêÁÆóÂÆûÁé∞ÁöÑÁºñÁ®ã‰ªªÂä°ÊúâÔºöÂ∫ïÂ±ÇËÆæÂ§áÊéßÂà∂„ÄÅÈîôËØØÊ£ÄÊµãÂíåÁü´Ê≠£ÁÆóÊ≥ï„ÄÅÊï∞ÊçÆÂéãÁº©„ÄÅÂä†ÂØÜÁÆóÊ≥ïÂèä‰ºòÂåñÁÆóÊ≥ï. ÂØπ‰∫éÂÖ∂‰ªñÂ§ßÈÉ®ÂàÜ‰ªªÂä°ËÄåË®ÄÔºå Áé∞‰ª£ÁºñÁ®ãËØ≠Ë®ÄÈÄöÂ∏∏ÂÖÅËÆ∏Á®ãÂ∫èÂëòË∑üÊäΩË±°ÂåñÁöÑ‰ΩçËøêÁÆó‰∫§‰∫íËÄåÈùûÁõ¥Êé•‰ΩøÁî®‰ΩçËøêÁÆó. ‰ΩçËøêÁÆóÈÄöÂ∏∏ÂåÖÂê´‰ª•‰∏ãÊìç‰ΩúÁ¨¶: AND, OR, XOR, NOTÂíåbit shifts. Âú®Êüê‰∫õÊÉÖÂÜµ‰∏ãÔºåÁî±‰∫é‰ΩçÊìç‰ΩúÊòØÂπ∂Ë°åËøõË°åÁöÑÔºå Âõ†Ê≠§ÈÄöÂ∏∏ËÉΩÂ§üÂéªÈô§ÊàñËÄÖÂáèÂ∞ëÂØπ‰∏Ä‰∏™Êï∞ÊçÆÊ†ºÂºèÁöÑÂæ™ÁéØÈÅçÂéÜÔºå Â∏¶Êù•ËøêÁÆóÈÄüÂ∫¶ÁöÑÊàêÂÄçÊèêÂçá. ‰ΩÜ‰∏éÊ≠§ÂêåÊó∂Ôºå ‰ΩçÊìç‰ΩúÁöÑ‰ª£Á†Å‰πü‰ºöÊõ¥ÈöæÁºñÂÜôÂíåÁª¥Êä§„ÄÇ ËØ¶ÁªÜÂÜÖÂÆπ Âü∫Á°Ä ‰ΩçÊìç‰ΩúÁöÑÊ†∏ÂøÉÊòØ‰ΩçËøêÁÆóÁ¨¶ & (‰∏é), | (Êàñ), ~ (Èùû) and &#94; (ÂºÇÊàñ) Âíå Áßª‰ΩçÊìç‰Ωú a << b and a >> b. ÂºÇÊàñËøêÁÆóÁ¨¶Ê≤°ÊúâÂØπÂ∫îÁöÑÂ∏ÉÂ∞îËøêÁÆóÁ¨¶ÔºåÂú®ËøôÈáåÊàë‰ª¨ÂØπÂÆÉ‰Ωú‰∏Ä‰∏™ÁÆÄÂçïÁöÑËß£Èáä. ÂºÇÊàñÊìç‰ΩúÁ¨¶Êé•Âèó‰∏§‰∏™ËæìÂÖ•ÔºåÂΩì‰∏î‰ªÖÂΩìÊúâ‰∏îÂè™Êúâ‰∏Ä‰∏™ËæìÂÖ•‰∏∫1ÁöÑÊó∂ÂÄôÂÆÉÊâç‰ºöËøîÂõû1. ‰πüÂ∞±ÊòØÂΩì‰∏§‰∏™ËæìÂÖ•‰∏çÂêåÁöÑÊó∂ÂÄôËøîÂõû1ÔºåÁõ∏ÂêåÁöÑÊó∂ÂÄôÂ∞±‰ºöËøîÂõû0. ÂºÇÊàñÊìç‰ΩúÁ¨¶ÈÄöÂ∏∏Áî®&#94;Á¨¶Âè∑Ë°®Á§∫ÔºåÁº©ÂÜô‰∏∫XOR. Set Âπ∂ÈõÜ A | B Set ‰∫§ÈõÜ A & B Set Â∑ÆÈõÜ A & ~B Set ÈùûÈõÜ ALL_BITS&#94; A or ~A Â∞ÜAÁöÑÁ¨¨bit‰ΩçËÆæ‰∏∫1 A |= 1 << bit Â∞ÜAÁöÑÁ¨¨bit‰ΩçËÆæ‰∏∫0 `A &= ~(1 << bit)`` ÊµãËØïÁ¨¨bit‰ΩçÊòØÂê¶‰∏∫0 (A & 1 << bit) != 0 ÂèñÂá∫ÊúÄÂêé1ÁöÑÂÄº A&-A or A&~(A-1) or x&#94;(x&(x-1)) Âà†Èô§ÊúÄÂêé1ÁöÑÂÄº A&(A-1) ÊûÑÂª∫ÂÖ®‰∏∫1ÁöÑ‰∫åËøõÂà∂Êï∞ ~0 (((unsigned)~0) >> 1 == 01111111111111111111111111111111) Ë¥üÊï∞ÁöÑËøêÁÆóÊòØ‰ª•Ë°•Á†ÅÂΩ¢ÂºèËøõË°åÁöÑÔºåÂ¶ÇÊûúËøêÁÆóÁªìÊûúÈ¶ñ‰Ωç‰∏∫1ÔºåÁªìÊûú‰πüÈúÄË¶ÅÊ±Ç‰∏ÄÊ¨°Ë°•Á†Å. ÂÆû‰æã Ê±ÇÊâÄÁªôÊï∞Â≠ó‰∫åËøõÂà∂Ë°®Á§∫‰∏≠ÁöÑ1ÁöÑÊï∞ÈáèÔºö int count_one ( int n ) { while ( n ) { n = n & ( n - 1 ); count ++ ; } return count ; } ÊòØ4ÁöÑÂπÇÊï∞ÂòõÔºü (‰∫ãÂÆû‰∏äÂõæÊ£ÄÊü•ÊñπÊ≥ï„ÄÅ Ëø≠‰ª£ÂíåÈÄíÂΩíÂèØ‰ª•ÂÅöÂà∞‰∏ÄÊ†∑ÁöÑÊïàÊûú) bool isPowerOfFour ( int n ) { return ! ( n & ( n - 1 )) && ( n & 0x55555555 ); //Âè™Êúâ‰∏Ä‰∏™1‰Ωç(0x55555555 =1010101010101010101010101010101); } &#94; ÁöÑÊäÄÂ∑ß &#94; ÂèØ‰ª•Áî®Êù•Ê∂àÈô§ÂÅ∂Êï∞‰∏™‰∏™‰∏ÄÊ®°‰∏ÄÊ†∑ÁöÑÊï∞Â≠óÂπ∂‰∏î‰øùÁïôÂ•áÊï∞ÁöÑÊï∞Â≠óÂØπ, ÊàñËÄÖ‰øùÂ≠ò‰∏ç‰∏ÄÊ†∑ÁöÑÂØπÂ∫î‰ΩçÂπ∂‰∏îÁßªÈô§‰∏ÄÊ†∑ÁöÑÂØπÂ∫î‰Ωç. ‰∏§Êï∞Ê±ÇÂíå ‰ΩøÁî® &#94; Âíå & Êù•ËøõË°å‰∏§Êï∞Ê±ÇÂíå int getSum ( int a , int b ) { return b == 0 ? a : getSum ( a &#94; b , ( a & b ) << 1 ); //Ê≥®ÊÑèÁªàÊ≠¢Êù°‰ª∂Ôºå(0,1)ÂØπÂ∫î‰Ωç‰∏∫1Ôºå(1,1)ÂØπÂ∫î‰ΩçËøõ‰Ωç; } ‰∏¢Â§±ÁöÑÊï∞Â≠ó Â∑≤Áü•‰∏Ä‰∏™Êï∞ÁªÑÂåÖÂê´n‰∏™‰∏çÂêåÁöÑÊï∞Â≠óÔºö 0, 1, 2, ..., n, ÊâæÂà∞ÈÇ£‰∏™‰∏çÂú®Êï∞ÁªÑ‰∏≠ÁöÑÊï∞Â≠ó„ÄÇ ‰æãÂ¶Ç, ÊâÄÁªôÊï∞ÁªÑ = [0, 1, 3] ÂàôËøîÂõû 2. int missingNumber ( vector < int >& nums ) { int ret = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { ret &#94;= i ; ret &#94;= nums [ i ]; } return ret &#94;= nums . size (); } | ÁöÑÊäÄÂ∑ß ‰øùÂ≠òÂ∞ΩÂèØËÉΩÂ§öÁöÑ1‰Ωç ÊâæÂà∞Â∞è‰∫éÊàñÁ≠â‰∫éNÁöÑ2ÁöÑÊúÄÂ§ßÁöÑÂπÇÊï∞ (ÊúÄÂ§ß‰∫åËøõÂà∂Êï∞). long largest_power ( long N ) { //Â∞ÜÊâÄÊúâÂè≥‰æßÁöÑ‰Ωç ÁΩÆ‰∏∫ 1. N = N | ( N >> 1 ); N = N | ( N >> 2 ); N = N | ( N >> 4 ); N = N | ( N >> 8 ); N = N | ( N >> 16 ); return ( N + 1 ) >> 1 ; } ÂèçËΩ¨ÊØîÁâπ ÂèçËΩ¨‰∏Ä‰∏™ÊâÄÁªôÁöÑ 32 bits unsigned integer. uint32_t reverseBits ( uint32_t n ) { unsigned int mask = 1 << 31 , res = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { if ( n & 1 ) res |= mask ; mask >>= 1 ; n >>= 1 ; } return res ; } uint32_t reverseBits ( uint32_t n ) { uint32_t mask = 1 , ret = 0 ; for ( int i = 0 ; i < 32 ; ++ i ){ ret <<= 1 ; if ( mask & n ) ret |= 1 ; mask <<= 1 ; } return ret ; } & ÁöÑÊäÄÂ∑ß & ÂÖ∑ÊúâÈÄâÊã©ÊåáÂÆöÁöÑ‰ΩçÁöÑÂäüËÉΩ„ÄÇ ÂèçËΩ¨Êï¥Êï∞‰∏≠ÁöÑ‰Ωç x = (( x & 0xaaaaaaaa ) >> 1 ) | (( x & 0x55555555 ) << 1 ); x = (( x & 0xcccccccc ) >> 2 ) | (( x & 0x33333333 ) << 2 ); x = (( x & 0xf0f0f0f0 ) >> 4 ) | (( x & 0x0f0f0f0f ) << 4 ); x = (( x & 0xff00ff00 ) >> 8 ) | (( x & 0x00ff00ff ) << 8 ); x = (( x & 0xffff0000 ) >> 16 ) | (( x & 0x0000ffff ) << 16 ); ‰ΩçËøêÁÆóÁ¨¶ AND Êï∞Â≠óËåÉÂõ¥ Â∑≤Áü•ËåÉÂõ¥ [m, n] ÂÖ∂‰∏≠ 0 <= m <= n <= 2147483647, ËøîÂõûÂØπËåÉÂõ¥‰∏≠ÁöÑÊâÄÊúâÊï∞ÊçÆÊåâ‰ΩçËÆ°ÁÆóÁ¨¶ANDËÆ°ÁÆóÁöÑÁªìÊûú„ÄÇ ‰æãÂ¶Ç, ËæìÂÖ• [5, 7], ÂàôËøîÂõû 4. int rangeBitwiseAnd ( int m , int n ) { int a = 0 ; while ( m != n ) { m >>= 1 ; n >>= 1 ; a ++ ; } return m << a ; } 1ÁöÑÊï∞Èáè int hammingWeight ( uint32_t n ) { ulong mask = 1 ; int count = 0 ; for ( int i = 0 ; i < 32 ; ++ i ){ //31 will not do, delicate; if ( mask & n ) count ++ ; mask <<= 1 ; } return count ; } Â∫îÁî® ÈáçÂ§çDNAÂ∫èÂàó ÊâÄÊúâDNAÁî±‰∏ÄÁ≥ªÂàóÁº©ÂÜô‰∏∫A„ÄÅG„ÄÅC„ÄÅTÁöÑÊ†∏Ëã∑ÈÖ∏ÁªÑÊàê, ‰æãÂ¶Ç: \"ACGAATTCCG\". ÂΩìÁ†îÁ©∂DNAÂ∫èÂàóÁöÑÊó∂ÂÄôÔºåDNA‰∏≠ÁöÑÈáçÂ§çÂ∫èÂàóÊòØ‰∏Ä‰∏™ÂæàÈáçË¶ÅÁöÑÁöÑÈÉ®ÂàÜ. ÁºñÂÜô‰∏Ä‰∏™ÂáΩÊï∞Êù•ÊâæÂà∞Âá∫Áé∞Â§ö‰∫é‰∏§Ê¨°ÁöÑÂçÅÂ≠óÁ¨¶ÈïøÂ∫¶Â∫èÂàó„ÄÇ ‰æãÂ¶Ç, ÁªôÂá∫ s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\", ËøîÂõû: [\"AAAAACCCCC\", \"CCCCCAAAAA\"]. class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { int sLen = s . length (); vector < string > v ; if ( sLen < 11 ) return v ; char keyMap [ 1 << 21 ]{ 0 }; int hashKey = 0 ; for ( int i = 0 ; i < 9 ; ++ i ) hashKey = ( hashKey << 2 ) | ( s [ i ] - 'A' + 1 ) % 5 ; for ( int i = 9 ; i < sLen ; ++ i ) { if ( keyMap [ hashKey = (( hashKey << 2 ) | ( s [ i ] - 'A' + 1 ) % 5 ) & 0xfffff ] ++ == 1 ) v . push_back ( s . substr ( i - 9 , 10 )); } return v ; } }; ‰ª•‰∏äÊñπÊ≥ï‰ºöÂú®ÈáçÂ§çÂ∫èÂàóÂá∫Áé∞Â§™Â§öÊ¨°Êó∂ÂÄôÂ§±Êïà„ÄÇ ‰∏∫‰∫ÜÈÅøÂÖçËøôÁßçÊÉÖÂÜµÁöÑÂèëÁîüÔºåÊàë‰ª¨ÂèØ‰ª•‰ΩøÁî® unordered_map<int, int> keyMap Êù•Êõø‰ª£ËøôÈáåÁöÑ char keyMap[1<<21]{0} . ‰∏ªÂÖÉÁ¥† ÂØπ‰∫é‰∏Ä‰∏™Â§ßÂ∞è‰∏∫nÁöÑÊï∞ÁªÑÔºåÊ±ÇÂÖ∂‰∏ªÂÖÉÁ¥†. ‰∏ªÂÖÉÁ¥†ÊòØÂú®Êï∞ÁªÑ‰∏≠Âá∫Áé∞Ê¨°Êï∞Â§ß‰∫é ‚åä n/2 ‚åã Ê¨°ÁöÑÂÖÉÁ¥†. (ÊØîÁâπËÆ°Êï∞ÊòØ‰∏çÊòØ‰∏Ä‰∏™ÈÄöÂ∏∏ÊñπÊ≥ï, Êàë‰ª¨ÈÄöÂ∏∏‰ºöÂ∫îÁî®ÊéíÂ∫èÂíåMoore VotingÁÆóÊ≥ï) int majorityElement ( vector < int >& nums ) { int len = sizeof ( int ) * 8 , size = nums . size (); * int count = 0 , mask = 1 , ret = 0 ; for ( int i = 0 ; i < len ; ++ i ) { count = 0 ; for ( int j = 0 ; j < size ; ++ j ) if ( mask & nums [ j ]) count ++ ; if ( count > size / 2 ) ret |= mask ; mask <<= 1 ; } return ret ; } Âçï‰∏ÄÊï∞Â≠ó III ÂØπ‰∫éÁªô‰∫àÁöÑ‰∏Ä‰∏™Êï¥Êï∞Êï∞ÁªÑ, Èô§‰∫Ü‰∏Ä‰∏™ÂÖÉÁ¥†‰ª•Â§ñÁöÑÊâÄÊúâÂÖÉÁ¥†‰ºöÂá∫Áé∞‰∏âÊ¨°Ôºå‰Ω†ÁöÑÁõÆÊ†áÊòØÊâæÂà∞ÈÇ£‰∏™Âçï‰∏ÄÁöÑÊï∞Â≠ó. (ËøôÁßçÁ±ªÂûãÁöÑÈóÆÈ¢òÂêåÊ†∑‰πüÂèØ‰ª•Áî®ÊØîÁâπËÆ°Êï∞ÁÆÄÂçïÂú∞Ëß£ÂÜ≥Ôºå‰ΩÜÂú®ËøôÈáåÊàë‰ª¨Â∞Ü‰ΩøÁî® digital logic design Êù•Â§ÑÁêÜÂÆÉ) //inspired by logical circuit design and boolean algebra; //counter - unit of 3; //current incoming next //a b c a b //0 0 0 0 0 //0 1 0 0 1 //1 0 0 1 0 //0 0 1 0 1 //0 1 1 1 0 //1 0 1 0 0 //a = a&~b&~c + ~a&b&c; //b = ~a&b&~c + ~a&~b&c; //return a|b since the single number can appear once or twice; int singleNumber ( vector < int >& nums ) { int t = 0 , a = 0 , b = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { t = ( a &~ b &~ nums [ i ]) | ( ~ a & b & nums [ i ]); b = ( ~ a & b &~ nums [ i ]) | ( ~ a &~ b & nums [ i ]); a = t ; } return a | b ; } ÊúÄÂ§ßÂ≠óÊØçÈïøÂ∫¶ÁªÑÂêà ÂØπ‰∫éÁªô‰∫àÁöÑ‰∏ÄÁªÑÂçïËØç, ÊâæÂà∞ÂçïËØçÈïøÂ∫¶(word[i]) * length(word[j])‰πãÁßØÁöÑÊúÄÂ§ßÂÄºÔºå Ë¶ÅÊ±Ç‰∏§‰∏™ÂçïËØç‰∏çËÉΩÊúâÁõ∏ÂêåÁöÑÂ≠óÊØç. ‰Ω†ÂèØ‰ª•ÂÅáÂÆöÊâÄÊúâÂçïËØçÂè™ÂåÖÂê´Â∞èÂÜôÂ≠óÊØç. Â¶ÇÊûúÊ≤°ÊúâÁ¨¶ÂêàÊù°‰ª∂ÁöÑÂçïËØçÁªÑÂ≠òÂú®ÂàôËøîÂõû 0. Á§∫‰æã 1: Áªô‰∫à [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"] ËøîÂõû 16 Á¨¶ÂêàÊù°‰ª∂ÁöÑ‰∏§‰∏™ÂçïËØçÂèØ‰ª•ÊòØ \"abcw\", \"xtfn\". Á§∫‰æã 2: Áªô‰∫à [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"] ËøîÂõû 4 Á¨¶ÂêàÊù°‰ª∂ÁöÑ‰∏§‰∏™ÂçïËØçÂèØ‰ª•ÊòØ \"ab\", \"cd\". Á§∫‰æã 3: Áªô‰∫à [\"a\", \"aa\", \"aaa\", \"aaaa\"] ËøîÂõû 0 Ê≤°ÊúâÁ¨¶ÂêàÊù°‰ª∂ÁöÑÂçïËØçÁªÑ. ÊòæÁÑ∂Êàë‰ª¨Â∞Ü‰ºöÈ¢ëÁπÅ‰ΩøÁî®ÂçïËØçÁöÑÈïøÂ∫¶‰ª•ÂèäÊØîËæÉ‰∏§‰∏™ÂçïËØçÊòØÂê¶Êã•ÊúâÁõ∏ÂêåÁöÑÂ≠óÊØç: ‰ΩøÁî®‰∏Ä‰∏™Êï¥ÂΩ¢Êï∞ÁªÑÂéªÈ¢ÑÂ≠òÊØè‰∏™ÂçïËØçÁöÑÈïøÂ∫¶Â∞ÜËÉΩÂ§üÊúâÊïàÂáèÂ∞ëÊµãÈáèÈïøÂ∫¶Ëøô‰∏ÄËøáÁ®ãÈ¢ëÂ∫¶; Êï¥ÂΩ¢ÊòØ‰∏Ä‰∏™Âõõ‰∏™Â≠óËäÇ‰∏âÂçÅ‰∫å‰ΩçÂ≠òÂÇ®ÂçïÂÖÉ, ËÄåÊàë‰ª¨Âè™Êúâ‰∫åÂçÅÂÖ≠‰∏™‰∏çÂêåÁöÑÂ≠óÊØç, ÊâÄ‰ª•Êàë‰ª¨Â∞±ÂèØ‰ª•Áî®ÊØè‰∏Ä‰ΩçÊù•Ë°®Á§∫ÂçïËØçÊòØÂê¶ÂåÖÂê´Êüê‰∏ÄÂ≠óÊØç. int maxProduct ( vector < string >& words ) { vector < int > mask ( words . size ()); vector < int > lens ( words . size ()); for ( int i = 0 ; i < words . size (); ++ i ) lens [ i ] = words [ i ]. length (); int result = 0 ; for ( int i = 0 ; i < words . size (); ++ i ) { for ( char c : words [ i ]) mask [ i ] |= 1 << ( c - 'a' ); for ( int j = 0 ; j < i ; ++ j ) if ( ! ( mask [ i ] & mask [ j ])) result = max ( result , lens [ i ] * lens [ j ]); } return result ; } Ê≥®ÊÑè Â∑¶Âè≥‰ΩçÁßªÂ§™Â§öÁöÑËøîÂõûÂÄºÊòØ undefined ÂØπ‰∫éË¥üÊï∞ÁöÑÂè≥ÁßªÂ§™Â§öÁöÑËøîÂõûÂÄºÊòØ undefined right operand in shifting should be non-negative, otherwise the result is undefined & Âíå | ËøêÁÆóÁ¨¶Áõ∏ÂØπ‰∫éÊØîËæÉËøêÁÆóÁ¨¶Êù•ËØ¥Êã•ÊúâÊõ¥‰ΩéÁöÑ‰ºòÂÖàÁ∫ß ÈõÜÂêà ÊâÄÊúâÁöÑÂ≠êÈõÜ Âú®ËøôÁßçÊÉÖÂÜµ‰∏ã‰ΩçÊìç‰Ωú‰ºö‰ΩìÁé∞Âá∫Â∑®Â§ßÁöÑ‰ºòÂäøÔºöÂΩìÈÅçÂéÜ‰∏Ä‰∏™NÂÖÉÁ¥†ÈõÜÂêàÁöÑÊâÄÊúâÂ≠êÈõÜÊòØÈùûÂ∏∏ÁπÅÁêêÁöÑÊó∂ÂÄôÔºåËÄå‰∏Ä‰∏™N‰ΩçÊØîÁâπÂÄºËÉΩÂ§üË°®Á§∫ÂÖ∂ÊâÄÊúâÂ≠êÈõÜ„ÄÇ Â¶ÇÊûúAÊòØBÁöÑÂ≠êÈõÜÔºåÂàôË°®ËææAÊâÄÈúÄÁöÑÊï∞Â≠óÂ∞è‰∫éÁõ¥Êé•Ë°®Á§∫BÊó∂ÂÄôÔºå‰ΩçÊìç‰ΩúÂØπ‰∫é‰∏Ä‰∫õÂä®ÊÄÅÁöÑÁºñÁ®ãÊñπÊ°àÊòØ‰∏Ä‰∏™Êõ¥Â•ΩÁöÑÈÄâÊã©„ÄÇ Â¶ÇÊûú‰Ω†‰∏ç‰ªãÊÑè‰ª•ÈÄÜÂ∫èÈÅçÂéÜÂ≠êÈõÜÁöÑËØùÔºå‰Ω†‰πüÂèØ‰ª•Âú®‰∏Ä‰∏™ÁâπÂÆöÁöÑÂ≠êÈõÜÈáåÈÅçÂéÜÂà∞ÊâÄÊúâÂèØËÉΩÁöÑÂ≠êÈõÜÊòüÁü¢ (Áî®ÊØîÁâπÊ®°ÂºèË°®Á§∫). ‰ΩøÁî®ÁöÑÊäÄÂ∑ßÂíåÊâæÂà∞Êï∞Â≠ó‰∏≠ÁöÑÊúÄ‰Ωé‰ΩçÁöÑÊñπÊ≥ïÁõ∏‰ºº. Â¶ÇÊûúÊàë‰ª¨‰ªé‰∏Ä‰∏™Â≠êÈõÜ‰∏≠ÂáèÂéª1, ÂàôÈõÜÂêàÁöÑÊúÄ‰ΩéÁöÑÂÖÉÁ¥†Â∞Ü‰ºöË¢´Ê∏ÖÊ•ö, Âπ∂‰∏îÊØè‰∏™Êõ¥‰ΩéÁöÑÂÖÉÁ¥†Â∞Ü‰ºöË¢´ËÆæÁΩÆ. ÁÑ∂ËÄå, Êàë‰ª¨‰ªÖ‰ªÖÊÉ≥Ë¶ÅÂú®Áà∂ÈõÜÂêà‰∏≠ËÆæÁΩÆËøô‰∫õÊõ¥‰ΩéÁöÑÂÖÉÁ¥†. Âõ†Ê≠§ÈÅçÂéÜÁöÑÊ≠•È™§Âè™‰ºöÊòØ i = (i - 1) & superset. vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> vv ; int size = nums . size (); if ( size == 0 ) return vv ; int num = 1 << size ; vv . resize ( num ); for ( int i = 0 ; i < num ; ++ i ) { for ( int j = 0 ; j < size ; ++ j ) if (( 1 << j ) & i ) vv [ i ]. push_back ( nums [ j ]); } return vv ; } ‰∫ãÂÆû‰∏äËøòÊúâÂè¶Â§ñ‰∏§ÁßçÊñπÂºèÔºö recursion Âíå iteration ‰πüËÉΩÂàÜÂà´Ëß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò. BitsetÁ±ª BitsetÂÇ®Â≠ò‰Ωç (Âè™Êúâ‰∏§ÁßçÂèØËÉΩÂÄºÁöÑÂÖÉÁ¥†: 0 or 1, true or false, ...). Ëøô‰∏™Á±ªÊúâ‰∫õÁ±ª‰ººÂ∏ÉÂ∞îÂÄºÊï∞ÁªÑÔºå‰∏çËøáÂÖ∑ÊúâÁ©∫Èó¥‰ºòÂåñÔºöÈÄöÂ∏∏ÊØè‰∏™ÂÖÉÁ¥†Âè™Âç†‰∏Ä‰Ωç (Âú®Â§ßÈÉ®ÂàÜÁ≥ªÁªü‰∏≠ÊØîÊúÄÂ∞èÁöÑÂÖÉÁ¥†ÁßçÁ±ªÔºöcharÂ∞èÂÖ´ÂÄç). // bitset::count #include <iostream> // std::cout #include <string> // std::string #include <bitset> // std::bitset int main () { std :: bitset < 8 > foo ( std :: string ( \"10110011\" )); std :: cout << foo << \" has \" ; std :: cout << foo . count () << \" ones and \" ; std :: cout << ( foo . size () - foo . count ()) << \" zeros. \\n \" ; return 0 ; }","tags":"Python,C","title":"ÊÄªÁªìÔºöÂ¶Ç‰ΩïÁî®‰ΩçËøêÁÆóÊù•ÁÆÄÂçïÈ´òÊïàÂú∞Ëß£ÂÜ≥ÈóÆÈ¢ò"},{"url":"leetcode-find-the-difference.html","text":"Description Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t . Example: Input : s = \"abcd\" t = \"abcde\" Output : e Explanation : 'e' is the letter that was added . Source link Best practice ‰ΩøÁî®ÂºÇÊàñÂíåC++11ÁöÑÈÅçÂéÜÁâπÊÄß„ÄÇ C++ class Solution { public : char findTheDifference ( string s , string t ) { char r = 0 ; for ( char c : s ) r &#94;= c ; for ( char c : t ) r &#94;= c ; return r ; } }; Mark: 6ms Python version class Solution ( object ): def findTheDifference ( self , s , t ): \"\"\" :type s: str :type t: str :rtype: str \"\"\" asc = 0 ; for item in t : asc += ord ( item ) for item in s : asc -= ord ( item ) return chr ( asc ) class Solution ( object ): def findTheDifference ( self , s , t ): \"\"\" :type s: str :type t: str :rtype: str \"\"\" ans = 0 for c in s + t : ans &#94;= ord ( c ) return chr ( ans ) Mark: 35ms Additional","tags":"Python,C","title":"LeetCode - Find the Difference"},{"url":"leetcode-most-frequent-subtree-sum.html","text":"Description Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order. Examples 1 Input : 5 / \\ 2 - 3 return [2, -3, 4], since all the values happen only once, return all of them in any order. Examples 2 Input : 5 / \\ 2 - 5 return [2], since 2 happens twice, however -5 only occur once. Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer. Source link Best practice C++ÁöÑregÊúâÁÇπÊÖ¢Âïä! C++ reg verison /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { private : unordered_map < int , int > mp ; int max = 0 ; public : vector < int > findFrequentTreeSum ( TreeNode * root ) { vector < pair < int , int >> v ; vector < int > res ; calSum ( root ); for ( auto & it : mp ) if ( it . second == max ) res . push_back ( it . first ); return res ; } int calSum ( TreeNode * root ) { if ( root == NULL ) return 0 ; int k ; k = root -> val + calSum ( root -> left ) + calSum ( root -> right ); mp [ k ] ++ ; max = max < mp [ k ] ? mp [ k ] : max ; return k ; } }; Mark: 12ms ÊôÆÈÄöÁöÑdfsÈÅçÂéÜ,ÈÅçÂéÜÁöÑÂêåÊó∂‰øùÂ≠òÊúÄÂ§ßÂÄºÂá∫Áé∞Ê¨°Êï∞„ÄÇ Python version - dfs class Solution ( object ): count = 0 def findFrequentTreeSum ( self , root ): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" dic = {} self . helper ( root , dic ) return [ item for item in dic . keys () if dic [ item ] == self . count ] def helper ( self , node , dic ): if not node : return 0 sums = node . val + self . helper ( node . left , dic ) + self . helper ( node . right , dic ) dic [ sums ] = dic . get ( sums , 0 ) + 1 self . count = max ( self . count , dic [ sums ]) return sums Mark: 78ms Additional","tags":"Python,C","title":"LeetCode - Most Frequent Subtree Sum"},{"url":"leetcode-detect-capital.html","text":"Description Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like \"USA\". All letters in this word are not capitals, like \"leetcode\". Only the first letter in this word is capital if it has more than one letter, like \"Google\". Otherwise, we define that this word doesn't use capitals in a right way. Example 1: Input: \"USA\" Output: True Example 2: Input: \"FlaG\" Output: False Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters. Source link Best practice C++ÁöÑregÊúâÁÇπÊÖ¢Âïä! C++ reg verison class Solution { public : bool detectCapitalUse ( string & word ) { const regex pattern ( \"[A-Z]+$|[a-z]+$|[A-Z][a-z]*$\" ); match_results < string :: const_iterator > result ; bool valid = regex_match ( word , result , pattern ); return valid ; } }; Mark: 149ms Âà©Áî®Ê≠£ÂàôË°®ËææÂºèÂÜôÁöÑÊ†áÂáÜÂåπÈÖçÁ®ãÂ∫è„ÄÇ Python version v1 - Re solution class Solution ( object ): def detectCapitalUse ( self , word ): \"\"\" :type word: str :rtype: bool \"\"\" return True if re . match ( r '[A-Z]+$|[a-z]+$|[A-Z][a-z]*$' , word ) else False Mark: 45ms Áúã‰∫ÜÂÖ∂‰ªñÂ∞è‰ºôÂ≠êÁöÑ‰ª£Á†Å‰πãÂêéÂèëÁé∞pythonÊúâËá™Â∑±ÂÆö‰πâÁöÑÊñπÊ≥ïÂåπÈÖçÈ¢òÁõÆÊâÄËø∞ÁöÑ‰∏âÈíüstringÁöÑÊÉÖÂÜµÔºå‰æøÊúâ‰∫Ü‰ª•‰∏ã‰ª£Á†Å„ÄÇ Python version v2 - Bulit in solution class Solution ( object ): def detectCapitalUse ( self , word ): \"\"\" :type word: str :rtype: bool \"\"\" return word . isupper () or word . istitle () or word . islower () Mark: 38ms Additional","tags":"Python,C","title":"LeetCode - Detect Capital"},{"url":"leetcode-convert-bst-to-greater-tree.html","text":"Description Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: Input : The root of a Binary Search Tree like this : 5 / \\ 2 13 Output : The root of a Greater Tree like this : 18 / \\ 20 13 Source link Best practice Âà©Áî®‰∫åÂèâÊêúÁ¥¢Ê†ëÁöÑÁâπÊÄßÔºå‰ª•Âè≥‰∏≠Â∑¶ÁöÑÊñπÂºèÈÅçÂéÜÂÖ®Ê†ë„ÄÇpythonÁâàÊú¨ÂÖàÂÆåÊàêÔºå‰ΩøÁî®‰∫ÜÂÖ®Â±ÄÂèòÈáèËÆ∞ÂΩïÁ¥ØËÆ°ÂÄºÊù•ËæÖÂä©ÈÄíÂΩí„ÄÇC++ÁâàÊú¨ÂàôÂ∞ÜÂèòÈáèÂä†ÂÖ•ÈÄíÂΩí,‰∏ç‰ΩøÁî®ÂÖ®Â±ÄÂèòÈáè„ÄÇ C++ version class Solution { public : int helper ( TreeNode * root , int cum ) { if ( root -> right ) cum = helper ( root -> right , cum ); root -> val = root -> val + cum ; return ( root -> left ) ? helper ( root -> left , root -> val ) : root -> val ; } TreeNode * convertBST ( TreeNode * root ) { if ( ! root ) return NULL ; helper ( root , 0 ); return root ; } }; Mark: 35ms Python version class Solution ( object ): cum = 0 def convertBST ( self , root ): \"\"\" :type root: TreeNode :rtype: TreeNode \"\"\" self . helper ( root ) return root def helper ( self , node ): if not node : return self . helper ( node . right ) self . cum += node . val node . val = self . cum self . helper ( node . left ) Mark: 178ms Additional","tags":"Python,C","title":"LeetCode - Convert BST to Greater Tree"},{"url":"leetcode-longest-uncommon-subsequence-i.html","text":"Description Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence . If the longest uncommon subsequence doesn't exist, return -1. Example 1: Input: \"aba\", \"cdc\" Output: 3 Explanation: The longest uncommon subsequence is \"aba\" (or \"cdc\"), because \"aba\" is a subsequence of \"aba\", but not a subsequence of any other strings in the group of two strings. Note: Both strings' lengths will not exceed 100. Only letters from a ~ z will appear in input strings. Source link Best practice ËøôÂÖ∂ÂÆûÊòØ‰∏™ÂæàÊÜ®ÂéöÁöÑÈóÆÈ¢ò„ÄÇ For strings A, B, when len(A) > len(B), the longest possible subsequence of either A or B is A, and no subsequence of B can be equal to A. Answer: len(A). When len(A) == len(B), the only subsequence of B equal to A is B; so as long as A != B, the answer remains len(A). When A == B, any subsequence of A can be found in B and vice versa, so the answer is -1. Python version class Solution ( object ): def findLUSlength ( self , a , b ): \"\"\" :type a: str :type b: str :rtype: int \"\"\" if a == b : return - 1 return max ( len ( a ), len ( b )) Mark: 45ms Additional Python String","tags":"Python,C","title":"LeetCode - Longest Uncommon Subsequence I"},{"url":"leetcode-single-number.html","text":"Description Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Source link Best practice Âà©Áî®ÂºÇÊàñ‰ΩçËøêÁÆóÊ∂àÈô§ÊàêÂØπÂá∫Áé∞ÁöÑÂÖÉÁ¥†Âè™Áïô‰∏ãÈÇ£‰∏™ÂçïË∫´ÂÖÉÁ¥†„ÄÇ C++ version class Solution { public : int singleNumber ( vector < int >& nums ) { int result = 0 ; int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) { result = result &#94; nums [ i ]; } return result ; } }; Mark: 16ms Python version class Solution ( object ): def singleNumber ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" result = 0 for item in nums : result &#94;= item return result Mark: 45ms Additional Êù•Ë∞àË∞àC++ ‰ΩçËøêÁÆó","tags":"Python,C","title":"LeetCode - Single Number"},{"url":"leetcode-find-largest-value-in-each-tree-row.html","text":"Description You need to find the largest value in each row of a binary tree. Example: Input : 1 / \\ 3 2 / \\ \\ 5 3 9 Output : [ 1 , 3 , 9 ] Source link Best practice ËÆæÊ†ëÊ†π‰∏∫Á¨¨0Â±ÇÔºåÂàôÁ¨¨iÂ±ÇÁöÑÊúÄÂ§ßÂÄºÁ≠â‰∫éÁªìÊûúÈõÜresult[i]„ÄÇÈÅçÂéÜÊØè‰∏ÄÂ±ÇÊØîËæÉÁõ∏ÂêåÂ∫èÂè∑ÁöÑÊ†πÂÄºÁöÑÊúÄÂ§ßÂÄº„ÄÇ C++ version #include <iostream> #include <vector> #include <algorithm> class Solution { vector < int > result ; public : vector < int > largestValues ( TreeNode * root ) { helper ( root , 0 ); return result ; } void helper ( TreeNode * node , int level ) { if ( ! node ) return ; if ( result . size () <= level ) { result . push_back ( node -> val ); } else { result [ level ] = max ( result [ level ], node -> val ); } helper ( node -> left , level + 1 ); helper ( node -> right , level + 1 ); } }; Mark: 12ms Êú¨È¢òÂÖàÁîüÊàê‰∏ÄË°å‰∏≠ÁöÑÊâÄÊúâÂÖÉÁ¥†Ôºå‰πãÂêéÂÜçÊØîËæÉÂá∫ÊúÄÂ§ßÂÄº„ÄÇ Python version class Solution ( object ): def largestValues ( self , root ): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" lst = [] child = [ root ] while any ( child ): lst . append ( max ([ item . val for item in child ])) child = [ item for node in child for item in filter ( None ,( node . left , node . right ))] return lst Mark: 96ms Additional C++ÊåáÈíàËØ¶Ëß£","tags":"Python,C","title":"LeetCode - Find Largest Value in Each Tree Row"},{"url":"leetcode-find-all-duplicates-in-an-array.html","text":"Description Given an array of integers, 1 ‚â§ a[i] ‚â§ n (n = size of array), some elements appear twice and others appear once . Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime? Example: Input : [ 4 , 3 , 2 , 7 , 8 , 2 , 3 , 1 ] Output : [ 2 , 3 ] Source link Best practice Êï∞ÂàóÊúâ‰∏§‰∏™ÁâπÂæÅÔºö‰∏ÄÊòØÈïøÂ∫¶‰∏∫nÁöÑÊï∞ÂàóÂè™‰ºöÁî±1Âà∞nÁöÑÊï∞Â≠óÁªÑÊàêÔºå‰∫åÊòØÈáçÂ§çÊï∞Èáè‰∏çË∂ÖËøá‰∏§Ê¨°„ÄÇÂØπ‰∫é‰ªªÊÑè‰∏Ä‰∏™Êï∞ÂàóÂÖÉÁ¥†iÔºåÂ∫èÂè∑i-1ÂøÖÂÆöÂ≠òÂú®‰∏îÂîØ‰∏ÄÔºåÂõ†Ê≠§Êàë‰ª¨ÂèØ‰ª•Áî®Êï∞ÂàóÁöÑÂ∫èÂè∑‰ΩøÊï∞ÂàóÊú¨Ë∫´Êàê‰∏∫‰∏Ä‰∏™Â≠òÊîæÂ∑≤ÂåπÈÖçÂà∞Êï∞Â≠óÁöÑÂìàÂ∏åË°®‚Äî‚ÄîÂΩìÂåπÈÖçÂÖÉÁ¥†ÂÄºÊó∂ÔºåÂ∞ÜÂÖ∂ÂØπÂ∫îÁöÑÂ∫èÂè∑ÁöÑÂÖÉÁ¥†ÂÄºËÆæ‰∏∫Ë¥üÊï∞„ÄÇ C++ version class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > res ; for ( int i = 0 ; i < nums . size (); i ++ ) { int index = abs ( nums [ i ]) - 1 ; if ( nums [ index ] < 0 ) { res . push_back ( abs ( nums [ i ])); } else { nums [ index ] = - nums [ index ]; } } return res ; } }; Mark: 139ms Python version class Solution ( object ): def findDuplicates ( self , nums ): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" res = [] for x in nums : if nums [ abs ( x ) - 1 ] < 0 : res . append ( abs ( x )) else : nums [ abs ( x ) - 1 ] *= - 1 print ( nums ) return res Mark: 365ms Additional Find duplicates in O(n) time and O(1) extra space","tags":"Python,C","title":"LeetCode - Find All Duplicates in an Array"},{"url":"leetcode-beautiful-arrangement.html","text":"Description Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the i th position ( 1 ‚â§ i ‚â§ N ) in this array: The number at the i th position is divisible by i . i is divisible by the number at the i th position. Now given N, how many beautiful arrangements can you construct? Example 1: Input : 2 Output : 2 Explanation : The first beautiful arrangement is [ 1 , 2 ]: Number at the 1 st position ( i = 1 ) is 1 , and 1 is divisible by i ( i = 1 ). Number at the 2 nd position ( i = 2 ) is 2 , and 2 is divisible by i ( i = 2 ). The second beautiful arrangement is [ 2 , 1 ]: Number at the 1 st position ( i = 1 ) is 2 , and 2 is divisible by i ( i = 1 ). Number at the 2 nd position ( i = 2 ) is 1 , and i ( i = 2 ) is divisible by 1 . Note : N is a positive integer and will not exceed 15 . Source link Most popular C++ version class Solution { public : int countArrangement ( int N ) { vector < int > vs ; for ( int i = 0 ; i < N ; ++ i ) vs . push_back ( i + 1 ); return counts ( N , vs ); } int counts ( int n , vector < int >& vs ) { if ( n <= 0 ) return 1 ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( vs [ i ] % n == 0 || n % vs [ i ] == 0 ) { swap ( vs [ i ], vs [ n - 1 ]); ans += counts ( n - 1 , vs ); swap ( vs [ i ], vs [ n - 1 ]); } } return ans ; } }; Mark: 6ms My solution C++ version class Solution { public : int count = 0 ; int size = 0 ; int countArrangement ( int N ) { vector < int > vs ; if ( N == 0 ) return 0 ; for ( int i = 0 ; i < N ; ++ i ) vs . push_back ( 0 ); size = N ; helper ( N , vs ); return count ; } void helper ( int n , vector < int > & vs ) { if ( n <= 0 ) { //ËæπÁïåÊù°‰ª∂ count ++ ; return ; } for ( int i = size - 1 ; i >= 0 ; -- i ) { if (( vs [ i ] == 0 ) && (( i + 1 ) % n == 0 || n % ( i + 1 ) == 0 )) { //Ââ™Êûù vs [ i ] = 1 ; helper ( n - 1 , vs ); vs [ i ] = 0 ; } } } }; Mark: 16ms DP Python version of leetcode user cache = {} class Solution ( object ): def countArrangement ( self , N ): def helper ( i , X ): if i == 1 : return 1 key = ( i , X ) if key in cache : return cache [ key ] total = 0 for j in range ( len ( X )): if X [ j ] % i == 0 or i % X [ j ] == 0 : total += helper ( i - 1 , X [: j ] + X [ j + 1 :]) cache [ key ] = total #Áî®ÂìàÂ∏åË°®Êù•ÂÇ®Â≠ò(‰ΩçÁΩÆ,([Ââ©‰ΩôÂÖÉÁ¥†])):ÈÖçÂØπÊï∞Èáè ‰ø°ÊÅØ return total return helper ( N , tuple ( range ( 1 , N + 1 ))) Mark: 66ms Additional ÂõûÊ∫ØÁÆóÊ≥ï‰ªãÁªç: https://segmentfault.com/a/1190000006121957","tags":"Python,C","title":"LeetCode - Beautiful Arrangement"},{"url":"leetcode-max-consecutive-ones.html","text":"Description Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 Source link Most popular My solution C++ version class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int cnt = 0 ; int ans = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] == 1 ) { ans = ans > ++ cnt ? ans : cnt ; } else { cnt = 0 ; } } return ans ; } }; Mark: 2ms Python version class Solution ( object ): def findMaxConsecutiveOnes ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" lst = [ - 1 ] length = len ( nums ) for i in range ( length ): if nums [ i ] == 0 : lst . append ( i ) lst . append ( length ) return max ( map ( lambda x : x [ 1 ] - x [ 0 ] - 1 , zip ( lst [: - 1 ], lst [ 1 :]))) Mark: 105ms Additional","tags":"Python,C","title":"LeetCode - Max Consecutive Ones"},{"url":"leetcode-arithmetic-slices.html","text":"Description A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7 A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N. A slice (P, Q) of array A is called arithmetic if the sequence: A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q. The function should return the number of arithmetic slices in the array A. Example: A = [ 1 , 2 , 3 , 4 ] return : 3 , for 3 arithmetic slices in A : [ 1 , 2 , 3 ], [ 2 , 3 , 4 ] and [ 1 , 2 , 3 , 4 ] itself . Source link Most popular python version class Solution ( object ): def numberOfArithmeticSlices ( self , A ): \"\"\" :type A: List[int] :rtype: int \"\"\" opt , i = [ 0 , 0 ], 1 for j in xrange ( 2 , len ( A )): if A [ j ] - A [ j - 1 ] == A [ j - 1 ] - A [ j - 2 ]: opt . append ( opt [ j - 1 ] + i ) i += 1 else : opt . append ( opt [ j - 1 ]) i = 1 return opt [ - 1 ] c++ version for 2ms class Solution { public : int numberOfArithmeticSlices ( vector < int >& A ) { int n = A . size (); if ( n < 3 ) return 0 ; vector < int > dp ( n , 0 ); // dp[i] means the number of arithmetic slices ending with A[i] if ( A [ 2 ] - A [ 1 ] == A [ 1 ] - A [ 0 ]) dp [ 2 ] = 1 ; // if the first three numbers are arithmetic or not int result = dp [ 2 ]; for ( int i = 3 ; i < n ; ++ i ) { // if A[i-2], A[i-1], A[i] are arithmetic, then the number of arithmetic slices ending with A[i] (dp[i]) // equals to: // the number of arithmetic slices ending with A[i-1] (dp[i-1], all these arithmetic slices appending A[i] are also arithmetic) // + // A[i-2], A[i-1], A[i] (a brand new arithmetic slice) // it is how dp[i] = dp[i-1] + 1 comes if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]) dp [ i ] = dp [ i - 1 ] + 1 ; result += dp [ i ]; // accumulate all valid slices } return result ; } }; My solution too ugly to post Additional","tags":"Python","title":"LeetCode - Arithmetic Slices"},{"url":"leetcode-optimal-division.html","text":"Description Given a list of positive integers , the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4. However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis . Example: ** Input ** : [ 1000 , 100 , 10 , 2 ] ** Output ** : \"1000/(100/10/2)\" ** Explanation ** : 1000 / ( 100 / 10 / 2 ) = 1000 / (( 100 / 10 ) / 2 ) = 200 However , the bold parenthesis in \"1000/((100/10)/2)\" are redundant , since they don ' t influence the operation priority . So you should return \"1000/(100/10/2)\" . Other cases : 1000 / ( 100 / 10 ) / 2 = 50 1000 / ( 100 / ( 10 / 2 )) = 50 1000 / 100 / 10 / 2 = 0 . 5 1000 / 100 / ( 10 / 2 ) = 2 Note: 1. The length of the input array is [1, 10]. 2. Elements in the given array will be in range [2, 1000]. 3. There is only one optimal division for each test case. Source link Most popular Regardless of parentheses, every element is either in the numerator or denominator of the final fraction. The expression A[0] / ( A[1] / A[2] / ... / A[N-1] ) has every element in the numerator except A[1], and it is impossible for A[1] to be in the numerator, so it is the largest. We must also be careful with corner cases. class Solution ( object ): def optimalDivision ( self , A ): A = map ( str , A ) if len ( A ) <= 2 : return '/' . join ( A ) return ' {} /( {} )' . format ( A [ 0 ], '/' . join ( A [ 1 :])) My solution class Solution ( object ): def optimalDivision ( self , nums ): \"\"\" :type nums: List[int] :rtype: str \"\"\" length = len ( nums ) if length == 1 : return str ( nums [ 0 ]) elif length == 2 : return str ( nums [ 0 ]) + \"/\" + str ( nums [ 1 ]) return str ( nums [ 0 ]) + \"/(\" + \"/\" . join ( map ( str , nums [ 1 :])) + \")\" Additional","tags":"Python","title":"LeetCode - Optimal Division"},{"url":"leetcode-queue-reconstruction-by-height.html","text":"Description Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k) , where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h . Write an algorithm to reconstruct the queue. Example: Input : [[ 7 , 0 ], [ 4 , 4 ], [ 7 , 1 ], [ 5 , 0 ], [ 6 , 1 ], [ 5 , 2 ]] Output : [[ 5 , 0 ], [ 7 , 0 ], [ 5 , 2 ], [ 6 , 1 ], [ 4 , 4 ], [ 7 , 1 ]] Note: The number of people is less than 1,100. Source link Most popular My solution ÂÖàÂ∞ÜÂàóË°®‰ª•h DEC, k ASCÊéíÂ∫è Â∞ÜÂÖÉÁ¥†‰∏Ä‰∏ÄÂÖ•Ê†à, Ëã• k > Ê†àÊ∑±, ÂàôÊó†Ëß£; Âê¶ÂàôÊèíÂÖ•Âà∞ÂàóË°®ÁöÑ‰ΩçÁΩÆk class Solution ( object ): def reconstructQueue ( self , people ): \"\"\" :type people: List[List[int]] :rtype: List[List[int]] \"\"\" stack = [] for item in sorted ( people , key = lambda x : ( - x [ 0 ], x [ 1 ])): if len ( stack ) < item [ 1 ]: return False stack . insert ( item [ 1 ], item ) return stack Additional","tags":"Python","title":"LeetCode - Queue Reconstruction by Height"},{"url":"leetcode-find-bottom-left-tree-value.html","text":"Description Given a binary tree, find the leftmost value in the last row of the tree. Example 1: Input : 2 / \\ 1 3 Output : 1 Example 2: Input : 1 / \\ 2 3 / / \\ 4 5 6 / 7 Output : 7 Note: You may assume the tree (i.e., the given root node) is not NULL. Source link Most popular solution class Solution ( object ): def findLeftMostNode ( self , root ): queue = [ root ] for node in queue : queue += filter ( None , ( node . right , node . left )) return node . val My solution Additional It's leftmost in last row not left left node","tags":"Python","title":"LeetCode - Find Bottom Left Tree Value"},{"url":"leetcode-island-perimeter.html","text":"Description You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have \"lakes\" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island. Example 1: [[ 0 , 1 , 0 , 0 ], [ 1 , 1 , 1 , 0 ], [ 0 , 1 , 0 , 0 ], [ 1 , 1 , 0 , 0 ]] Answer : 16 Explanation : The perimeter is the 16 yellow stripes in the image below : Note: 1. All elements in nums1 and nums2 are unique. 2. The length of both nums1 and nums2 would not exceed 1000. Source link Most popular Since there are no lakes, every pair of neighbour cells with different values is part of the perimeter (more precisely, the edge between them is). So just count the differing pairs, both horizontally and vertically (for the latter I simply transpose the grid). def islandPerimeter ( self , grid ): return sum ( sum ( map ( operator . ne , [ 0 ] + row , row + [ 0 ])) for row in grid + map ( list , zip ( * grid ))) My solution Add 4 for each land and remove 2 for each internal edge. class Solution ( object ): def islandPerimeter ( self , grid ): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" total = 0 for row in range ( len ( grid )): for column in range ( len ( grid [ row ])): if grid [ row ][ column ] == 1 : total += ( int ( grid [ row - 1 ][ column ] == 1 ) * ( row != 0 ) + int ( grid [ row ][ column - 1 ] == 1 ) * ( column != 0 )) * ( - 2 ) + 4 return total Additional","tags":"Python","title":"LeetCode - Island Perimeter"},{"url":"leetcode-keyboard-row.html","text":"Description Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below. Example 1: Input: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"] Output: [\"Alaska\", \"Dad\"] Note: 1. You may use one character in the keyboard more than once. 2. You may assume the input string will only contain letters of alphabet. Source link My solution class Solution ( object ): def findWords ( self , words ): return list ( filter ( re . compile ( r '(?i)&#94;([qwertyuiop]+|[asdfghjkl]+|[zxcvbnm]+)$' ) . match , words )) Additional Regular Expression","tags":"Python","title":"LeetCode - Keyboard Row"},{"url":"leetcode-next-greater-element-i.html","text":"Description You are given two arrays (without duplicates) nums1 and nums2 where nums1 's elements are subset of nums2 . Find all the next greater numbers for nums1 's elements in the corresponding places of nums2 . The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2 . If it does not exist, output -1 for this number. Example 1: Input : nums1 = [ 4 , 1 , 2 ], nums2 = [ 1 , 3 , 4 , 2 ]. Output : [- 1 , 3 ,- 1 ] Explanation : For number 4 in the first array , you cannot find the next greater number for it in the second array , so output - 1 . For number 1 in the first array , the next greater number for it in the second array is 3 . For number 2 in the first array , there is no next greater number for it in the second array , so output - 1 . Example 2: Input : nums1 = [ 2 , 4 ], nums2 = [ 1 , 2 , 3 , 4 ]. Output : [ 3 ,- 1 ] Explanation : For number 2 in the first array , the next greater number for it in the second array is 3 . For number 4 in the first array , there is no next greater number for it in the second array , so output - 1 . Note: 1. All elements in nums1 and nums2 are unique. 2. The length of both nums1 and nums2 would not exceed 1000. Source link Most popular class Solution ( object ): def nextGreaterElement ( self , findNums , nums ): \"\"\" :type findNums: List[int] :type nums: List[int] :rtype: List[int] \"\"\" d = {} st = [] ans = [] for x in nums : while len ( st ) and st [ - 1 ] < x : d [ st . pop ()] = x st . append ( x ) for x in findNums : ans . append ( d . get ( x , - 1 )) return ans Mark: 83% My solution class Solution ( object ): def nextGreaterElement ( self , findNums , nums ): \"\"\" :type findNums: List[int] :type nums: List[int] :rtype: List[int] \"\"\" lst = [] for k , i in enumerate ( findNums ): for j in nums [ nums . index ( i ):]: if j > i : lst . append ( j ) break if len ( lst ) != k + 1 : lst . append ( - 1 ) return lst Mark: 50% Additional","tags":"Python","title":"LeetCode - Next Greater Element I"},{"url":"leetcode-reverse-words-in-a-string-iii.html","text":"Description Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: \"Let's take LeetCode contest\" Output: \"s'teL ekat edoCteeL tsetnoc\" Note: In the string, each word is separated by single space and there will not be any extra space in the string. Source link Most popular solution class Solution ( object ): def reverseWords ( self , s ): \"\"\" :type s: str :rtype: str \"\"\" return \" \" . join ( map ( lambda x : x [:: - 1 ], s . split ())) My solution class Solution ( object ): def reverseWords ( self , s ): \"\"\" :type s: str :rtype: str \"\"\" string = '' for item in s . split (): string += ( item [:: - 1 ] + ' ' ) return string [: - 1 ] Mark: 38% Additional","tags":"Python","title":"LeetCode - Reverse Words in a String III"},{"url":"markdown-syntax.html","text":"Please Note: This is an unofficial kramdown sandbox, the official complete documentation for kramdown is here . documentation Code This demo uses highlight.js to enable client-side syntax highlighting inline or as a block (auto detect language): def ruby puts \"ruby\" end def hello(): print \"python\" Force language: function hello () { alert ( \"Javascript\" ); } Lists One Two Three Lorem Ipsum Dolar Etc. Dolar Example Meep Meep LaTeX Using MathJax . Inline: $$ \\varphi = \\frac{1+\\sqrt{5}}{2} = 1.61803\\,39887\\ldots. $$ Block: $$ \\int_0&#94;{2\\pi}\\sin{x}\\ dx=0 $$ Tables Header1 Header2 Header3 cell1 cell2 cell3 cell4 cell5 cell6 ---- cell1 cell2 cell3 cell4 cell5 cell6 ===== Foot1 Foot2 Foot3 etc.","tags":"Python","title":"Markdown Syntax"},{"url":"leetcode-array-partition-i.html","text":"Description Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. - Example: ''' Input: [1,4,3,2] Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4. ''' - Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. Source link Most popular solution class Solution ( object ) : def arrayPairSum ( self , nums ) : \"\"\" :type nums: List[int] :rtype: int \"\"\" return sum ( sorted ( nums ) [ ::2 ] ) Mark: 87% My solution class Solution ( object ) : def arrayPairSum ( self , nums ) : \"\"\" :type nums: List[int] :rtype: int \"\"\" nums . sort () return sum ( nums [ ::2 ] ) Mark: 85% Additional ''' Help on method_descriptor: sort(...) L.sort(cmp=None, key=None, reverse=False) -- stable sort IN PLACE ; cmp(x, y) -> -1, 0, 1 help(sorted) Help on built-in function sorted in module builtin : sorted(...) sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list '''","tags":"Python","title":"LeetCode - Array Partition I"},{"url":"leetcode-distribute-candies.html","text":"Description Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. - Example 1: Input : candies = [ 1 , 1 , 2 , 2 , 3 , 3 ] Output : 3 Explanation : There are three different kinds of candies ( 1 , 2 and 3 ), and two candies for each kind . Optimal distribution : The sister has candies [ 1 , 2 , 3 ] and the brother has candies [ 1 , 2 , 3 ], too . The sister has three different kinds of candies . - Example 2: Input : candies = [ 1 , 1 , 2 , 3 ] Output : 2 Explanation : For example , the sister has candies [ 2 , 3 ] and the brother has candies [ 1 , 1 ]. The sister has two different kinds of candies , the brother has only one kind of candies . - Note: The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000]. Source link Most popular solution class Solution ( object ): def distributeCandies ( self , candies ): \"\"\" :type candies: List[int] :rtype: int \"\"\" return min ( len ( candies ) / 2 , len ( set ( candies ))) My solution Same Mark: 97% Additional","tags":"Python","title":"LeetCode - Distribute Candies"},{"url":"leetcode-hamming-distance.html","text":"Description The Hamming distance 1 between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. - Note: 0 ‚â§ x, y < 231. - Example: Input : x = 1 , y = 4 Output : 2 Explanation : 1 ( 0 0 0 1 ) 4 ( 0 1 0 0 ) ‚Üë ‚Üë The above arrows point to positions where the corresponding bits are different . Source link Most popular solution class Solution ( object ): def hammingDistance ( self , x , y ): \"\"\" :type x: int :type y: int :rtype: int \"\"\" return bin ( x &#94; y ) . count ( '1' ) My solution class Solution ( object ): def hammingDistance ( self , x , y ): \"\"\" :type x: int :type y: int :rtype: int \"\"\" bit = x &#94; y count = 0 while bit : if bit & 1 : count += 1 bit = bit >> 1 return count Mark: 42 ms Additional Python ‰ΩçËøêÁÆó Description Mark Comment Êåâ‰Ωç‰∏é: & | Êåâ‰ΩçÊàñ: | | | | | Êåâ‰ΩçÂºÇÊàñ: | &#94; | | Êåâ‰ΩçÁøªËΩ¨: | ~ | +1 ‰πãÂêé‰πò‰ª• -1| | Â∑¶ÁßªËøêÁÆóÁ¨¶ | << | X << N Â∞Ü‰∏Ä‰∏™Êï∞Â≠óXÂêëÂ∑¶ÁßªÂä®N‰Ωç| | Âè≥ÁßªËøêÁÆóÁ¨¶ | >> | | Âú®‰ø°ÊÅØËÆ∫‰∏≠Ôºå‰∏§‰∏™Á≠âÈïøÂ≠óÁ¨¶‰∏≤‰πãÈó¥ÁöÑ Ê±âÊòéË∑ùÁ¶ª (Hamming distanceÔºâÊòØ‰∏§‰∏™Â≠óÁ¨¶‰∏≤ÂØπÂ∫î‰ΩçÁΩÆÁöÑ‰∏çÂêåÂ≠óÁ¨¶ÁöÑ‰∏™Êï∞„ÄÇÊç¢Âè•ËØùËØ¥ÔºåÂÆÉÂ∞±ÊòØÂ∞Ü‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÂèòÊç¢ÊàêÂè¶Â§ñ‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÊâÄÈúÄË¶ÅÊõøÊç¢ÁöÑÂ≠óÁ¨¶‰∏™Êï∞„ÄÇ Ê±âÊòéÈáçÈáè ÊòØÂ≠óÁ¨¶‰∏≤Áõ∏ÂØπ‰∫éÂêåÊ†∑ÈïøÂ∫¶ÁöÑÈõ∂Â≠óÁ¨¶‰∏≤ÁöÑÊ±âÊòéË∑ùÁ¶ªÔºå‰πüÂ∞±ÊòØËØ¥ÔºåÂÆÉÊòØÂ≠óÁ¨¶‰∏≤‰∏≠ÈùûÈõ∂ÁöÑÂÖÉÁ¥†‰∏™Êï∞ÔºöÂØπ‰∫é‰∫åËøõÂà∂Â≠óÁ¨¶‰∏≤Êù•ËØ¥ÔºåÂ∞±ÊòØ1ÁöÑ‰∏™Êï∞ÔºåÊâÄ‰ª•11101ÁöÑÊ±âÊòéÈáçÈáèÊòØ4„ÄÇ ‚Ü©","tags":"Python","title":"LeetCode - Hamming Distance"},{"url":"leetcode-two-sum.html","text":"Description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [ 2 , 7 , 11 , 15 ], target = 9 , Because nums [ 0 ] + nums [ 1 ] = 2 + 7 = 9 , return [ 0 , 1 ]. Subscribe to see which companies asked this question. Source page Most popular solution class Solution ( object ): def twoSum ( self , nums , target ): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" if len ( nums ) <= 1 : return False dict = {} for i in range ( len ( nums )): if nums [ i ] in dict : return [ dict [ nums [ i ]], i ] else : dict [ target - nums [ i ]] = i My solution class Solution ( object ): def twoSum ( self , nums , target ): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" length = len ( nums ) num_temp = sorted ( range ( length ), key = lambda k : nums [ k ]) #ÊéíÂ∫èÂâçÁöÑÊï∞ÁªÑÂ∫èÂè∑ nums . sort () i = 0 j = length - 1 while 1 : sumed = nums [ i ] + nums [ j ] if sumed > target : j -= 1 elif sumed < target : i += 1 else : return [ num_temp [ i ], num_temp [ j ]] Mark: 86% Additional","tags":"Python","title":"LeetCode - Two Sum"},{"url":"top-10-python-libraries-of-2016.html","text":"We try to avoid most established choices such as Django, Flask, etc. that are kind of standard nowadays. Also, some of these libraries date prior to 2016, but either they had an explosion in popularity this year or we think they are great enough to deserve the spot. Here we go! Last year, we did a recap with what we thought were the best Python libraries of 2015 , which was widely shared within the Python community (see post in r/Python ). A year has gone by, and again it is time to give due credit for the awesome work that has been done by the open source community this year. Again, we try to avoid most established choices such as Django, Flask, etc. that are kind of standard nowadays. Also, some of these libraries date prior to 2016, but either they had an explosion in popularity this year or we think they are great enough to deserve the spot. Here we go! 1. Zappa Since the release of AWS Lambda (and others that have followed ), all the rage has been about serverless architectures . These allow microservices to be deployed in the cloud, in a fully managed environment where one doesn't have to care about managing any server, but is assigned stateless, ephemeral computing containers that are fully managed by a provider. With this paradigm, events (such as a traffic spike) can trigger the execution of more of these containers and therefore give the possibility to handle \"infinite\" horizontal scaling. Zappa is the serverless framework for Python , although (at least for the moment) it only has support for AWS Lambda and AWS API Gateway. It makes building so-architectured apps very simple, freeing you from most of the tedious setup you would have to do through the AWS Console or API, and has all sort of commands to ease deployment and managing different environments. 2. Sanic + uvloop Who said Python couldn't be fast? Apart from competing for the best name of a software library ever, Sanic also competes for the fastest Python web framework ever, and appears to be the winner by a clear margin. It is a Flask-like Python 3.5+ web server that is designed for speed. Another library, uvloop , is an ultra fast drop-in replacement for asyncio 's event loop that uses libuv under the hood. Together, these two things make a great combination! According to the Sanic author's benchmark , uvloop could power this beast to handle more than 33k requests/s which is just insane (and faster than node.js ). Your code can benefit from the new async/await syntax so it will look neat too; besides we love the Flask-style API. Make sure to give Sanic a try, and if you are using asyncio , you can surely benefit from uvloop with very little change in your code! 3. asyncpg In line with recent developments for the asyncio framework, the folks from MagicStack bring us this efficient asynchronous (currently CPython 3.5 only) database interface library designed specifically for PostgreSQL. It has zero dependencies, meaning there is no need to have libpq installed. In contrast with psycopg2 (the most popular PostgreSQL adapter for Python) which exchanges data with the database server in text format, asyncpg implements PostgreSQL binary I/O protocol , which not only allows support for generic types but also comes with numerous performance benefits. The benchmarks are clear: asyncpg is on average, at least 3x faster than psycopg2 (or aiopg ), and faster than the node.js and Go implementations. 4. boto3 If you have your infrastructure on AWS or otherwise make use of their services (such as S3), you should be very happy that boto , the Python interface for AWS API, got a completely rewrite from the ground up. The great thing is that you don't need to migrate your app all at once: you can use boto3 and boto (2) at the same time ; for example using boto3 only for new parts of your application. The new implementation is much more consistent between different services, and since it uses a data-driven approach to generate classes at runtime from JSON description files, it will always get fast updates. No more lagging behind new Amazon API features, move to boto3 ! 5. TensorFlow Do we even need an introduction here? Since it was released by Google in November 2015, this library has gained a huge momentum and has become the #1 trendiest GitHub Python repository. In case you have been living under a rock for the past year, TensorFlow is a library for numerical computation using data flow graphs, which can run over GPU or CPU. We have quickly witnessed it become a trend in the Machine Learning community (especially Deep Learning, see our post on 10 main takeaways from MLconf ), not only growing its uses in research but also being widely used in production applications. If you are doing Deep Learning and want to use it through a higher level interface, you can try using it as a backend for Keras (which made it to last years post) or the newer TensorFlow-Slim . 6. gym + universe If you are into AI, you surely have heard about the OpenAI non-profit artificial intelligence research company (backed by Elon Musk et al.). The researchers have open sourced some Python code this year! Gym is a toolkit for developing and comparing reinforcement learning algorithms. It consists of an open-source library with a collection of test problems (environments) that can be used to test reinforcement learning algorithms, and a site and API that allows to compare the performance of trained algorithms (agents). Since it doesn't care about the implementation of the agent, you can build them with the computation library of your choice: bare numpy, TensorFlow, Theano, etc. We also have the recently released universe , a software platform for researching into general intelligence across games, websites and other applications. This fits perfectly with gym , since it allows any real-world application to be turned into a gym environment. Researchers hope that this limitless possibility will accelerate research into smarter agents that can solve general purpose tasks. 7. Bokeh You may be familiar with some of the libraries Python has to offer for data visualization; the most popular of which are matplotlib and seaborn . Bokeh, however, is created for interactive visualization , and targets modern web browsers for the presentation. This means Bokeh can create a plot which lets you_explore_ the data from a web browser. The great thing is that it integrates tightly with Jupyter Notebooks , so you can use it with your probably go-to tool for your research. There is also an optional server component, bokeh-server , with many powerful capabilities like server-side downsampling of large dataset (no more slow network tranfers/browser!), streaming data, transformations, etc. Make sure to check the gallery for examples of what you can create. They look awesome! 8. Blaze Sometimes, you want to run analytics over a dataset too big to fit your computer's RAM. If you cannot rely on numpy or Pandas, you usually turn to other tools like PostgreSQL, MongoDB, Hadoop, Spark, or many others. Depending on the use case, one or more of these tools can make sense, each with their own strengths and weaknesses. The problem? There is a big overhead here because you need to learn how each of these systems work and how to insert data in the proper form. Blaze provides a uniform interface that abstracts you away from several database technologies. At the core, the library provides a way to express computations . Blaze itself doesn't actually do any computation: it just knows how to instruct a specific backend who will be in charge of performing it. There is so much more to Blaze (thus the ecosystem), as libraries that have come out of its development. For example, Dask implements a drop-in replacement for NumPy array that can handle content larger than memory and leverage multiple cores, and also comes with dynamic task scheduling. Interesting stuff. 9. arrow There is a famous saying that there are only two hard problems in Computer Science: cache invalidation and naming things. I think the saying is clearly missing one thing: managing datetimes . If you have ever tried to do that in Python, you will know that the standard library has a gazillion modules and types: datetime , date , calendar , tzinfo , timedelta , relativedelta , pytz , etc. Worse, it is timezone naive by default. Arrow is \"datetime for humans\", offering a sensible approach to creating, manipulating, formatting and converting dates, times, and timestamps. It is a replacement for the datetime type that supports Python 2 or 3, and provides a much nicer interface as well as filling the gaps with new functionality (such as humanize ). Even if you don't really need arrow, using it can greatly reduce the boilerplate in your code. 10. hug Expose your internal API externally, drastically simplifying Python API development. Hug is a next-generation Python 3 (only) library that will provide you with the cleanest way to create HTTP REST APIs in Python. It is not a web framework per se (although that is a function it performs exceptionally well), but only focuses on exposing idiomatically correct and standard internal Python APIs externally. The idea is simple: you define logic and structure once, and you can expose your API through multiple means . Currently, it supports exposing REST API or command line interface. You can use type annotations that let hug not only generate documentation for your API but also provide with validation and clean error messages that will make your life (and your API user's) a lot easier. Hug is built on Falcon's high performance HTTP library, which means you can deploy this to production using any wsgi-compatible server such as gunicorn . Follow the discussion of this post on: Reddit Original source: https://tryolabs.com/blog/2016/12/20/top-10-python‚Ä¶","tags":"posts","title":"Top 10 Python libraries of 2016"}]}