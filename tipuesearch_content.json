{"pages":[{"url":"pages/about.html","text":"Why I started this blog My background My family My hobbies","tags":"pages","title":"About"},{"url":".html","text":"å¾ˆä¹…ä¹‹å‰åŸºäºç”Ÿæˆå™¨å†™è¿‡ ä¸€ä¸ªç®€å•çš„æ–‡æœ¬è§£æè®¡ç®—å™¨ ã€‚è¿™ä¸ªè®¡ç®—å™¨é›†ä¸­äº†å¾ˆå¤šé¢å‘å¯¹è±¡çš„æ€æƒ³ï¼Œä½†å´ä¸æ˜¯å¾ˆå¤šæœ‰ç”¨ã€‚è™½ç„¶å®ƒæ”¯æŒæ±‚å¹‚ &#94; æ“ä½œï¼Œä½†å´æ— æ³•å¤„ç†æ‹¬å·ï¼Œå¹¶æ²¡æœ‰é‚£ä¹ˆæœ‰ç”¨ã€‚ å­¦ä¹ æ ˆçš„æ—¶å€™æœ‰äº†è§£è¿‡å¦‚ä½•ç”¨åç¼€è¡¨è¾¾å¼æ±‚è¡¨è¾¾å¼çš„å€¼ï¼Œä¸€ç›´æ²¡æœ‰åŠ¨æ‰‹å»äº²è‡ªå®ç°è¿™ä¸€ç®—æ³•ã€‚æœ€è¿‘æœ‰è¢«é—®åˆ°å’Œè¿™ä¸ªç®—æ³•ç›¸ç±»ä¼¼çš„é¢˜ï¼ŒåŠ¨æ‰‹å°è¯•ä¸‹åŠ æ·±äº†å°è±¡ã€‚ ä¸­ç¼€è¡¨è¾¾å¼è½¬åŒ–åç¼€è¡¨è¾¾å¼ ä¸­ç¼€è½¬åŒ–åç¼€çš„è§„åˆ™å¦‚ä¸‹ï¼Œæ¥è‡ªç‹é“å­¦å ‚ï¼š æŒ‰ç…§è¿™ä¸€é€»è¾‘ï¼Œå®ç°çš„ç®—æ³•å¦‚ä¸‹ï¼š def postfix_expression ( string : str ) -> List [ Union [ int , str ]]: if not string : return [] priority_map = { '+' : 0 , '-' : 0 , '*' : 1 , '/' : 1 } i = 0 operator_stack = [] postfix_expression = [] while i < len ( string ): if string [ i ] == ' ' : i += 1 continue if string [ i ] . isdigit (): # æ•°å­—ç›´æ¥åŠ å…¥åç¼€è¡¨è¾¾å¼ summary = 0 while i < len ( string ) and string [ i ] . isdigit (): summary = summary * 10 + int ( string [ i ]) i += 1 postfix_expression . append ( summary ) else : if string [ i ] == '(' : # è‹¥ä¸ºå·¦æ‹¬å·ï¼Œå…¥æ ˆ operator_stack . append ( string [ i ]) elif string [ i ] == ')' : # è‹¥ä¸ºå³æ‹¬å·ï¼Œåˆ™æŠŠæ ˆä¸­è¿ç®—ç¬¦åŠ å…¥åç¼€è¡¨è¾¾å¼ï¼Œç›´åˆ°é‡åˆ°å·¦æ‹¬å· operator = operator_stack . pop () while operator != '(' : postfix_expression . append ( operator ) operator = operator_stack . pop () else : operator = string [ i ] if not operator_stack or operator_stack [ - 1 ] == '(' or priority_map [ operator ] > priority_map [ operator_stack [ - 1 ]]: # è‹¥1.æ ˆç©º 2.æ ˆé¡¶å…ƒç´ ä¸ºå·¦æ‹¬å· 3.é«˜äºæ ˆé¡¶å…ƒç´ ä¼˜å…ˆçº§ï¼Œåˆ™å…¥æ ˆ operator_stack . append ( operator ) else : # è‹¥ä½äºæ ˆé¡¶å…ƒç´ ä¼˜å…ˆçº§ï¼Œå¼¹å‡ºæ ˆé¡¶åŠ å…¥åç¼€ç›´åˆ°1.æ ˆç©º 2.é‡åˆ°å·¦æ‹¬å· 3.é‡åˆ°ä¼˜å…ˆçº§æ¯”å®ƒä½çš„è¿ç®—ç¬¦(ä¹˜å’Œé™¤ï¼ŒåŠ å’Œå‡ä¹‹é—´çš„å‰åé¡ºåº) while operator_stack and operator_stack [ - 1 ] != '(' and priority_map [ operator ] <= priority_map [ operator_stack [ - 1 ]]: item = operator_stack . pop () postfix_expression . append ( item ) operator_stack . append ( operator ) i += 1 while operator_stack : postfix_expression . append ( operator_stack . pop ()) return postfix_expression æˆ‘ä»¬è¦ç»´æŠ¤çš„è¿ç®—ç¬¦æ ˆ operator_stack çš„ä¸€ä¸ªæ€§è´¨ï¼šæ ˆä¸Šæ–¹è¿ç®—ç¬¦ä¼šæ¯”ä¸‹æ–¹è¿ç®—ç¬¦æ›´ä¼˜å…ˆæ‰§è¡Œã€‚ å…¶ä¸­ï¼Œä¹‹å‰å›°æƒ‘æˆ‘æ¯”è¾ƒå¤šçš„ç‚¹æ˜¯cä¸­çš„ç¬¬å››ç‚¹ï¼šä¾æ¬¡å¼¹å‡ºæ ˆé¡¶è¿ç®—ç¬¦ï¼Œç›´åˆ°ä¸€ä¸ªä¼˜å…ˆçº§æ¯”å®ƒä½çš„è¿ç®—ç¬¦æˆ–å·¦æ‹¬å·ã€‚åœ¨38è¡Œæœ‰ä¸‰ä¸ªå¾ªç¯å…ˆå†³æ¡ä»¶ï¼š è¿ç®—ç¬¦æ ˆä¸èƒ½ä¸ºç©ºã€‚é€‚ç”¨äº 1+2-3 è¿™ç§æƒ…å†µï¼Œç¬¬äºŒä¸ªåŠ å·popå‡ºç¬¬ä¸€ä¸ªåŠ å·åï¼Œæ ˆä¸­æ²¡æœ‰å…ƒç´ å°±éœ€è¦åœæ­¢å¾ªç¯ è¿ç®—ç¬¦æ ˆé¡¶ä¸èƒ½ä¸ºå·¦æ‹¬å·ã€‚åªæœ‰å³æ‹¬å·æ‰èƒ½popå‡ºå·¦æ‹¬å·ã€‚åœæ­¢å¾ªç¯æ—¶æ ˆé¡¶å…ƒç´ ä¸ºå·¦æ‹¬å·ï¼Œä¹‹åå°†ç°åœ¨å¤„ç†çš„è¿ç®—ç¬¦å…¥æ ˆã€‚é€‚ç”¨äº 1+(2+3+4) è¿™ç§æƒ…å†µ æ ˆé¡¶å…ƒç´ çš„è¿ç®—ç¬¦å¤§äºæˆ–ç­‰äºæ­£åœ¨å¤„ç†çš„è¿ç®—ç¬¦ï¼Œå³åªæœ‰é‡åˆ°ä¼˜å…ˆçº§æ¯”å®ƒä½çš„è¿ç®—ç¬¦æ‰ä¼šåœæ­¢å¼¹å‡ºæ“ä½œã€‚æœ‰è¿™ä¹ˆä¸¤ç§æƒ…å†µï¼š 1+2*3/4 ï¼Œæ ˆä¸­å·²æœ‰ +,* ï¼Œ \\ æƒ³å…¥æ ˆæ—¶å‘ç°æ ˆé¡¶å…ƒç´ ç­‰äºå®ƒçš„ä¼˜å…ˆçº§ã€‚æ­¤æ—¶å…ˆå…¥æ ˆçš„åŒçº§å…ƒç´ åœ¨è¡¨è¾¾å¼æ›´é å‰å¤„ï¼Œç†åº”ä¼˜å…ˆè®¡ç®—ã€‚æœ€ç»ˆæ“ä½œæ˜¯å‡ºæ ˆ * å…¥æ ˆ \\ ã€‚è€Œå¯¹äº + ï¼Œé™¤æ³•è¿˜æ˜¯å¾—ä¼˜å…ˆäºåŠ æ³•è¿è¡Œã€‚ 1+2*3-3 ï¼Œæ ˆä¸­å·²æœ‰ +,* ï¼Œ - æƒ³å…¥æ ˆæ—¶å‘ç°æ ˆé¡¶å…ƒç´ å¤§äºå®ƒçš„ä¼˜å…ˆçº§ï¼Œå¹¶ä¸”ä¸ä¼šæœ‰å…ƒç´ å°äºå®ƒçš„ä¼˜å…ˆçº§ã€‚å› æ­¤ä¼šä¸æ–­é€€æ ˆç›´è‡³æŠµè¾¾1æˆ–è€…2çš„æ¡ä»¶ã€‚ æ¥ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼š assert postfix_expression ( '11 + 22*( 33*44/55-66)-77/88' ) == [ 11 , 22 , 33 , 44 , '*' , 55 , '/' , 66 , '-' , '*' , '+' , 77 , 88 , '/' , '-' ] è®¡ç®—åç¼€è¡¨è¾¾å¼ æœ‰äº†åç¼€è¡¨è¾¾å¼ï¼Œæ¥ä¸‹æ¥ä¸€éƒ¨å°±æ˜¯è®¡ç®—åç¼€è¡¨è¾¾å¼äº†ã€‚è¿™æ­¥ç›¸å¯¹è€Œè¨€é€»è¾‘æ²¡æœ‰é‚£ä¹ˆå¤æ‚ã€‚åŸºæœ¬æ“ä½œå°±æ˜¯éå†åç¼€è¡¨è¾¾å¼å…¥æ ˆï¼›é‡åˆ°æ“ä½œç¬¦é€€æ ˆä¸¤ä¸ªå…ƒç´ è®¡ç®—ï¼Œå°†ç»“æœå†æ¬¡å…¥æ ˆã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š def simple_calculator ( string : str ) -> float : postfix_list = postfix_expression ( string ) stack = [] for item in postfix_list : if isinstance ( item , int ): stack . append ( item ) else : # æ ˆæœ€ä¸Šæ–¹çš„ä¸ºç¬¬äºŒä½å…ƒç´  second = stack . pop () first = stack . pop () if item == '+' : stack . append ( first + second ) elif item == '-' : stack . append ( first - second ) elif item == '*' : stack . append ( first * second ) elif item == '/' : stack . append ( first / second ) return stack [ - 1 ] æœ‰ä¸€ä¸ªéœ€è¦æ³¨æ„çš„ç‚¹ã€‚é€€æ ˆä¸¤ä¸ªå…ƒç´ æ—¶ï¼Œå…ˆè¢«å¼¹å‡ºçš„å…ƒç´ æ˜¯è®¡ç®—è¡¨è¾¾å¼çš„ç¬¬äºŒä½ã€‚ è·‘ä¸¤ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼š assert simple_calculator ( '(10-(15+6/2)/3)*(6+8)' ) == 56 assert simple_calculator ( '11 + 22*( 33*44/55-66)-77/88' ) == - 861.075 æ€»ç»“ ä»¥ä¸Šå°±æ˜¯ç”¨åç¼€è¡¨è¾¾å¼å®ç°ç®€å•è®¡ç®—å™¨çš„å…¨éƒ¨å†…å®¹äº†ã€‚æ€»çš„æ¥è¯´ï¼Œé€»è¾‘å¤æ‚åº¦é›†ä¸­åœ¨ä¸­ç¼€è½¬åç¼€çš„éƒ¨åˆ†ã€‚ å®Œæ•´ä»£ç  é“¾æ¥ ã€‚","tags":"posts","title":""},{"url":"translate-pythonku-jie-shao-shi-yong-luxjin-xing-zhi-neng-ke-shi-shu-ju-fa-xian.html","text":"åŸä½œè€…ï¼š Parul Pandey æ¢ç´¢æ€§çš„æ•°æ®åˆ†ææ˜¯ä¸€ç§æ€åº¦ï¼Œæ˜¯ä¸€ç§çµæ´»æ€§ï¼Œæ˜¯ä¸€ç§å»å¯»æ‰¾é‚£äº›æˆ‘ä»¬è®¤ä¸ºä¸å­˜åœ¨çš„äº‹ç‰©ä»¥åŠæˆ‘ä»¬ç›¸ä¿¡å­˜åœ¨çš„äº‹ç‰©çš„æ„æ„¿ã€‚â€” John W Tukey åœ¨æ•°æ®ç§‘å­¦é¢†åŸŸï¼Œæ•°æ®å¯è§†åŒ–çš„é‡è¦æ€§å’Œå¿…è¦æ€§å¹¶æ²¡æœ‰å¾—åˆ°è¶³å¤Ÿçš„é‡è§†ã€‚ ä¸€å¼ å›¾ç‰‡èƒœè¿‡åƒè¨€ä¸‡è¯­ï¼Œè¿™å¥è¯é€‚ç”¨äºä»»ä½•ä¸æ•°æ®ç›¸å…³çš„é¡¹ç›®çš„ç”Ÿå‘½å‘¨æœŸä¸­ã€‚ ç„¶è€Œå¾ˆå¤šæ—¶å€™ï¼Œå®ç°è¿™äº›å¯è§†åŒ–çš„å·¥å…·å¾€å¾€ä¸å¤Ÿæ™ºèƒ½ã€‚ äº‹å®ä¸Šè¿™æ„å‘³ç€ï¼Œå°½ç®¡æˆ‘ä»¬æœ‰æ•°ä»¥ç™¾è®¡çš„å¯è§†åŒ–åº“ï¼Œä½†å…¶ä¸­ç»å¤§å¤šæ•°éƒ½è¦æ±‚ç”¨æˆ·è‡ªå·±ç¼–å†™å¤§é‡ä»£ç æ‰èƒ½ç»˜åˆ¶ç®€å•å›¾å½¢ã€‚ è¿™ä¼šè®©äººä»¬çš„å…³æ³¨ç„¦ç‚¹è½¬ç§»åˆ°å¯è§†åŒ–çš„å†…éƒ¨æœºåˆ¶ä¸Šï¼Œè€Œä¸æ˜¯çœŸæ­£é‡è¦çš„ä¸œè¥¿ï¼šæ•°æ®å†…çš„å…³ç³»ä¸Šã€‚ å¦‚æœè¯´ç°åœ¨æœ‰ä¸€ç§å·¥å…·å¯ä»¥é€šè¿‡å‘ç”¨æˆ·æ¨èç›¸å…³çš„å¯è§†åŒ–å»ºè®®æ¥ç®€åŒ–æ•°æ®æ¢ç´¢çš„è¿‡ç¨‹å‘¢ï¼Ÿä¸€ä¸ªåä¸ºLuxğŸ’¡çš„æ–°åº“æ¨ªç©ºå‡ºä¸–ï¼Œå®ƒæ­£æ˜¯ä¸ºè§£å†³è¿™äº›é—®é¢˜è€Œå¼€å‘çš„ã€‚ å½“å‰é«˜æ•ˆæ•°æ®æ¢ç´¢é¢ä¸´çš„æŒ‘æˆ˜ å¦‚ä»Šï¼Œæ•°æ®åˆ†æå¸ˆå¯ä»¥ä½¿ç”¨å¤šç§å·¥å…·è¿›è¡Œæ•°æ®æ¢ç´¢ã€‚ å°½ç®¡äº¤äº’å¼Jupyterç¬”è®°æœ¬å…è®¸äººä»¬åœ¨å…¶ä¹‹ä¸Šè¿­ä»£å®éªŒï¼Œè¿˜æœ‰ä¸€äº›å¼ºå¤§çš„BIå·¥å…·ï¼Œå¦‚Power BIå’ŒTableauï¼Œè®©æ™®é€šäººä»…éœ€å•å‡»éå¯å®ç°é«˜çº§åˆ«çš„æ•°æ®æ¢ç´¢ï¼Œå¯å³ä¾¿æœ‰è¿™äº›åŠŸèƒ½å¼ºå¤§çš„å·¥å…·é—®ä¸–ï¼Œé˜»ç¢æ•°æ®æ¢ç´¢æµç¨‹çš„æŒ‘æˆ˜ä»ç„¶å­˜åœ¨ã€‚ å½“æˆ‘ä»¬ä»åœ¨è„‘ä¸­åˆ†æé—®é¢˜è½¬å‘åœ¨å®é™…æ¢å¯»å¯è¡Œçš„è§£å†³æ–¹æ¡ˆæ—¶å°¤å…¶å¦‚æ­¤ã€‚ è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹æ•°æ®åˆ†æå¸ˆå½“å‰é¢ä¸´çš„ä¸‰ä¸ªä¸»è¦çš„ã€å¯è¯†åˆ«çš„éšœç¢ï¼š ä»£ç ä¸äº¤äº’å·¥å…·ä¹‹é—´çš„è„±èŠ‚ è™½ç„¶éœ€è¦ç¼–ç¨‹çš„å·¥å…·æä¾›äº†çµæ´»æ€§ï¼Œä½†æ˜¯ç¼–ç¨‹ç»éªŒè¾ƒå°‘çš„äººé€šå¸¸ä¸ä¼šä½¿ç”¨å®ƒä»¬ã€‚ å¦ä¸€æ–¹é¢ï¼Œè™½ç„¶ç‚¹å‡»äº¤äº’çš„å·¥å…·æ˜“äºä½¿ç”¨ï¼Œä½†å®ƒä»¬çš„çµæ´»æ€§æœ‰é™ä¸”éš¾ä»¥è‡ªå®šä¹‰ã€‚ ç»˜å›¾éœ€è¦å¤§é‡ä»£ç å’Œå…ˆå†³æ¡ä»¶ å…¶æ¬¡ï¼Œéœ€è¦åˆ›å»ºå¯è§†åŒ–æ—¶ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦è€ƒè™‘çš„æ˜¯æ‰€æœ‰çš„è§„æ ¼åº”å½“å¦‚ä½•è¢«å¯è§†åŒ–ã€‚ ä¹‹åæˆ‘ä»¬éœ€è¦å°†è¿™äº›è§„æ ¼çš„ç»†èŠ‚ä¿¡æ¯è½¬æ¢ä¸ºä»£ç ã€‚ ä¸Šå›¾æ˜¾ç¤ºäº†åœ¨ä¸¤ä¸ªæµè¡Œçš„pythonåº“ï¼ˆMatplotlibå’ŒPlotlyï¼‰ä¸­ï¼Œä»…ä»…æ˜¯ä¸ºäº†è¾“å‡ºä¸€ä¸ªæŸ±çŠ¶å›¾å°±éœ€è¦å¤§é‡çš„çš„ä»£ç ã€‚ è¿™ç§æƒ…å†µåŒæ ·ä¼šå½±å“æ•°æ®æµè§ˆï¼Œå°¤å…¶æ˜¯å½“ç”¨æˆ·å¯¹æ‰€è¦æŸ¥æ‰¾çš„å†…å®¹åªæœ‰æ¨¡ç³Šçš„æ¦‚å¿µæ—¶ã€‚ è¯•é”™æ˜¯ä¸€ä¸ªå³ç¹çåˆä»¤äººçª’æ¯çš„è¿‡ç¨‹ æ¯æ¬¡EDAï¼ˆExploratory data analysisï¼‰éƒ½éœ€è¦ä¸æ–­çš„åå¤è¯•éªŒã€‚ ç”¨æˆ·å¿…é¡»å…ˆè¯•éªŒå¤šç§å¯è§†åŒ–æ•ˆæœï¼Œç„¶åæ‰èƒ½ç¡®å®šæœ€ç»ˆçš„å¯è§†åŒ–æ•ˆæœã€‚ åˆ†æäººå‘˜æœ‰å¯èƒ½ä¼šå› æ­¤é”™è¿‡æ•°æ®é›†ä¸­çš„å…³é”®ä¿¡æ¯ã€‚ å¦ä¸€ä¸ªå¸¸è§çš„é—®é¢˜æ˜¯åˆ†æäººå‘˜å¯èƒ½å¹¶ä¸çŸ¥é“åº”è¯¥å¯¹æ•°æ®æ‰§è¡Œå“ªäº›æ“ä½œæ‰èƒ½è·å¾—æ‰€éœ€çš„å…³é”®ä¿¡æ¯ï¼Œå¹¶ä¸”ä»–ä»¬å¾€å¾€ä¼šè¿·å¤±æ–¹å‘ï¼Œæ— æ³•åˆ†æå‡ºæœ‰æ•ˆçš„ç»“è®ºã€‚ åœ¨äººä»¬åˆ†æå’Œæ€è€ƒä»–ä»¬çš„æ•°æ®ä¸å®é™…å¦‚ä½•å¤„ç†æ•°æ®æ‰èƒ½è·å¾—æœ‰ä»·å€¼çš„ä¿¡æ¯ä¹‹é—´å­˜åœ¨æ˜æ˜¾çš„é¸¿æ²Ÿã€‚ Luxæ­£æ˜¯è§£å†³è¿™äº›å¯èƒ½çš„é¸¿æ²Ÿä¸€æ­¥ã€‚ Lux Luxæ˜¯ä¸€ä¸ªæ—¨åœ¨é€šè¿‡è‡ªåŠ¨æ‰§è¡ŒæŸäº›æ–¹é¢çš„æ•°æ®æ¢æŸ¥ï¼Œæ¥å¸®åŠ©ç”¨æˆ·æ¢ç´¢å’Œå‘ç°ä»–ä»¬æ•°æ®ä¸­çš„æœ‰æ„ä¹‰çš„è§è§£çš„Pythonåº“ã€‚å®ƒè¯•å›¾å¼¥åˆä»£ç ä¸äº¤äº’å¼ç•Œé¢ä¹‹é—´çš„é¸¿æ²Ÿã€‚Luxä»¥ä¸€ç§è¡¨æ„è¯­è¨€çš„æ–¹å¼ï¼Œä½¿å¾—åœ¨ç”¨æˆ·ä»…ä»…ç»™å‡ºä¸€ä¸ªæ¨¡ç³Šçš„åˆ†ææ„å›¾çš„æƒ…å†µä¸‹ï¼Œå®ƒä¹Ÿèƒ½è‡ªåŠ¨æ¨æ–­å‡ºå…¶ä¸­æœªæŒ‡å®šçš„ç»†èŠ‚å¹¶å†³å®šé€‚å½“çš„å¯è§†åŒ–æ˜ å°„ã€‚ Luxçš„ç›®æ ‡æ˜¯ï¼Œå³ä½¿æ•°æ®ç§‘å­¦å®¶å¯¹è¿˜æ²¡æƒ³å¥½ä»–ä»¬éœ€è¦ä»€ä¹ˆæœ‰ç”¨çš„ä¿¡æ¯ï¼Œä»–ä»¬ä¹Ÿå¯ä»¥æ›´è½»æ¾åœ°æ¢ç´¢æ•°æ®ã€‚ Luxå°†äº¤äº’å¼å¯è§†åŒ–çš„åŠŸèƒ½ç›´æ¥é›†æˆè¿›äº†Jupyter notebooksï¼Œä»¥å¼¥åˆä»£ç ä¸äº¤äº’å¼ç•Œé¢ä¹‹é—´çš„é¸¿æ²Ÿã€‚ Luxä½¿ç”¨å¼ºå¤§çš„è¡¨æ„è¯­è¨€ï¼Œå…è®¸ç”¨æˆ·æŒ‡å®šå…¶åœ¨åˆ†æä¸­æ„Ÿå…´è¶£çš„éƒ¨åˆ†ä»¥é™ä½ç¼–ç¨‹æˆæœ¬ã€‚ Luxä¼šè‡ªåŠ¨å‘ç”¨æˆ·æä¾›æ•°æ®çš„å¯è§†åŒ–å»ºè®®ã€‚ ç°åœ¨ï¼Œæˆ‘ä»¬å¯¹Luxæ€æ ·å‚ä¸ç”¨æˆ·æ¢ç´¢æ•°æ®æ—¶é‡åˆ°çš„å¸¸è§é—®é¢˜æœ‰äº†ä¸€ä¸ªæ¸…æ™°çš„è®¤è¯†ã€‚ ç°åœ¨è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä½¿ç”¨Luxåº“çš„ç¤ºä¾‹ã€‚ ä¸ºäº†æä¾›ä¸€ä¸ªå¿«é€Ÿæ¼”ç¤ºï¼Œæˆ‘å°†ä½¿ç”¨ä¸€ä¸ªç®€å•çš„æ¡ˆä¾‹ã€‚ åœ¨ä½ å¯¹è¿™ä¸ªä¾‹å­æœ‰äº†æ¸…æ™°åœ°è®¤è¯†ä¹‹åï¼Œä¾¿å¯ä»¥å°†å…¶ä¸ä½ é€‰æ‹©çš„æ•°æ®é›†ç»“åˆä½¿ç”¨ã€‚ æ¡ˆä¾‹ç ”ç©¶ï¼šåˆ†æPalmer PenguinsğŸ§æ•°æ®é›† Palmerä¼é¹…æ•°æ®é›†ç›®å‰å·²æˆä¸ºæ•°æ®ç§‘å­¦ç•Œçš„æ–°å® ï¼Œå®ƒæ˜¯è¢«è¿‡åº¦ä½¿ç”¨çš„Irisæ•°æ®é›†çš„ç›´æ¥æ›¿ä»£å“ã€‚ è¯¥æ•°æ®é›†åŒ…å«344ä¸ªä¼é¹…çš„æ•°æ®ã€‚ æ•°æ®ç”± Kristen Gorman åšå£«å’Œå—ææ´² Palmer Station ç«™æ”¶é›†å¹¶æä¾›ã€‚ é¦–å…ˆè®©æˆ‘ä»¬å®‰è£…å¹¶å¯¼å…¥Luxåº“ã€‚ä½ å¯ä»¥é€šè¿‡ Binder åœ¨Jupyter notbookä¸­ç»§ç»­é˜…è¯»æœ¬æ•™ç¨‹ã€‚ å®‰è£… pip install lux-api # æ¿€æ´»Jupyter notebookæ‰©å±• jupyter nbextension install --py luxwidget jupyter nbextension enable --py luxwidget # æ¿€æ´»Jupyter labæ‹“å±• jupyter labextension install @jupyter-widgets/jupyterlab-manager jupyter labextension install luxwidget æœ‰å…³å¦‚ä½•å°†Luxä¸SQLå¼•æ“é…åˆä½¿ç”¨çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·é˜…è¯» æ–‡æ¡£ ï¼Œè¯¥æ–‡æ¡£éå¸¸è¯¦å®å¹¶ä¸”åŒ…å«è®¸å¤šåŠ¨æ‰‹ç¤ºä¾‹ã€‚ å¯¼å…¥å¿…è¦çš„åº“ä¸æ•°æ®é›† ä¸€æ—¦Luxåº“å®‰è£…å®Œæ¯•ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¯¼å…¥æ•°æ®é›†äº†ã€‚ import pandas as pd import lux df = pd . read_csv ( 'penguins_size.csv' ) df . head () Luxçš„ä¸€ä¸ªä¸é”™çš„ç‚¹æ˜¯å®ƒå¯ä»¥ä¸Pandasæ¡†æ¶ä¸€èµ·ä½¿ç”¨å¹¶ä¸”æ— éœ€å¯¹ç°æœ‰çš„æ ¼å¼è¿›è¡Œä»»ä½•ä¿®æ”¹ã€‚ æ¯”å¦‚è¯´ï¼Œå¦‚æœä½ æƒ³åˆ é™¤ä»»ä½•è¡Œæˆ–åˆ—ï¼ŒLuxçš„å»ºè®®ä¼šæ ¹æ®æ›´æ–°çš„dataframeç”Ÿæˆã€‚Pandasä¸­çš„åˆ é™¤åˆ—ï¼Œå¯¼å…¥CSVç­‰ä¼˜ç§€çš„åŠŸèƒ½ä¹Ÿè¢«ä¿ç•™ã€‚ æ¥ä¸‹æ¥è®©æˆ‘ä»¬æ¥æ¦‚è§ˆä¸€ä¸‹æ•°æ®é›†ã€‚ df . info () æ•°æ®é›†é‡Œæœ‰äº›ç©ºå€¼ï¼Œè®©æˆ‘ä»¬æ‘†è„±å®ƒä»¬ã€‚ df = df . dropna () ç°åœ¨æˆ‘ä»¬çš„æ•°æ®å·²è¢«åŠ è½½è‡³å†…å­˜ï¼Œæ¥ä¸‹æ¥çœ‹Luxå¦‚ä½•ä¸ºæˆ‘ä»¬ç®€åŒ–EDAçš„æµç¨‹ã€‚ ä½¿ç”¨Luxè¿›è¡ŒEDAï¼šæ”¯æŒå¯è§†åŒ–dataframeå·¥ä½œæµ df å½“dataframeè¢«æ‰“å°å‡ºæ¥æ—¶ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„æ˜¯Pandasé»˜è®¤çš„è¡¨æ ¼æ ¼å¼ã€‚æˆ‘ä»¬å¯ä»¥ç‚¹å‡»åˆ‡æ¢æ¥è·å¾—ç”±Luxè‡ªåŠ¨ç”Ÿæˆçš„ä¸€ç»„å¯è§†åŒ–å»ºè®®ã€‚ Luxä¸­çš„å»ºè®®ç»„ç»‡åœ¨ä¸‰ä¸ªä¸åŒçš„é€‰é¡¹å¡ä¸­ï¼Œåˆ†åˆ«è¡¨ç¤ºç”¨æˆ·å¯ä»¥åœ¨å…¶æ¢ç´¢è¿‡ç¨‹ä¸­å¯ä»¥é‡‡å–çš„ä¸‹ä¸€æ­¥ã€‚ ç›¸å…³æ€§é€‰é¡¹å¡ï¼š æ˜¾ç¤ºå®šé‡å±æ€§ä¹‹é—´çš„æˆå¯¹å…³ç³»ï¼ŒæŒ‰æœ€é«˜ç›¸å…³è‡³æœ€ä½ç›¸å…³æ’åºã€‚ æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¼é¹…é³çš„é•¿åº¦ä¸ä½“é‡å‘ˆæ­£ç›¸å…³ã€‚ ä¼é¹…å˜´å³°(culmen)çš„é•¿åº¦å’Œæ·±åº¦ä¹Ÿæ˜¾ç°å‡ºä¸€äº›æœ‰è¶£çš„æ¨¡å¼ï¼Œå®ƒä»¬æ˜¾ç„¶å­˜åœ¨ç€æŸç§è´Ÿç›¸å…³ã€‚ å…·ä½“æ¥è¯´ï¼Œ\"å˜´å³°\"å°±æ˜¯é¸Ÿç±»çš„ä¸Šè„Šã€‚ åˆ†å¸ƒé€‰é¡¹å¡: æ˜¾ç¤ºä¸€ç»„å•å˜é‡åˆ†å¸ƒï¼ŒæŒ‰ååº¦ä»å¤§åˆ°å°æ’åºã€‚ å‡ºç°ç‡é€‰é¡¹å¡: æ˜¾ç¤ºäº†ä¸€ç»„ä»æ•°æ®é›†ä¸­ç”Ÿæˆçš„æ¡å½¢å›¾ã€‚ æ­¤é€‰é¡¹å¡å±•ç¤ºäº†ä¸‰ç§ä¸åŒçš„ä¼é¹… - Adelie ï¼Œ Chinstrap å’Œ Gentoo ã€‚ è¿˜æœ‰ä¸‰ä¸ªä¸åŒçš„å²›å±¿ï¼Œåˆ†åˆ«æ˜¯ Torgersen ï¼Œ Biscoe å’Œ Dream ã€‚ è¢«åŒ…å«åœ¨æ•°æ®é›†ä¸­é›„æ€§å’Œé›Œæ€§å‡ºç°ç‡ä¹Ÿèƒ½åœ¨å›¾è¡¨ä¸­æ¸…æ¥šçš„çœ‹åˆ°ã€‚ åŸºäºæ„å›¾çš„å»ºè®® é™¤äº†åŸºæœ¬çš„æ¨èåŠŸèƒ½å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šåˆ†ææ„å›¾ã€‚ æ¯”æ–¹è¯´ï¼Œæˆ‘ä»¬æƒ³æ‰¾å‡ºå˜´å³°é•¿åº¦éšä¼é¹…ç‰©ç§å˜åŒ–çš„æ¨¡å¼ã€‚ æˆ‘ä»¬å¯ä»¥åœ¨æ­¤å¤„å°†æ„å›¾è®¾ç½®ä¸º ['culmen_length_mm'ï¼Œ'species'] ã€‚å†æ¬¡æ‰“å°æ•°æ®æ¡†æ—¶ï¼Œå°±å¯ä»¥çœ‹åˆ°æ¨èå·²ç»ç¼–ç¨‹ä¸æˆ‘ä»¬æŒ‡å®šçš„æ„å›¾ç›¸å…³çš„å†…å®¹ã€‚ df . intent = [ 'culmen_length_mm' , 'species' ] df åœ¨ä¸‹å›¾çš„å·¦ä¾§ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„æ˜¯ä¸æ‰€é€‰å±æ€§ç›¸å¯¹åº”çš„ Current Visualization ã€‚ å³ä¾§åˆ™æ˜¯ Enhace ï¼šå³åœ¨å‘å½“å‰é€‰æ‹©ä¸­æ·»åŠ å±æ€§æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚ è¿˜æœ‰ Filter é€‰é¡¹å¡ï¼Œå…è®¸åœ¨å›ºå®šé€‰æ‹©çš„å˜é‡çš„åŒæ—¶æ·»åŠ è¿‡æ»¤å™¨ã€‚ å¦‚æœæˆ‘ä»¬ä»”ç»†è§‚å¯Ÿç‰©ç§å†…éƒ¨çš„ç›¸å…³æ€§ï¼Œåˆ™ä¼šå‘ç°å˜´å³°é•¿åº¦å’Œæ·±åº¦æ˜¯æ­£ç›¸å…³çš„ï¼Œä¸ä¹‹å‰çš„æ¨æµ‹æ­£ç›¸åã€‚ è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„ è¾›æ™®æ£®æ‚–è®º çš„ä¾‹å­ã€‚ æœ€åï¼Œé€šè¿‡æ¯”è¾ƒé³çŠ¶è‚¢çš„é•¿åº¦ä¸å˜´å³°çš„é•¿åº¦ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆæ¸…æ¥šåœ°å°†è¿™ä¸‰ä¸ªç‰©ç§åˆ†å¼€ã€‚ ç”¨æ’ä»¶å¯¼å‡ºå¯è§†åŒ–ç»“æœ Luxä½¿å¾—å¯¼å‡ºå’Œåˆ†äº«ç”Ÿæˆçš„å¯è§†åŒ–ç»“æœå˜å¾—å¼‚å¸¸ç®€å•ã€‚è¿™äº›å¯è§†åŒ–å›¾è¡¨å¯ä»¥ä»¥å¦‚ä¸‹æ–¹å¼è¢«å¯¼å‡ºæˆé™æ€çš„HTMLæ–‡ä»¶ï¼š df.save_as_html('file.html') æˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡ recommendation å±æ€§è·å¾—ä¸ºdataframeç”Ÿæˆçš„ å»ºè®®é›† ã€‚ å®ƒçš„è¿”å›æ ¼å¼ä¸ºå­—å…¸ï¼Œç”±æ¨èç±»åˆ«çš„åç§°æ„æˆå­—å…¸çš„å…³é”®å­—ã€‚ df . recommendation ä»¥ä»£ç çš„æ ¼å¼å¯¼å‡ºå¯è§†åŒ–ç»“æœ æˆ‘ä»¬ä¸ä»…å¯ä»¥å°†å¯è§†åŒ–å¯¼å‡ºä¸ºHTMLï¼Œè¿˜å¯ä»¥å°†å…¶å¯¼å‡ºä¸ºä»£ç ã€‚ ä¸‹é¢çš„GIFæ˜¾ç¤ºäº†å¦‚ä½•åœ¨ å‘ç”Ÿç‡é€‰é¡¹å¡ ä¸­æŸ¥çœ‹ç¬¬ä¸€ä¸ªæ¡å½¢å›¾çš„ä»£ç ã€‚ ä¹‹åæˆ‘ä»¬å¯ä»¥å°†å¯è§†åŒ–ç»“æœå¯¼å‡ºæˆä»£ç è‡³ Altair ä¸­ï¼Œä»¥ä¾¿è¿›è¡Œè¿›ä¸€æ­¥ç¼–è¾‘æˆ–ä½œä¸º Vega-Lite è§„èŒƒã€‚ ä½ å¯ä»¥åœ¨ è¿™ä¸ªæ–‡æ¡£ä¸­ æ‰¾åˆ°æ›´å¤šè¯¦ç»†ä¿¡æ¯ã€‚ ç›¸å…³èµ„æºå’Œç»ƒä¹  ä¸Šé¢çš„ä¸€ç³»åˆ—æ¼”ç¤ºåªæ˜¯ä¸€ä¸ªç®€å•çš„å…¥é—¨æ•™ç¨‹ã€‚ Luxçš„Github ä¸­åŒ…å«è®¸å¤šèµ„æºä»¥åŠæœ‰å…³å¦‚ä½•ä½¿ç”¨Luxçš„äº¤äº’å¼Binder notebookã€‚ é‚£é‡Œå°†ä¼šæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„èµ·ç‚¹ã€‚ æ­¤å¤–ï¼Œè¿™é‡Œè¿˜æœ‰è¿˜æœ‰è¯¦ç»†çš„ æ–‡æ¡£ ã€‚ lux-binder ç»“è®ºä¸ä¸‹ä¸€æ­¥ åœ¨ä»¥ä¸Šæ–‡ç« ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†å¦‚ä½•é€šè¿‡ä½¿ç”¨Luxæ¥å®Œå…¨è½¬æ¢Jupyter notebookä¸­çš„æ•°æ®åˆ†æå·¥ä½œæµã€‚ Luxæä¾›äº†æ›´å¤šçš„è§†è§‰ä¸°å¯Œæ€§ä»¥é¼“åŠ±æœ‰æ„ä¹‰çš„æ•°æ®æ¢ç´¢ã€‚ Luxä»åœ¨ ç§¯æå¼€å‘ ä¸­ï¼Œå…¶ç»´æŠ¤è€…å¸Œæœ›ä»æ­£åœ¨ä½¿ç”¨æˆ–å¯èƒ½å¯¹ä½¿ç”¨Luxæ„Ÿå…´è¶£çš„ç”¨æˆ·å¾—åˆ°æ›´å¤šåé¦ˆã€‚ å¦‚æœæ‚¨æœ‰å…´è¶£ä¸ºè¿™ä¸ªåº“åšè´¡çŒ®ï¼Œè¯·å¡«å†™ä»¥ä¸‹è¡¨æ ¼ã€‚ è¿™å°†å¸®åŠ©å›¢é˜Ÿäº†è§£ä»–ä»¬å¦‚ä½•ä¸ºæ‚¨æ”¹è¿›å·¥å…·ã€‚","tags":"posts","title":"[Translate] Pythonåº“ä»‹ç»ï¼šä½¿ç”¨Luxè¿›è¡Œæ™ºèƒ½å¯è§†æ•°æ®å‘ç°"},{"url":"translate-pythonzhong-ru-he-jiang-duo-ge-can-shu-chuan-ru-maphan-shu.html","text":"æ¥æºï¼š How to Pass Multiple Arguments to a map Function in Python ä½œè€…ï¼šMiguel Brito åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä¼šç»™å¤§å®¶å±•ç¤ºå½“æœ‰å¤šä¸ªå‚æ•°éœ€è¦ä¼ å…¥ map å‡½æ•°æ—¶æˆ‘çš„å¤„ç†æ–¹å¼ã€‚è¿™ä¸ªæ–¹æ³•ä¸ä»…é€‚ç”¨äºæ™®é€šçš„ map æ–¹æ³•ï¼ŒåŒæ—¶ä½ ä¹Ÿèƒ½ä»¥åŒæ ·çš„æŠ€å·§ç»™ concurrent.futures.Executor.map å’Œ multiprocessing.Pool ä¼ å…¥å¤æ•°ä¸ªå‚æ•°ã€‚ é—®é¢˜ å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå«åš sum_four çš„å‡½æ•°ï¼Œå®ƒæ¥æ”¶å››ä¸ªå‚æ•°å¹¶ä¸”è¿”å›å®ƒä»¬çš„æ€»å’Œã€‚ >>> def sum_four ( a , b , c , d ): return a + b + c + d åŒæ—¶æˆ‘ä»¬å‡è®¾ä½ åœ¨è§£å†³ä¸€ä¸ªéå¸¸ç‰¹æ®Šçš„é—®é¢˜ï¼Œè¯¥é—®é¢˜è¦æ±‚å›ºå®šä»¥ä¸Šå‡½æ•°å‰ä¸‰ä¸ªå‚æ•°ã€‚åœ¨ä»…æ”¹å˜æœ€åä¸€ä¸ªå‚æ•°çš„æ¡ä»¶ä¸‹ï¼Œè¯•å›¾æ¯”è¾ƒè¯¥å‡½æ•°çš„ä¸åŒè¡Œä¸ºã€‚ >>> a , b , c = 1 , 2 , 3 >>> sum_four ( a = a , b = b , c = c , d = 1 ) 7 >>> sum_four ( a = a , b = b , c = c , d = 2 ) 8 >>> sum_four ( a = a , b = b , c = c , d = 3 ) 9 >>> sum_four ( a = a , b = b , c = c , d = 4 ) 10 å¦‚æœè¯´å› ä¸ºä½ å–œæ¬¢å‡½æ•°å¼ç¼–ç¨‹æˆ–è€…ä½ æ¥è‡ªä¸€é—¨é¼“åŠ±è¿™ä¸€èŒƒå¼çš„è¯­è¨€ï¼ˆ*è¯´çš„å°±æ˜¯ä½ ï¼ŒHaskellï¼‰ï¼Œæ‰€ä»¥ä½ æ¸´æœ›ä½¿ç”¨ map å‡½æ•°æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸éš¾æƒ³åˆ°ï¼Œæ—¢ç„¶åªæœ‰ d åœ¨å˜åŒ–ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†è¦æµ‹è¯•çš„æ‰€æœ‰å¯èƒ½å€¼å­˜åœ¨åˆ—è¡¨é‡Œ ds = [1, 2, 3, 4] ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œç»™å®šä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªåŒ…å«å¤šä¸ªå…ƒç´ çš„åˆ—è¡¨ï¼Œå¦‚æœä½ æƒ³å°†è¿™ä¸ªåˆ—è¡¨ä¼ å…¥ä¸€ä¸ªåªæ¥å—å•ä¸ªå…ƒç´ çš„ map æ–¹æ³•ï¼Œè¯¥æ€ä¹ˆåšï¼Ÿ æ–¹æ¡ˆ 1 ç¬¬ä¸€ä¸ªæ–¹æ¡ˆæ˜¯ç”¨ itertools.starmap æ¥æ›¿ä»£ map å‡½æ•°ã€‚è¯¥å‡½æ•°æ¥å—ä¸€ä¸ªå‡½æ•°åŠä¸€ä¸ªç”±å…ƒç»„ç»„æˆçš„å¯è¿­ä»£( iterable )å¯¹è±¡ä½œä¸ºå‚æ•°ã€‚ startmap ä¼šéå†å„ä¸ªå…ƒç»„ t ï¼Œä¹‹åå°†å®ƒä»¬è§£åŒ…å¹¶ä½œä¸ºå‚æ•°æ‰§è¡Œå‡½æ•°ï¼Œç±»ä¼¼äº for t in tuples: function(*t) ã€‚ ä¸ºäº†è®©äº‹æƒ…æ›´åŠ ç›´è§‚ï¼Œç»™ä»¥ä¸‹ç¤ºä¾‹ä¾›æ€è€ƒï¼š >>> import itertools >>> ds = [ 1 , 2 , 3 , 4 ] >>> items = (( a , b , c , d ) for d in ds ) >>> list ( items ) [( 1 , 2 , 3 , 1 ), ( 1 , 2 , 3 , 2 ), ( 1 , 2 , 3 , 3 ), ( 1 , 2 , 3 , 4 )] >>> list ( itertools . starmap ( sum_four , items )) [ 7 , 8 , 9 , 10 ] å¦‚ä½ æ‰€è§ï¼Œåˆ—è¡¨ä¸­æœ‰å¾ˆå¤šé‡å¤çš„å…ƒç´ ï¼Œå½“åˆ—è¡¨è¿‡é•¿æ—¶å®ƒä»¬ä¼šä¸å¯é¿å…åœ°æ¶ˆè€—è®¸å¤šå†…å­˜ã€‚ä½œä¸ºæ”¹è¿›ï¼Œæˆ‘å°† items è®¾è®¡æˆç”Ÿæˆå™¨ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åªå°†æ­£åœ¨å¤„ç†çš„å…ƒç´ åŠ è½½è‡³å†…å­˜ä¸­äº†ã€‚ æ–¹æ¡ˆ 2 ç¬¬äºŒä¸ªæ–¹æ¡ˆæ˜¯é€šè¿‡ æŸ¯é‡ŒåŒ– å¹¶åˆ›å»ºä¸€ä¸ªæ–°çš„åå‡½æ•°ã€‚æ ¹æ®æ–‡æ¡£ï¼Œ partial() ä¼š\"å†»ç»“\"å‡½æ•°çš„æŸéƒ¨åˆ†å‚æ•°å’Œ(æˆ–)å…³é”®å­—ï¼Œä»è€Œç”Ÿæˆä¸€ä¸ªå…·æœ‰ç®€åŒ–ç­¾åçš„æ–°å‡½æ•°ã€‚ In [ 29 ]: import functools In [ 30 ]: partial_sum_four = functools . partial ( sum_four , a , b , c ) In [ 31 ]: partial_sum_four ( 3 ) Out [ 31 ]: 9 In [ 32 ]: list ( map ( partial_sum_four , ds )) Out [ 32 ]: [ 7 , 8 , 9 , 10 ] æ–¹æ¡ˆ 3 ç¬¬ä¸‰ä¸ªé€‰æ‹©æ˜¯ä½¿ç”¨ itertools.repeat ã€‚è¿™ä¸ªå‡½æ•°äº§ç”Ÿä¸€ä¸ªè¿­ä»£å™¨ï¼Œè¯¥è¿­ä»£å™¨ä¼šä¸€éåˆä¸€éçš„è¿”å›å¯¹è±¡ã€‚å¦‚æœä½ æ²¡æœ‰æŒ‡å®š_times_è¿™ä¸€å‚æ•°çš„è¯ï¼Œå°±å¯ä»¥æ— é™æ¬¡åœ°éå†å®ƒã€‚æ¥ä¸‹æ¥è®©æˆ‘ä»¬ä»”ç»†çœ‹ä¸€ä¸‹ map() çš„ ç­¾å ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªå‡½æ•°åŠå¤šä¸ªå¯è¿­ä»£å¯¹è±¡ä½œä¸ºå‚æ•°ï¼Œ map(function, iterable, ...) ã€‚ æ ¹æ®æ–‡æ¡£ä¸­çš„æè¿°ï¼Œ å¦‚æœä¼ é€’äº†é¢å¤–çš„ iterable ä½œä¸ºå‚æ•°ï¼Œåˆ™ function å¿…é¡»èƒ½å¤Ÿæ¥æ”¶å’Œæ‰€æœ‰å¯è¿­ä»£å¯¹è±¡æ•°é‡ç›¸åŒçš„å‚æ•°ï¼Œå¹¶ä¸”æ‰€æœ‰å¯è¿­ä»£å¯¹è±¡çš„å…ƒç´ å°†ä¼šåŒæ—¶å¹¶è¡Œåœ°ä½œç”¨äºè¯¥å‡½æ•°ã€‚å½“æœ‰å¤æ•°ä¸ªå¯è¿­ä»£å¯¹è±¡æ—¶ï¼Œæœ€çŸ­çš„å¯è¿­ä»£å¯¹è±¡è€—å°½åˆ™æ•´ä¸ªè¿­ä»£å°±å°†ç»“æŸã€‚ Bingo ï¼æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ itertools.repeat() æ¥åˆ¶ä½œ a ï¼Œ b ï¼Œ c çš„æ— ç©·è¿­ä»£å™¨ã€‚å½“æœ€çŸ­çš„å¯è¿­ä»£å¯¹è±¡â€”â€” ds è¢«è€—å°½æ—¶ï¼Œ map å°±ä¼šåœæ­¢ã€‚ >>> import itertools >>> list ( map ( sum_four , itertools . repeat ( a ), itertools . repeat ( b ), itertools . repeat ( c ), ds )) [ 7 , 8 , 9 , 10 ] æ¢ä¸€ç§æ–¹å¼çš„è¯ï¼Œä½¿ç”¨ repeat() å¤§è‡´ç­‰æ•ˆäºï¼š >>> list ( map ( sum_four , [ 1 , 1 , 1 , 1 ], [ 2 , 2 , 2 , 2 ], [ 3 , 3 , 3 , 3 ], ds )) [ 7 , 8 , 9 , 10 ] ä½ æ— éœ€å¤ªæ‹…å¿ƒå†…å­˜çš„é—®é¢˜ï¼Œå› ä¸ºå…ƒç´ åªæœ‰åœ¨è¢«ä½¿ç”¨æ—¶æ‰ä¼šè¢«ç”Ÿæˆã€‚äº‹å®ä¸Šï¼Œ repeat è¿”å›ä¸€ä¸ª repeatobject å¯¹è±¡ï¼Œè€Œä¸æ˜¯ list [ ref ]ã€‚ é—®é¢˜ 2ï¼šå¦‚ä½•ä¼ é€’å¤šä¸ªå‚æ•° multiprocessing.Pool.map ? è¿™æ˜¯ä¸€ä¸ªå’Œæ™®é€š map() å‡½æ•°ä¸å¤šä¸ªå‚æ•°äº¤äº’ç±»ä¼¼çš„é—®é¢˜ã€‚å‡è®¾æˆ‘ä»¬çš„è¦æé«˜ä»£ç æ€§èƒ½ï¼Œå°† sum_four å¹¶è¡Œè¿è¡Œåœ¨ä¸åŒè¿›ç¨‹ä¸­ã€‚å¥½æ¶ˆæ¯æ˜¯ä¸Šè¿°çš„å¤§éƒ¨åˆ†æ–¹æ¡ˆå¯ä»¥é€‚ç”¨äºè¿™ä¸€æ–°çš„åœºæ™¯ä¸­ï¼Œé™¤äº†ä¸€ä¸ªä¾‹å¤–ï¼š Pool.map åªæ¥æ”¶å•ä¸€çš„å¯è¿­ä»£å¯¹è±¡ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬ä¸å†èƒ½å¤Ÿä½¿ç”¨ repeat() ï¼Œé‚£è®©æˆ‘ä»¬çœ‹çœ‹å…¶ä»–æ–¹æ¡ˆå§ã€‚ ä½¿ç”¨ starmap >>> from multiprocessing import Pool >>> import itertools >>> def sum_four ( a , b , c , d ): return a + b + c + d >>> a , b , c = 1 , 2 , 3 >>> ds = [ 1 , 2 , 3 , 4 ] >>> items = [( a , b , c , d ) for d in ds ] >>> items [( 1 , 2 , 3 , 1 ), ( 1 , 2 , 3 , 2 ), ( 1 , 2 , 3 , 3 ), ( 1 , 2 , 3 , 4 )] >>> with Pool ( processes = 4 ) as pool : res = pool . starmap ( sum_four , items ) >>> res [ 7 , 8 , 9 , 10 ] ä½¿ç”¨ partial() >>> import functools >>> partial_sum_four = functools . partial ( sum_four , a , b , c ) >>> with Pool ( processes = 4 ) as pool : res = pool . map ( partial_sum_four , ds ) >>> res [ 7 , 8 , 9 , 10 ] é—®é¢˜ 3ï¼š å¦‚ä½•ä¼ é€’å¤šä¸ªå‚æ•°ç»™ concurrent.futures.Executor.map ? concurrent.futures æ¨¡å—æä¾›äº†ä¸€ç§å« Executor çš„é«˜å±‚æ¥å£æ¥è¿è¡Œå¼‚æ­¥è¿è¡Œå¯è°ƒç”¨å¯¹è±¡( callable )ã€‚ å½“å‰çš„ç‰ˆæœ¬ä¸­è¿™ä¸€æ¥å£å­˜åœ¨ä¸¤ç§ä¸åŒçš„å®ç°æ–¹å¼ï¼Œå³ ThreadPoolExecutor å’Œ ProcessPoolExecutor ã€‚ä¸ multiprocessing.Pool ç›¸åçš„æ˜¯ï¼Œ Executor æ²¡æœ‰ startmap() æ–¹æ³•ï¼Œä½†æ˜¯å®ƒçš„ map() å®ç°æ”¯æŒå¤šä¸ªå¯è¿­ä»£å¯¹è±¡ã€‚è¿™å…è®¸æˆ‘ä»¬ä½¿ç”¨ repeat() å‡½æ•°ã€‚å¦å¤–ä¸€ä¸ªåŒºåˆ«æ˜¯ Executor.map è¿”å›çš„æ˜¯ç”Ÿæˆå™¨è€Œéåˆ—è¡¨ã€‚ ä½¿ç”¨ partial() >>> from concurrent.futures import ProcessPoolExecutor >>> import functools >>> def sum_four ( a , b , c , d ): return a + b + c + d >>> a , b , c = 1 , 2 , 3 >>> ds = [ 1 , 2 , 3 , 4 ] >>> partial_sum_four = functools . partial ( sum_four , a , b , c ) >>> with ProcessPoolExecutor ( max_workers = 4 ) as pool : res = list ( pool . map ( partial_sum_four , ds )) >>> res [ 7 , 8 , 9 , 10 ] ä½¿ç”¨ repeat() >>> from concurrent.futures import ProcessPoolExecutor >>> from itertools import repeat >>> def sum_four ( a , b , c , d ): return a + b + c + d >>> a , b , c = 1 , 2 , 3 >>> ds = [ 1 , 2 , 3 , 4 ] >>> with ProcessPoolExecutor ( max_workers = 4 ) as pool : res = list ( pool . map ( sum_four , repeat ( a ), repeat ( b ), repeat ( c ), ds )) >>> res [ 7 , 8 , 9 , 10 ] ç»“è®º ä¼™è®¡ä»¬ï¼è¿™å°±æ˜¯ä»Šå¤©çš„å…¨éƒ¨å†…å®¹äº†ã€‚å¸Œæœ›ä½ èƒ½å­¦åˆ°ä¸€äº›æœ‰ç”¨å’Œç‰¹åˆ«çš„ä¸œè¥¿ã€‚ map() å‡½æ•°ä½¿å¾—Pythonæœ‰ä¸ªå‡½æ•°å¼ç¼–ç¨‹è¯­è¨€çš„æ„Ÿè§‰ã€‚ map() ä¸ä»…æ˜¯ä¸€ä¸ªç½®å‡½æ•°ï¼Œè¿˜å¯ä»¥ä½œä¸º multiprocessing å’Œ concurrent.futures æ¨¡å—çš„æ–¹æ³•ä½¿ç”¨ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘å±•ç¤ºäº†å¦‚ä½•åœ¨ map å‡½æ•°é‡Œå¤„ç†å¤šä¸ªå‚æ•°ã€‚å¦‚æœä½ å–œæ¬¢è¿™ç¯‡æ–‡ç« ï¼Œè¯·è€ƒè™‘ä¸ä½ çš„æœ‹å‹ä»¬åˆ†äº«ï¼ å¦å¤–ï¼Œè¯·éšæ—¶å…³æ³¨æˆ‘ï¼š miguendes.me ã€‚ ä½ å¯èƒ½ä¼šå–œæ¬¢æˆ‘çš„å…¶ä»–æ–‡ç« ï¼š How to Use datetime.timedelta in Python With Examples 73 Examples to Help You Master Python's f-strings How to Check if an Exception Is Raised (or Not) With pytest 3 Ways to Test API Client Applications in Python Everything You Need to Know About Python's Namedtuples The Best Way to Compare Two Dictionaries in Python 5 Hidden Python Features You Probably Never Heard Of","tags":"posts","title":"[Translate] Pythonä¸­å¦‚ä½•å°†å¤šä¸ªå‚æ•°ä¼ å…¥mapå‡½æ•°"},{"url":"review-guess-word-and-hangman-game.html","text":"Guess max score word è¿™ä¸ªæ¸¸æˆæ¥è‡ª Pybites ã€‚ æ•´ä¸ªæ¸¸æˆçš„æµç¨‹æ˜¯è¿™æ ·çš„ï¼š é¦–å…ˆéšæœºçš„ç»™å‡ºåä¸ªè‹±æ–‡å­—æ¯ï¼Œå¦‚ O, S, J, I, O, O, R, H, X, D , ä¹‹åç©å®¶ä»¥è¿™äº›å­—æ¯æ‹¼å‡ºåˆç†çš„è‹±æ–‡å•è¯ã€‚ä»¥ç»™å‡ºå­—æ¯ä¸ºä¾‹ï¼Œå¯ä»¥ç»„æˆ DOOR ï¼Œä½†æ— æ³•ä½¿ç”¨è¶…è¿‡ç»™å‡ºå­—æ¯æ•°é‡çš„å•è¯æ¥ç»„è¯ã€‚ä¹‹åä¼šæ ¹æ®å­—æ¯çš„ç¨€æœ‰åº¦ç»™ç©å®¶æ‰€ç»„å•è¯æ¥æ‰“åˆ†ï¼Œå¦‚ E ã€ A ç­‰å­—æ¯ä¸ºä¸€åˆ†ï¼Œè€Œ Y , Z ç­‰å­—æ¯åˆ™ç®—ä½œå…«ä¹åˆ†ã€‚ç³»ç»ŸåŒæ—¶è®¡ç®—å‡ºè¿™äº›å­—æ¯å®é™…èƒ½ç»„æˆçš„æœ€é«˜åˆ†çš„å•è¯ï¼Œå¹¶è®¡ç®—ç©å®¶çš„æ‰“åˆ†æ¯”ä¾‹ã€‚å¦‚æœæˆ‘ä»¬çŒœæµ‹çš„å€¼ä¸º DOOR ï¼Œåˆ™æˆ‘ä»¬è·å¾—çš„å­—æ¯åˆ†ä¸ºäº”åˆ†ï¼Œè€Œç»™å‡ºçš„å­—æ¯èƒ½ç»„æˆçš„æœ€é«˜åˆ†å•è¯ä¸º SHOJI (å•†ä¼š)åˆ†å€¼ä¸ºåäº”åˆ†ï¼Œæˆ‘ä»¬çš„å¾—åˆ†æ¯”ä¾‹åˆ™ä¸º33%ã€‚ è¯¥æ¸¸æˆçš„æºç å¯åœ¨æ­¤ è·å¾— ã€‚ åœ¨å¯»æ‰¾ç»™å‡ºå­—æ¯èƒ½ç»„æˆçš„æœ€é«˜åˆ†å•è¯æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†ä»¥ä¸‹ä»£ç : def get_possible_dict_words ( draw ): \"\"\"Get all possible words from draw which are valid dictionary words. Use the _get_permutations_draw helper and DICTIONARY constant\"\"\" return set ( DICTIONARY ) & set ( map ( \"\" . join , _get_permutations_draw ( draw ))) def _get_permutations_draw ( draw ): \"\"\"Helper for get_possible_dict_words to get all permutations of draw letters. Hint: use itertools.permutations\"\"\" for length in range ( 1 , len ( draw ) + 1 ): yield from set ( itertools . permutations ( draw , length )) _get_permutations_draw ç”Ÿæˆå™¨ä½¿ç”¨äº† itertools.permutations æ–¹æ³•ç”Ÿæˆäº†æ‰€ç»™å•è¯ç»„çš„æ‰€æœ‰é•¿åº¦çš„æ’åˆ—ã€‚è¿™é‡Œ ab å’Œ ba è¦è¢«ä½œä¸ºä¸¤ä¸ªå•è¯å­˜åœ¨ï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨æ’åˆ—ã€‚æˆ‘åœ¨ç”Ÿæˆå™¨é‡Œå°±æ—©æ—©ä½¿ç”¨äº† set æ–¹æ³•å»é‡ï¼Œä¹‹ååœ¨ get_possible_dict_words æ–¹æ³•é‡Œåˆå°†ç»„æˆçš„å­—ç¬¦ä¸²å†æ¬¡å»é‡ï¼Œå®é™…ä¸Šæ˜¯æ²¡æœ‰å¿…è¦çš„ã€‚å¯ä»¥åªä¿ç•™åé¢ä¸€ä¸ªå»é‡æ­¥éª¤æ¥æé«˜æ•´ä½“å‡½æ•°çš„è¿è¡Œæ•ˆç‡ã€‚ åœ¨ get_possible_dict_words ä¸­ï¼Œæˆ‘è¿ç”¨äº†pythoné›†åˆçš„äº¤é›†æ“ä½œæ¥å–å¾—æ‰€æœ‰åœ¨å­—å…¸é‡Œçš„æœ‰æ•ˆè¯ç»„ç»„åˆã€‚æœ€ç»ˆè¿”å›æ‰€è¦æ±‚çš„å•è¯é›†åˆã€‚ é‚£äº›æœ€é«˜åˆ†çš„å•è¯ä¸­éƒ½æ˜¯ä¸€äº›å†·é—¨è¯æ±‡ï¼Œæ‰€ä»¥æ€»çš„æ¥è¯´ï¼Œè¿™è¿˜æ˜¯ä¸ªæ¯”è¾ƒæœ‰è¶£çš„æ¸¸æˆã€‚ Hangman è¿™é‡Œè¿˜æœ‰å¦ä¸€ä¸ªæœ‰æ„æ€çš„ Hangman å°æ¸¸æˆã€‚ Hangmanæ˜¯ä¸€ç³»åˆ—çŒœè¯æ¸¸æˆçš„ç®€ç§°ã€‚åœ¨æˆ‘ä»¬çš„Hangmanä¸­ï¼Œæˆ‘ä»¬éœ€è¦çŒœçš„æ˜¯ç”µæºçš„è‹±æ–‡åç§°ã€‚æ¯æ¬¡å¤±è´¥å°†éƒ½ä¼šåœ¨Hangmanæ·»åŠ ä¸€ç¬”ï¼Œæœ€ç»ˆå½¢æˆä¸€å‰¯å®Œæ•´çš„Hangmanå›¾ï¼Œæ¸¸æˆå¤±è´¥ã€‚ ________ | | | 0 | /|\\ | / \\ |\"\"\" è¯¥æ¸¸æˆçš„æºç å¯åœ¨æ­¤ è·å¾— ã€‚ é¦–å…ˆæˆ‘ä»¬å…ˆå¤„ç†ä¸€ä¸‹è¦çŒœçš„å•è¯ï¼š def _construct_word ( self , word : str ) -> defaultdict : character_dict = defaultdict ( set ) for index , character in enumerate ( word ): if character . strip () and character in ASCII : character_dict [ character ] . add ( index ) return character_dict åœ¨æ­¤æˆ‘ä»¬å°†æ‰€æœ‰çš„æœ‰æ•ˆå­—æ¯åŠå…¶åºå·ä¿å­˜åœ¨å­—å…¸ä¸­ï¼Œå¦‚ tootsie ä¸­çš„ o åˆ™è¢«ä¿å­˜ä¸º o: (1, 2) ã€‚æ­¤å¤–ï¼Œå°†è°œé¢ä½œä¸ºä¸€ä¸ªåˆ—è¡¨å‚¨å­˜ï¼Œè¿˜æœªæ­æ™“çš„æ•°å­—ç”¨ PlACEHOLDER æ›¿ä»£ï¼Œåˆ™çŒœåˆ° o åçš„è°œé¢ä¸º ['_', 'o', 'o', '_', '_', '_', '_'] ã€‚è¿™æ ·åœ¨ä¹‹åç©å®¶çŒœåˆ°å­—å…¸ä¸­çš„å­—æ¯æ—¶æˆ‘ä»¬: 1.å°†è¯¥å­—æ¯ä»å­—å…¸é‡Œå¼¹å‡ºï¼›2.å°†è°œé¢åˆ—è¡¨ä¸­æ‰€æœ‰è¯¥å­—æ¯å‚¨å­˜çš„åºå·çš„å…ƒç´ æ›¿æ¢ä¸ºè¯¥å­—æ¯ã€‚å½“å­—å…¸é‡Œæ²¡æœ‰å…ƒç´ æ—¶å€™ï¼Œç”¨æˆ·ä¾¿çŒœå‡ºäº†ç›¸å…³å•è¯ã€‚ å¦å¤–éœ€è¦è€ƒè™‘çš„æ˜¯ç”¨æˆ·çŒœæµ‹å¤±è´¥çš„ä¾‹å­ï¼Œæœ‰ä¸¤ç§æƒ…å†µä¼šå¯¼è‡´ä¸€æ¬¡çŒœæµ‹çš„å¤±è´¥ã€‚ä¸€æ˜¯ç”¨æˆ·æ‰€çŒœå­—æ¯ä¸åœ¨æˆ‘ä»¬æ‰€ç»™çš„è°œåº•ä¹‹ä¸­ï¼Œè¿™æ—¶æˆ‘ä»¬è¾“å‡ºä¸€å¼ Hangmançš„å›¾ç‰‡ï¼Œå¦‚æœç”¨æˆ·çš„é”™è¯¯æ¬¡æ•°è¿‡å¤šå°†å¯¼è‡´æ¸¸æˆçš„å¤±è´¥ã€‚äºŒæ˜¯ç”¨æˆ·çŒœäº†ä¸€ä¸ªä¹‹å‰çŒœè¿‡çš„å­—æ¯ï¼Œæˆ‘ä»¬è¿™æ—¶ä»æ…ˆçš„å¼¹å‡ºæç¤ºå¹¶ç»™äºˆç”¨æˆ·ä¸€æ¬¡é¢å¤–çš„çŒœæµ‹æœºä¼šã€‚è¿™éƒ¨åˆ†å®ç°çš„ä»£ç å¦‚ä¸‹: @types . coroutine def _hangman_popper ( self ): \"\"\"print a hangman graph if guess is not right\"\"\" guessed_character = set () graphics = hang_graphics () graph = next ( graphics ) while True : guess = yield False if guess not in guessed_character : guessed_character . add ( guess ) if guess in self . _word : print ( f '{colored(len(self._word[guess]),\"green\")} of {colored(guess,\"green\")} in the word.' ) for index in self . _word . pop ( guess ): self . _guess [ index ] = guess if not self . _word : yield True else : print ( f '{colored(guess,\"green\")} is not in the word! \\n ' f ' {graph} \\n ' ) try : graph = next ( graphics ) except StopIteration : raise NoChance else : print ( f 'You have guessed {colored(guess,\"green\")} before, please choose another character. \\n ' ) è¾“å‡ºè¶Šæ¥è¶Šå®Œæ•´çš„Hangmanå›¾ç‰‡æ˜¯ä»¥ç”Ÿæˆå™¨çš„æ–¹å¼å®ç°çš„ï¼Œè¿™å¯å‘äº†æˆ‘ä»¥åç¨‹çš„æ–¹å¼å®ç°æ¸¸æˆä¸ç”¨æˆ·çš„äº¤äº’è¿‡ç¨‹ã€‚åç¨‹æœ‰ä¸‰ç§è¾“å‡ºï¼Œåˆ†åˆ«æ˜¯çŒœæµ‹å¤±è´¥æ—¶çš„ yield False ï¼Œå®Œæˆè°œåº•æ—¶çš„ yield True å’Œæœºä¼šç”¨å®Œæ—¶çš„ raise NoChane ã€‚ä¸€ä¸ªè¿˜éœ€è¦æ³¨æ„çš„åœ°æ–¹æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦åœ¨Hangmanç±»çš„æ„é€ å‡½æ•°ä¸­é¢„æ¿€è¯¥ç”Ÿæˆå™¨ã€‚ è¿™ä¹Ÿæ˜¯ä¸€ä¸ªç›¸å½“é•¿çŸ¥è¯†çš„æ¸¸æˆï¼Œä¸ä»…å¦‚æ­¤ï¼Œç”¨åç¨‹å®ç°çš„è¿‡ç¨‹ä¹Ÿæ˜¯ç›¸å½“æœ‰è¶£çš„ï¼Œæ˜¯ä¸€ç§ä¸ä¸€æ ·çš„ç¼–ç¨‹ä½“éªŒã€‚ Additional","tags":"posts","title":"[Review] Guess word and hangman game"},{"url":"stackoverflow-list-generator-algorithms.html","text":"Faltten nested lists with indices è¿™ä¸ªé—®é¢˜æ¥è‡ª StackOverflow ã€‚ å¯¹äºä¸€ä¸ªåµŒå¥—çš„åˆ—è¡¨L: L = [[[ 1 , 2 , 3 ], [ 4 , 5 ]], [ 6 ], [ 7 ,[ 8 , 9 ]], 10 ] å¸Œæœ›æœ‰ä¸€ä¸ªå‡½æ•°èƒ½å¤Ÿyieldå‡ºæ¯ä¸ªå…ƒç´ çš„åµŒå¥—ä½ç½®å…ƒç»„ï¼š ( 1 , ( 0 , 0 , 0 )) ( 2 , ( 0 , 0 , 1 )) ( 3 , ( 0 , 0 , 2 )) ( 4 , ( 0 , 1 , 0 )) ( 5 , ( 0 , 1 , 1 )) ( 6 , ( 1 , 0 )) ( 7 , ( 2 , 0 )) ( 8 , ( 2 , 1 , 0 )) ( 9 , ( 2 , 1 , 1 )) ( 10 , ( 3 ,)) ä»¥ 4 ä¸ºä¾‹ï¼Œå…ƒç»„ (0,1,0) ä»£è¡¨å®ƒå¤„äºç¬¬ä¸€å±‚çš„ é¦–ä¸ªåˆ—è¡¨ ä¸­çš„ ç¬¬äºŒä¸ªåˆ—è¡¨ çš„ ç¬¬ä¸€ä¸ªå…ƒç´  çš„çš„ä½ç½®ä¸Šã€‚ ä¹‹å‰æˆ‘ä¹Ÿé‡åˆ°è¿‡ä¸€ä¸ª yield from çš„ç¤ºä¾‹ï¼Œåœ¨æ­¤ä¸å¾—ä¸æä¸€ä¸‹ def flatten ( iter ): for item in iter : if isinstance ( item , list ): yield from flatten ( item ) else : yield item è¿™ä¸ªå‡½æ•°ç”¨é€’å½’çš„æ–¹å¼è®²åµŒå¥—åˆ—è¡¨é‡Œçš„å…ƒç´ å–å‡ºï¼Œ yield å‡ºä¸€ä¸ª flatten ç‰ˆæœ¬çš„åˆ—è¡¨ï¼š [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ã€‚ å›å½’åˆ°è¿™ä¸ªé—®é¢˜ï¼Œæé—®è€…ç»™å‡ºäº†ä¸€ä¸ªåŸºäºé€’å½’å’Œç”Ÿæˆå™¨çš„è§£å†³æ–¹æ¡ˆï¼š def flatten ( l ): for i , e in enumerate ( l ): try : for x , y in flatten ( e ): yield x , ( i ,) + y except : yield e , ( i ,) è¿™ä¸ªå‡½æ•°çš„å…³é”®åœ¨äºåˆ©ç”¨äº†å…ƒç»„åŠ æ³•çš„æ€§è´¨ (1, 2) + (3,) = (1, 2, 3) æ¥è¿”å›å‡ºåµŒå¥—ä½ç½®çš„ä¿¡æ¯ï¼Œè€Œå…ƒç»„æœ¬èº«åˆ™æ˜¯ç”±å˜é‡ e å’Œ x ä¼ é€’ã€‚ è€Œåº•ä¸‹çš„ç­”æ¡ˆåˆ™æä¾›äº†ä¸€ä¸ªéé€’å½’çš„æ–¹æ¡ˆï¼š def flatten ( l ): stack = [ enumerate ( l )] path = [ None ] while stack : for path [ - 1 ], x in stack [ - 1 ]: if isinstance ( x , list ): stack . append ( enumerate ( x )) path . append ( None ) else : yield x , tuple ( path ) break else : stack . pop () path . pop () è¿™ä¸ªç®—æ³•å®šä¹‰äº†ä¸¤ä¸ªæ ˆ stack å’Œ path ã€‚ path ç”¨æ¥å­˜å‚¨å½“å‰è¿½è¸ªå…ƒç´ çš„åµŒå¥—ä½ç½®ä¿¡æ¯ï¼Œè€Œ stack åˆ™æ˜¯ä»¥å¤–å±‚è‡³å†…å±‚çš„é¡ºåºå°†åˆ—è¡¨çš„ enumerate è¿­ä»£å™¨å…¥æ ˆã€‚å¹¶æŒ‰å±‚æ¬¡éå†ã€‚ç®—æ³•æœ¬èº«å·§å¦™çš„ä¸€ç‚¹æ˜¯å°†å…¥æ ˆçš„åˆå§‹ä½ç½®ç½®ä¸º None ï¼Œä¹‹åå†é€šè¿‡å¯¹ enumerate çš„æ‹†åŒ…ç”¨å…ƒç´ çš„ä½ç½®ä¿¡æ¯æ›¿æ¢ path æ ˆçš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚è¿™ä¸ªæ–¹æ³•æ²¡æœ‰ä½¿ç”¨é€’å½’ã€‚ Iterate through array while finding the mean of the top k elements æ¥æºäºStack Overflowçš„é—®é¢˜: Python iterate through array while finding the mean of the top k elements ã€‚ é—®é¢˜çš„æè¿°æ˜¯è¿™æ ·çš„ï¼šå¯¹äºä¸€ä¸ªåˆ—è¡¨ a = [3, 5, 2, 7, 5, 3, 6, 8, 4] , æˆ‘ä»¬å¸Œæœ›æ‰¾åˆ°æ‰€æœ‰è¿ç»­ä¸‰ä¸ªå…ƒç´ ä¸­æœ€å¤§ä¸¤ä¸ªå…ƒç´ çš„å‡å€¼ã€‚å¯¹äºä¸¾ä¾‹çš„åˆ—è¡¨ a å°†ç”Ÿæˆåˆ—è¡¨ [4, 6, 6, 6, 5.5, 7, 7] ã€‚é¦–ä¸ªè¿ç»­ä¸‰å…ƒç´ ç»„åˆ [3, 5, 2] çš„è®¡ç®—ç»“æœä¸º 4 ã€‚ æˆ‘ä»¬å¯æŠŠæ•´ä¸ªé—®é¢˜åˆ†è§£æˆä¸‰ä¸ªéƒ¨åˆ†ï¼š 1. è·å¾—æ¯ä¸ªè¿ç»­ä¸‰å…ƒç»„ 2. å–å‡ºå‰ä¸¤å¤§çš„å…ƒç´  3. è®¡ç®—å¹³å‡å€¼ã€‚å¯¹äºæ‰€æœ‰é—®é¢˜ï¼Œæˆ‘æ¯”è¾ƒå–œæ¬¢è¿™ä¸ªè§£ç­”ï¼š # Sliding window def windowed_iterator ( iterable , n = 2 ): iterators = itertools . tee ( iterable , n ) iterators = ( itertools . islice ( it , i , None ) for i , it in enumerate ( iterators )) yield from zip ( * iterators ) windows = windowed_iterator ( iterable = a , n = 3 ) # Top 2 elements from heapq import nlargest top_n = map ( lambda x : nlargest ( 2 , x ), windows ) # Mean from statistics import mean means = map ( mean , top_n ) æ¯”è¾ƒæœ‰è¶£çš„æ˜¯ Sliding window çš„éƒ¨åˆ†ï¼Œè¿™é‡Œæˆ‘ä»¬ç”¨ itertools.tee ç”Ÿæˆä¸‰ä¸ªç‹¬ç«‹çš„è¿­ä»£å™¨ã€‚å¹¶ä¸”ç”¨ islice å’Œ zip è¿›è¡Œé”™ä½å’Œç»„åˆï¼Œæœ€ç»ˆç”Ÿæˆè¿ç»­ä¸‰å…ƒç»„åºåˆ—ã€‚ Additional","tags":"posts","title":"StackOverflow list generator algorithms"},{"url":"build-a-circular-list-and-regex-trie.html","text":"Dancing programs è¿™ä¸ªé—®é¢˜æ¥è‡ª Advent of code çš„ ç¬¬åå…­æ—¥ ã€‚ è§£å†³ä»£ç å¦‚ä¸‹: def solution ( lst , order ): # å¾ªç¯æ•°ç»„ï¼Œstartä¸ºå¤´æŒ‡é’ˆ result_list = list ( order ) # å‡å°‘Partneræ—¶é—´å¤æ‚åº¦çš„å­—å…¸ result_dict = { s : i for i , s in enumerate ( result_list )} length = len ( result_list ) start = 0 for action in lst : if action . startswith ( 's' ): start = ( start + length ) % length - int ( action [ 1 :]) continue if action . startswith ( 'x' ): x , y = action [ 1 :] . split ( '/' ) x_real = ( start + int ( x )) % length y_real = ( start + int ( y )) % length elif action . startswith ( 'p' ): x , y = action [ 1 :] . split ( '/' ) x_real = result_dict [ x ] y_real = result_dict [ y ] result_list [ x_real ], result_list [ y_real ] = result_list [ y_real ], result_list [ x_real ] result_dict [ result_list [ x_real ]], result_dict [ result_list [ y_real ]] = result_dict [ result_list [ y_real ]], \\ result_dict [ result_list [ x_real ]] return \"\" . join ( result_list [ i % length ] for i in range ( start , start + length )) def solution2 ( lst ï¼Œ order ): orders = [] while order not in orders : orders . append ( order ) order = solution ( lst , order ) return orders [ 1000000000 % len ( orders )] å¯¹äºç¬¬ä¸€éƒ¨åˆ†æ¶‰åŠåˆ°çš„ä¸‰ä¸ªæ“ä½œã€‚ç¬¬ä¸€ä¸ªæ“ä½œSpin sX ï¼Œåªéœ€å°†å¤´æŒ‡é’ˆåç§»Xä½ã€‚å¯¹äºç¬¬äºŒä¸ªæ“ä½œExchangeå’Œç¬¬ä¸‰ä¸ªæ“ä½œPartnerï¼Œç”±äºæ¶‰åŠåˆ°indexå’Œå€¼çš„æ¯”è¾ƒï¼Œå› æ­¤æˆ‘ä»¬é€šè¿‡å»ºç«‹{å€¼ï¼šindex}å­—å…¸çš„å½¢å¼æ¥å‡å°‘Partneræ“ä½œçš„æ—¶é—´å¤æ‚åº¦ã€‚ ç¬¬äºŒéƒ¨åˆ†é—®é¢˜ç”±äºè¦å¾ªç¯ä¸€äº¿æ¬¡ï¼Œå…¨éƒ¨éå†æ—¶é—´å¤æ‚åº¦è¿‡é«˜ã€‚æµ‹è¯•å‘ç°å½“è¾“å…¥ç›¸åŒçš„æ“ä½œåºåˆ—æ—¶ï¼Œå¤šæ¬¡éå†åä¼šå‡ºç°å¾ªç¯çš„æƒ…å†µï¼Œå› æ­¤æœ‰è§£æ³•äºŒã€‚ Regex replacement æ¥æºäºStack Overflowçš„ä¸€ä¸ªé—®é¢˜: Speed up millions of regex replacements in Python 3 ã€‚ èµåŒæœ€å¤šçš„ \"\\b(word1|word2|word3)\\b\" æ–¹æ³•å…¶å®ä¸æ˜¯æœ€å¥½çš„ç®—æ³•ï¼Œæ­£åˆ™å¹¶é›†ä¼šå¸¦æ¥O(1)çš„æœ€å¥½æ—¶é—´å¤æ‚åº¦ï¼ŒO(n)çš„å¹³å‡åŠæœ€å·®æ—¶é—´å¤æ‚åº¦ã€‚éªŒè¯ä»£ç å¦‚ä¸‹ï¼š import re import timeit import random with open ( '/usr/share/dict/american-english' ) as wordbook : english_words = [ word . strip () . lower () for word in wordbook ] random . shuffle ( english_words ) print ( \"First 10 words :\" ) print ( english_words [: 10 ]) test_words = [ ( \"Surely not a word\" , \"#surely_NÃ¶TÃ¤WORD_so_regex_engine_can_return_fast\" ), ( \"First word\" , english_words [ 0 ]), ( \"Last word\" , english_words [ - 1 ]), ( \"Almost a word\" , \"couldbeaword\" ) ] def find ( word ): def fun (): return union . match ( word ) return fun for exp in range ( 1 , 6 ): print ( \" \\n Union of %d words\" % 10 ** exp ) union = re . compile ( r \"\\b( %s )\\b\" % '|' . join ( english_words [: 10 ** exp ])) for description , test_word in test_words : time = timeit . timeit ( find ( test_word ), number = 1000 ) * 1000 print ( \" %-17s : %.1f ms\" % ( description , time )) Output: First 10 words : [ \"geritol's\" , \"sunstroke's\" , 'fib' , 'fergus' , 'charms' , 'canning' , 'supervisor' , 'fallaciously' , \"heritage's\" , 'pastime' ] Union of 10 words Surely not a word : 0.7 ms First word : 0.8 ms Last word : 0.7 ms Almost a word : 0.7 ms Union of 100 words Surely not a word : 0.7 ms First word : 1.1 ms Last word : 1.2 ms Almost a word : 1.2 ms Union of 1000 words Surely not a word : 0.7 ms First word : 0.8 ms Last word : 9.6 ms Almost a word : 10.1 ms Union of 10000 words Surely not a word : 1.4 ms First word : 1.8 ms Last word : 96.3 ms Almost a word : 116.6 ms Union of 100000 words Surely not a word : 0.7 ms First word : 0.8 ms Last word : 1227.1 ms Almost a word : 1404.1 ms è¿™ä¼šå¯¼è‡´æ•´ä½“ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å˜ä¸ºO(n&#94;2),å› æ­¤æœ‰å¦‚ä¸‹ä¸¤ä¸ªè§£æ³•ï¼š import re with open ( '/usr/share/dict/american-english' ) as wordbook : banned_words = set ( word . strip () . lower () for word in wordbook ) def delete_banned_words ( matchobj ): word = matchobj . group ( 0 ) if word . lower () in banned_words : return \"\" else : return word sentences = [ \"I'm eric. Welcome here!\" , \"Another boring sentence.\" , \"GiraffeElephantBoat\" , \"sfgsdg sdwerha aswertwe\" ] * 250000 for sentence in sentences : sentence = re . sub ( '\\w+' , delete_banned_words , sentence ) è¿™ä¸ªè§£æ³•æ—¶é—´å‘å¤æ‚åº¦ä¸ºO(n)ï¼Œä½†æ˜¯ä¼šåœ¨å»æ‰å•è¯æ—¶ç•™ä¸‹ç©ºæ ¼ã€‚å› ä¸ºå®ƒæ˜¯æ‰«æ \\w+ çš„ï¼Œå› æ­¤æ— æ³•é¿å…è¿™ä¸ªé—®é¢˜ã€‚ ä¸€ä¸ªå¯¹ä¹‹å‰æ­£åˆ™å¹¶é›†çš„æ”¹è¿›æ˜¯é€šè¿‡å­—å…¸æ ‘çš„æ–¹å¼åˆ›å»ºæ­£åˆ™å¹¶é›†ï¼Œè¯¥ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸ºO(n)ã€‚ class Trie (): \"\"\"Regex::Trie in Python. Creates a Trie out of a list of words. The trie can be exported to a Regex pattern. The corresponding Regex should match much faster than a simple Regex union.\"\"\" def __init__ ( self ): self . data = {} def add ( self , word ): ref = self . data for char in word : ref [ char ] = char in ref and ref [ char ] or {} ref = ref [ char ] ref [ '' ] = 1 def dump ( self ): return self . data def quote ( self , char ): return re . escape ( char ) def _pattern ( self , pData ): data = pData if \"\" in data and len ( data . keys ()) == 1 : return None alt = [] cc = [] q = 0 for char in sorted ( data . keys ()): if isinstance ( data [ char ], dict ): recurse = self . _pattern ( data [ char ]) if recurse : alt . append ( self . quote ( char ) + recurse ) else : cc . append ( self . quote ( char )) else : q = 1 cconly = not len ( alt ) > 0 if len ( cc ) > 0 : if len ( cc ) == 1 : alt . append ( cc [ 0 ]) else : alt . append ( '[' + '' . join ( cc ) + ']' ) if len ( alt ) == 1 : result = alt [ 0 ] else : result = \"(?:\" + \"|\" . join ( alt ) + \")\" if q : if cconly : result += \"?\" else : result = \"(?: %s )?\" % result return result def pattern ( self ): return self . _pattern ( self . dump ()) è¿™æ®µä»£ç é¦–å…ˆä¼šç”Ÿæˆæ‰€æœ‰è¢«banå•è¯çš„å­—å…¸æ ‘ï¼Œç„¶åparseè¯¥æ ‘ç”Ÿæˆåƒå¦‚ä¸‹è¿™æ ·çš„æ­£åˆ™è¡¨è¾¾å¼ï¼š ( ? : a ( ? : ( ? :\\ 's|a(?:\\' s | chen | liyah ( ? :\\ 's)?|r(?:dvark(?:(?:\\' s | s )) ? | on )) | b ( ? :\\ 's|a(?:c(?:us(?:(?:\\' s | es )) ? |[ ik ] ) | ft | lone ( ? : ( ? :\\ 's|s))?|ndon(?:(?:ed|ing|ment(?:\\' s ) ? | s )) ? | s ( ? : e ( ? : ( ? : ment ( ? :\\ 's)?|[ds]))?|h(?:(?:e[ds]|ing))?|ing)|t(?:e(?:(?:ment(?:\\' s ) ? |[ ds ] )) ? | ing | toir ( ? : ( ? :\\ 's|s))?))|b(?:as(?:id)?|e(?:ss(?:(?:\\' s | es )) ? | y ( ? : ( ? :\\ 's|s))?)|ot(?:(?:\\' s | t ( ? :\\ 's)?|s))?|reviat(?:e[ds]?|i(?:ng|on(?:(?:\\' s | s )) ? )) | y ( ? :\\ 's)?|\\Ã©(?:(?:\\' s | s )) ? ) | d ( ? : icat ( ? : e [ ds ] ? | i ( ? : ng | on ( ? : ( ? :\\ 's|s))?))|om(?:en(?:(?:\\' s | s )) ? | inal ) | u ( ? : ct ( ? : ( ? : ed | i ( ? : ng | on ( ? : ( ? :\\ 's|s))?)|or(?:(?:\\' s | s )) ? | s )) ? | l ( ? :\\ 's)?))|e(?:(?:\\' s | am | l ( ? : ( ? :\\ 's|ard|son(?:\\' s ) ? )) ? | r ( ? : deen ( ? :\\ 's)?|nathy(?:\\' s ) ? | ra ( ? : nt | tion ( ? : ( ? :\\ 's|s))?))|t(?:(?:t(?:e(?:r(?:(?:\\' s | s )) ? | d ) | ing | or ( ? : ( ? :\\ 's|s))?)|s))?|yance(?:\\' s ) ? | d )) ? | hor ( ? : ( ? : r ( ? : e ( ? : n ( ? : ce ( ? :\\ 's)?|t)|d)|ing)|s))?|i(?:d(?:e[ds]?|ing|jan(?:\\' s ) ? ) | gail | l ( ? : ene | it ( ? : ies | y ( ? :\\ 's)?)))|j(?:ect(?:ly)?|ur(?:ation(?:(?:\\' s | s )) ? | e [ ds ] ? | ing )) | l ( ? : a ( ? : tive ( ? : ( ? :\\ 's|s))?|ze)|e(?:(?:st|r))?|oom|ution(?:(?:\\' s | s )) ? | y ) | m \\ 's|n(?:e(?:gat(?:e[ds]?|i(?:ng|on(?:\\' s ) ? )) | r ( ? :\\ 's)?)|ormal(?:(?:it(?:ies|y(?:\\' s ) ? ) | ly )) ? ) | o ( ? : ard | de ( ? : ( ? :\\ 's|s))?|li(?:sh(?:(?:e[ds]|ing))?|tion(?:(?:\\' s | ist ( ? : ( ? :\\ 's|s))?))?)|mina(?:bl[ey]|t(?:e[ds]?|i(?:ng|on(?:(?:\\' s | s )) ? ))) | r ( ? : igin ( ? : al ( ? : ( ? :\\ 's|s))?|e(?:(?:\\' s | s )) ? ) | t ( ? : ( ? : ed | i ( ? : ng | on ( ? : ( ? :\\ 's|ist(?:(?:\\' s | s )) ? | s )) ? | ve ) | s )) ? ) | u ( ? : nd ( ? : ( ? : ed | ing | s )) ? | t ) | ve ( ? : ( ? :\\ 's|board))?)|r(?:a(?:cadabra(?:\\' s ) ? | d ( ? : e [ ds ] ? | ing ) | ham ( ? :\\ 's)?|m(?:(?:\\' s | s )) ? | si ( ? : on ( ? : ( ? :\\ 's|s))?|ve(?:(?:\\' s | ly | ness ( ? :\\ 's)?|s))?))|east|idg(?:e(?:(?:ment(?:(?:\\' s | s )) ? |[ ds ] )) ? | ing | ment ( ? : ( ? :\\ 's|s))?)|o(?:ad|gat(?:e[ds]?|i(?:ng|on(?:(?:\\' s | s )) ? ))) | upt ( ? : ( ? : e ( ? : st | r ) | ly | ness ( ? :\\ 's)?))?)|s(?:alom|c(?:ess(?:(?:\\' s | e [ ds ]| ing )) ? | issa ( ? : ( ? :\\ 's|[es]))?|ond(?:(?:ed|ing|s))?)|en(?:ce(?:(?:\\' s | s )) ? | t ( ? : ( ? : e ( ? : e ( ? : ( ? :\\ 's|ism(?:\\' s ) ? | s )) ? | d ) | ing | ly | s )) ? ) | inth ( ? : ( ? :\\ 's|e(?:\\' s ) ? )) ? | o ( ? : l ( ? : ut ( ? : e ( ? : ( ? :\\ 's|ly|st?))?|i(?:on(?:\\' s ) ? | sm ( ? :\\ 's)?))|v(?:e[ds]?|ing))|r(?:b(?:(?:e(?:n(?:cy(?:\\' s ) ? | t ( ? : ( ? :\\' s | s )) ? ) | d ) | ing | s )) ? | pti ... Additional","tags":"posts","title":"Build a circular list and regex trie"},{"url":"top-10-python-libraries-of-2017.html","text":"December is the time when you sit back and think about the accomplishments of the past year. For us programmers, this is often looking at the open source libraries that were either released this year (or close enough), or whose popularity has recently boomed because they are simply great tools to solve a particular problem. For the past two years , we have done this in the form of a blog post with what we consider to be some of the best work that has been done in the Python community. Now, as we are wrapping up 2017, we had to do the same. This time, the list comes with a Machine Learning (ML) flavor . Forgive us, authors of great non-ML libraries, but we are just too biased ;) Hopefully, people in the comments help us do some justice and mention other great pieces of software, some of which have surely have escaped our radar. So, without further ado, here it goes! 1. Pipenv We couldn't make this list without reserving the top spot for a tool that was only released early this year, but has the power to affect the workflow of every Python developer, especially more now since it has become the officially recommended tool on Python.org for managing dependencies! Pipenv, originally started as a weekend project by the awesome Kenneth Reitz , aims to bring ideas from other package managers (such as npm or yarn ) into the Python world. Forget about installing virtualenv , virtualenvwrapper , managing requirements.txt files and ensuring reproducibility with regards to versions of dependencies of the dependencies (read here for more info about this). With Pipenv, you specify all your dependencies in a Pipfile â€” which is normally built by using commands for adding, removing, or updating dependencies. The tool can generate a Pipfile.lock file, enabling your builds to be deterministic , helping you avoid those difficult to catch bugs because of some obscure dependency that you didn't even think you needed. Of course, Pipenv comes with many other perks and has great documentation , so make sure to check it out and start using it for all your Python projects, as we do at Tryolabs :) 2. PyTorch If there is a library whose popularity has boomed this year, especially in the Deep Learning (DL) community, it's PyTorch, the DL framework introduced by Facebook this year. PyTorch builds on and improves the (once?) popular Torch framework, especially since it's Python based â€” in contrast with Lua. Given how people have been switching to Python for doing data science in the last couple of years, this is an important step forward to make DL more accessible. Most notably, PyTorch has become one of the go-to frameworks for many researchers, because of its implementation of the novel Dynamic Computational Graph paradigm. When writing code using other frameworks like TensorFlow , CNTK or MXNet , one must first define something called a computational graph . This graph specifies all the operations that will be run by our code, which are later compiled and potentially optimized by the framework, in order to allow for it to be able to run even faster, and in parallel on a GPU. This paradigm is called Static Computational Graph , and is great since you can leverage all sorts of optimizations and the graph, once built, can potentially run in different devices (since execution is separate from building ). However, in many tasks such as Natural Language Processing, the amount of \"work\" to do is often variable: you can resize images to a fixed resolution before feeding them to an algorithm, but cannot do the same with sentences which come in variable length. This is where PyTorch and dynamic graphs shine, by letting you use standard Python control instructions in your code, the graph will be defined when it is executed, giving you a lot of freedom which is essential for several tasks. Of course, PyTorch also computes gradients for you (as you would expect from any modern DL framework), is very fast, and extensible , so why not give it a try? 3. Caffe2 It might sound crazy, but Facebook also released another great DL framework this year. The original Caffe framework has been widely used for years, and known for unparalleled performance and battle-tested codebase. However, recent trends in DL made the framework stagnate in some directions. Caffe2 is the attempt to bring Caffe to the modern world. It supports distributed training, deployment (even in mobile platforms), the newest CPUs and CUDA-capable hardware. While PyTorch may be better for research, Caffe2 is suitable for large scale deployments as seen on Facebook. Also, check out the recent ONNX effort . You can build and train your models in PyTorch, while using Caffe2 for deployment! Isn't that great? 4. Pendulum Last year, Arrow , a library that aims to make your life easier while working with datetimes in Python, made the list. This year, it is the turn of Pendulum. One of Pendulum's strength points is that it is a drop-in replacement for Python's standard datetime class, so you can easily integrate it with your existing code, and leverage its functionalities only when you actually need them. The authors have put special care to ensure timezones are handled correctly, making every instance timezone-aware and UTC by default. You will also get an extended timedelta to make datetime arithmetic easier. Unlike other existing libraries, it strives to have an API with predictable behavior, so you know what to expect. If you are doing any non trivial work involving datetimes, this will make you happier! Check out the docs for more. 5. Dash You are doing data science, for which you use the excellent available tools in the Python ecosystem like Pandas and scikit-learn . You use Jupyter Notebooks for your workflow, which is great for you and your colleagues. But how do you share the work with people who do not know how to use those tools? How do you build an interface so people can easily play around with the data, visualizing it in the process? It used to be the case that you needed a dedicated frontend team, knowledgeable in Javascript, for building these GUIs. Not anymore. Dash, announced this year , is an open source library for building web applications, especially those that make good use of data visualization, in pure Python. It is built on top of Flask , Plotly.js and React , and provides abstractions that free you from having to learn those frameworks and let you become productive quickly. The apps are rendered in the browser and will be responsive so they will be usable in mobile devices. If you would like to know more about what is possible with Dash, the Gallery is a great place for some eye-candy. 6. PyFlux There are many libraries in Python for doing data science and ML, but when your data points are metrics that evolve over time (such as stock prices, measurements obtained from instruments, etc), that is not the case. PyFlux is an open source library in Python built specifically for working with time series . The study of time series is a subfield of statistics and econometrics, and the goals can be describing how time series behave (in terms of latent components or features of interest), and also predicting how they will behave the future. PyFlux allows for a probabilistic approach to time series modeling, and has implementations for several modern time series models like GARCH . Neat stuff. 7. Fire It is often the case that you need to make a Command Line Interface (CLI) for your project. Beyond the traditional argparse , Python has some great tools like click or docopt . Fire, announced by Google this year , has a different take on solving this same problem. Fire is an open source library that can automatically generate a CLI for any Python project. The key here is automatically : you almost don't need to write any code or docstrings to build your CLI! To do the job, you only need to call a Fire method and pass it whatever you want turned into a CLI: a function, an object, a class, a dictionary, or even pass no arguments at all (which will turn your entire code into a CLI). Make sure to read the guide so you understand how it works with examples. Keep it under your radar, because this library can definitely save you a lot of time in the future. 8. imbalanced-learn In an ideal world, we would have perfectly balanced datasets and we would all train models and be happy. Unfortunately, the real world is not like that, and certain tasks favor very imbalanced data. For example, when predicting fraud in credit card transactions, you would expect that the vast majority of the transactions (+99.9%?) are actually legit. Training ML algorithms naively will lead to dismal performance, so extra care is needed when working with these types of datasets. Fortunately, this is a studied research problem and a variety of techniques exist. Imbalanced-learn is a Python package which offers implementations of some of those techniques, to make your life much easier. It is compatible with scikit-learn and is part of scikit-learn-contrib projects. Useful! 9. FlashText When you need to search for some text and replace it for something else, as is standard in most data-cleaning work, you usually turn to regular expressions. They will get the job done, but sometimes it happens that the number of terms you need to search for is in the thousands, and then, reg exp can become painfully slow to use. FlashText is a better alternative just for this purpose. In the author's initial benchmark , it improved the runtime of the entire operation by a huge margin: from 5 days to 15 minutes. The beauty of FlashText is that the runtime is the same no matter how many search terms you have, in contrast with regexp in which the runtime will increase almost linearly with the number of terms. FlashText is a testimony to the importance of the design of algorithms and data structures, showing that, even for simple problems, better algorithms can easily outdo even the fastest CPUs running naive implementations. 10. Luminoth Disclaimer: this library was built by Tryolabs' R&D area. Images are everywhere nowadays, and understanding their content can be critical for several applications. Thankfully, image processing techniques have advanced a lot, fueled by the advancements in DL. Luminoth is an open source Python toolkit for computer vision, built using TensorFlow and Sonnet . Currently, it out-of-the-box supports object detection in the form of a model called Faster R-CNN. But Luminoth is not only an implementation of a particular model. It is built to be modular and extensible, so customizing the existing pieces or extending it with new models to tackle different problems should be straightforward, with as much code reuse as there can be. It provides tools for easily doing the engineering work that are needed when building DL models: converting your data (in this case, images) to adequate format for feeding your data pipeline ( TensorFlow's tfrecords ), doing data augmentation, running the training in one or multiple GPUs (distributed training will be a must when working with large datasets), running evaluation metrics, easily visualizing stuff in TensorBoard and deploying your trained model with a simple API or browser interface, so people can play around with it. Moreover, Luminoth has straightforward integration with Google Cloud's ML Engine , so even if you don't own a powerful GPU, you can train in the cloud with a single command, just as you do in your own local machine. If you are interested in learning more about what's behind the scenes, you can read the announcement blog post and watch the video of our talk at ODSC. Bonus: watch out for these PyVips You may have never heard of the libvips library. In that case, you must know that it's an image processing library, like Pillow or ImageMagick , and supports a wide range of formats. However, when comparing to other libraries, libvips is faster and uses less memory . For example, some benchmarks show it to be about 3x faster and use less than 15x memory as ImageMagick. You can read more about why libvips is nice here . PyVips is a recently released Python binding for libvips, which is compatible with Python 2.7-3.6 (and even PyPy), easy to install with pip and drop-in compatible with the old binding, so if you are using that, you don't have to modify your code. If doing some sort of image processing in your app, definitely something to keep an eye on. Requestium Disclaimer: this library was built by Tryolabs. Sometimes, you need to automatize some actions in the web. Be it when scraping sites, doing application testing, or filling out web forms to perform actions in sites that do not expose an API, automation is always necessary. Python has the excellent Requests library which allows you perform some of this work, but unfortunately (or not?) many sites make heavy client side use of Javascript. This means that the HTML code that Requests fetches, in which you could be trying to find a form to fill for your automation task, may not even have the form itself! Instead, it will be something like an empty div of some sort that will be generated in the browser with a modern frontend library such as React or Vue . One way to solve this is to reverse-engineer the requests that Javascript code makes, which will mean many hours of debugging and fiddling around with (probably) uglified JS code. No thanks. Another option is to turn to libraries like Selenium , which allow you to programmatically interact with a web browser and run the Javascript code. With this, the problems are no more, but it is still slower than using plain Requests which adds very little overhead. Wouldn't it be cool if there was a library that let you start out with Requests and seamlessly switch to Selenium, only adding the overhead of a web browser when actually needing it? Meet Requestium, which acts as a drop-in replacement for Requests and does just that. It also integrates Parsel , so writing all those selectors for finding the elements in the page is much cleaner than it would otherwise be, and has helpers around common operations like clicking elements and making sure stuff is actually rendered in the DOM. Another time saver for your web automation projects! skorch You like the awesome API of scikit-learn, but need to do work using PyTorch? Worry not, skorch is a wrapper which will give PyTorch an interface like sklearn. If you are familiar with those libraries, the syntax should be straightforward and easy to understand. With skorch, you will get some code abstracted away, so you can focus more on the things that really matter, like doing your data science. Conclusion What an exciting year! If you know of a library that deserves to be on this list, make sure you mention it in the comments below. There are so many good developments that it's hard to keep up. As usual, thanks to everybody in the community for such great work! Finally, don't forget to subscribe to our newsletter so that you don't miss out future editions of this post or our ML related content.","tags":"Python","title":"Top 10 Python libraries of 2017"},{"url":"find-longest-word-in-dictionary-that-is-a-subsequence-of-a-given-string.html","text":"Description Given a string S and a set of words D , find the longest word in D that is a subsequence of S . Word W is a subsequence of S if some number of characters, possibly zero, can be deleted from S to form W , without reordering the remaining characters. Note: D can appear in any format (list, hash table, prefix tree, etc. For example, given the input of S = \"abppplee\" and D = {\"able\", \"ale\", \"apple\", \"bale\", \"kangaroo\"} the correct output would be \"apple\" . The words \"able\" and \"ale\" are both subsequences of S, but they are shorter than \"apple\". The word \"bale\" is not a subsequence of S because even though S has all the right letters, they are not in the right order. The word \"kangaroo\" is the longest word in D, but it isn't a subsequence of S. Solution Check each dictionary word using a greedy algorithm ä¸€ä¸ªæ¯”è¾ƒå®¹æ˜“æƒ³åˆ°çš„æ–¹æ³•å°±æ˜¯å°†å­—å…¸ä¸­çš„å•è¯ä¸ S é€ä¸ªæ¯”è¾ƒï¼Œè¿™æ ·æœ€å·®æ—¶é—´å¤æ‚åº¦ä¸ºO(N W M)ã€‚ W ä½å­—å…¸ä¸­çš„å•è¯æ•°é‡ï¼Œ M ä¸ºå•è¯çš„å¹³å‡é•¿åº¦ã€‚è™½ç„¶å¯ä»¥å°†å­—å…¸ä¸­çš„å•è¯æŒ‰é•¿åº¦é™åºæ’åˆ—æ¥å‡å°‘ä¸€èˆ¬çŠ¶æ€ä¸‹çš„è¿è¡Œæ—¶é—´ï¼Œä½†ä¸ä¼šå‡å°‘æœ€å·®æ—¶é—´å¤æ‚åº¦ã€‚å°† L è®¾ä¸ºå­—å…¸ä¸­æ‰€æœ‰å•è¯å­—æ¯é•¿åº¦ä¹‹å’Œï¼Œæ—¶é—´å¤æ‚åº¦ä¹Ÿå¯ä»¥è¡¨ç¤ºä¸ºO(N*L)ã€‚ ä»£ç å¦‚ä¸‹ï¼š s = 'abppplee' d = [ 'able' , 'ale' , 'apple' , 'bale' , 'kangaroo' ] def compare ( s , w ): i = 0 for character in w : while i < len ( s ): if character == s [ i ]: i += 1 break i += 1 else : break else : return True return False def solution ( s , d ): for w in sorted ( d , key = len , reverse = True ): if compare ( s , w ): return w print ( solution ( s , d )) Improving the greedy approach æˆ‘ä»¬ä¹Ÿå¯ä»¥å¯¹ S åšä¸€äº›é¢„å¤„ç†æ“ä½œï¼Œè®°å½•å…¶ä¸­å­—æ¯çš„å‡ºç°ï¼š S = \"abppplee\" a -> [ 0 ] b -> [ 1 ] p -> [ 2 , 3 , 4 ] l -> [ 5 ] e -> [ 6 , 7 ] è¿™ä¸€æ“ä½œçš„çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚åœ¨æˆ‘ä»¬æŸ¥æ‰¾æ—¶ï¼Œå¯¹äºä¸€ä¸ªå­—å…¸ä¸­çš„å•è¯ w ï¼Œé¦–å…ˆåˆ¤æ–­å®ƒçš„å­—æ¯ X æ˜¯å¦åœ¨ä¸Šè¿°æ•°æ®ç»“æ„ä¸­ï¼Œä¹‹åå†å»äºŒåˆ†æŸ¥æ‰¾åˆ°æ•°æ®ç»“æ„ä¸­çš„æ»¡è¶³ï¼šæœ€å°çš„indexå¤§äº X çš„ Y å­—æ¯ï¼Œå…¶ä¸­ Y ä¸º X çš„ä¸‹ä¸€ä¸ªå­—æ¯ã€‚è¿™æ ·å¤„ç†çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(N + L * logN)ã€‚ Googleæä¾›çš„ä»£ç å¦‚ä¸‹ï¼š import collections import sys def find_longest_word_in_string ( letters , words ): letter_positions = collections . defaultdict ( list ) # For each letter in 'letters', collect all the indices at which it appears. # O(#letters) space and speed. for index , letter in enumerate ( letters ): letter_positions [ letter ] . append ( index ) # For words, in descending order by length... # Bails out early on first matched word, and within word on # impossible letter/position combinations, but worst case is # O(#words # avg-len) * O(#letters / 26) time; constant space. # With some work, could be O(#W * avg-len) * log2(#letters/26) # But since binary search has more overhead # than simple iteration, log2(#letters) is about as # expensive as simple iterations as long as # the length of the arrays for each letter is # \"small\". If letters are randomly present in the # search string, the log2 is about equal in speed to simple traversal # up to lengths of a few hundred characters. for word in sorted ( words , key = lambda w : len ( w ), reverse = True ): pos = 0 for letter in word : if letter not in letter_positions : break # Find any remaining valid positions in search string where this # letter appears. It would be better to do this with binary search, # but this is very Python-ic. possible_positions = [ p for p in letter_positions [ letter ] if p >= pos ] if not possible_positions : break pos = possible_positions [ 0 ] + 1 else : # We didn't break out of the loop, so all letters have valid positions return word if __name__ == '__main__' : print subdict ( sys . argv [ 1 ], sys . argv [ 2 :]) An optimal O(N + L) approach for any alphabet é¦–å…ˆæ˜¯ä¸€ä¸ªåŸºäºä¸Šè¿°ç®—æ³•çš„ï¼Œé€‚ç”¨äº S çš„é•¿åº¦ä¸é•¿çš„æƒ…å†µçš„ä¼˜åŒ–æ–¹æ¡ˆã€‚æˆ‘ä»¬å°† p -> [2, 3, 4] æ‹“å±•æˆ p -> [2, 2, 3, 4, -1, -1, -1, -1] ï¼Œå…¶ä¸­åˆ—è¡¨çš„æ¯ä¸ªå…ƒç´ å¯¹åº” S ä¸­è¯¥ä½ç½®åå‡ºç°è¯¥åˆ—è¡¨keyçš„å­—æ¯çš„åºå·ï¼ˆåŒ…æ‹¬è¯¥ä½ç½®çš„åºå·ï¼‰ã€‚å¦‚æœä¸å­˜åœ¨å°±ä»¥ -1 è¡¨ç¤ºã€‚è¿™æ ·æˆ‘ä»¬å°±ä¸ç”¨äºŒåˆ†æ³•æ¥æŸ¥æ‰¾åˆ—è¡¨ï¼Œä½†éšä¹‹å¸¦æ¥çš„é—®é¢˜æ˜¯ï¼šç®—æ³•çš„å®é™…å¤æ‚åº¦å˜ä¸ºO(N*A + L)ï¼Œ A ä¸º S çš„å­—æ¯é›†åˆçš„é•¿åº¦ï¼Œå¹¶ä¸”æ¶ˆè€—Oï¼ˆNAï¼‰çš„ç©ºé—´ã€‚å› æ­¤å½“ S è¿‡é•¿æ—¶å¹¶éä¸€ä¸ªå¾ˆå¥½çš„ä¼˜åŒ–ã€‚ é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡åŒæ—¶éå†æ‰€æœ‰ D ä¸­çš„å•è¯æ¥å‹æ¦¨æˆ‘ä»¬çš„æ—¶é—´å¤æ‚åº¦ã€‚å­—å…¸ä¸­çš„æ¯ä¸ªå•è¯æ”¾å…¥(w,i)å…ƒç»„ã€‚å…¶ä¸­wä¸ºå•è¯æœ¬èº«ï¼Œiè®°å½•äº†åºå·ä¸ºiçš„å­—æ¯å·²ç»è¾¾æˆåŒ¹é…ã€‚è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å½¢æˆç±»ä¼¼è¿™æ ·çš„æ•°æ®ç»“æ„ï¼š D = { \"able\" , \"ale\" , \"apple\" , \"bale\" , \"kangaroo\" } a -> [( \"able\" , 0 ), ( \"ale\" , 0 ), ( \"apple\" , 0 )] b -> [( \"bale\" , 0 )] k -> [( \"kangaroo\" , 0 )] æˆ‘ä»¬éå† S ä¸­çš„æ¯ä¸ªå…ƒç´ æ—¶ï¼Œå°†æ‰€æœ‰è¯¥å­—æ¯keyå¯¹åº”åˆ—è¡¨é‡Œçš„å…ƒç»„ t çš„iå¢åŠ 1ï¼Œå°†è¿™äº›å…ƒç´ ç§»åˆ° t.w[t.i] å¯¹åº”çš„é”®ä¸‹ã€‚å½“æŸä¸ª t çš„iç­‰äºwçš„é•¿åº¦æ—¶å®ƒå°±æ˜¯ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å•è¯ï¼Œå°†å®ƒç§»è‡³ä¸€ä¸ªç»“æœåˆ—è¡¨ã€‚æœ€ç»ˆæˆ‘ä»¬æ‰¾å‡ºè¿™ä¸ªåˆ—è¡¨ä¸­çš„æœ€é•¿å•è¯ã€‚è¿™ä¹ˆåšçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(W + N + W' * logW')ï¼Œå…¶ä¸­ W' ä¸ºç»“æœé›†ä¸­çš„å•è¯æ•°é‡ï¼Œæœ€å·®ç­‰äº W ï¼Œä½¿å¾—å…¶å¤æ‚åº¦éå¸¸æ¥è¿‘ç†è®ºæœ€ä¼˜çš„O(N + L)ã€‚ä»£ç å¦‚ä¸‹ï¼š s = 'abppplee' d = [ 'able' , 'ale' , 'apple' , 'bale' , 'kangaroo' ] from collections import defaultdict Alphabets = defaultdict ( list ) for word in d : Alphabets [ word [ 0 ]] . append ([ word , 0 ]) def solution ( s , d ): result = '' for character in s : alphabet_list = Alphabets [ character ] for i in reversed ( range ( len ( alphabet_list ))): temp = alphabet_list . pop ( i ) temp [ 1 ] += 1 if len ( temp [ 0 ]) == temp [ 1 ]: if temp [ 1 ] >= len ( result ): result = temp [ 0 ] else : Alphabets [ temp [ 0 ][ temp [ 1 ]]] . append ( temp ) return result print ( solution ( s , d )) Additional","tags":"Python","title":"Find longest word in dictionary that is a subsequence of a given string"},{"url":"pyjion-python-debug-pandasyou-hua-bi-ji.html","text":"Description Brett Cannonå’ŒDino Viehlandåœ¨ Pycon2016 çš„ Pyjion: who doesn't want faster for free? æ¼”è®²ä¸­ä»‹ç»äº†Microsoftä¸ºcpythonæä¾›JITçš„c++é¡¹ç›® Pyjion ã€‚ä¹‹åæˆ‘ä¹Ÿåœ¨talkpythonçš„å¾€æœŸè®¿è°ˆä¸­æ‰¾åˆ°ä¸Brett Cannonçš„ Pyjion ç›¸å…³çš„è®¿è°ˆï¼Œå…¶ä¸­çš„å¾ˆå¤šçœ‹æ³•è®©æˆ‘å¤§å—è„¾ç›Šã€‚ Elizaveta Shashkovaåœ¨ Pycon2017 çš„ Debugging in Python 3 6 Better, Faster, Stronger æ¼”è®²éå¸¸ä»¤äººå°è±¡æ·±åˆ»ã€‚å¥¹åœ¨å¼€å‘pycharmçš„JetBrainså…¬å¸å·¥ä½œï¼Œè€Œpycharmå› ä¸ºå®ƒä¼˜ç§€çš„debugåŠŸèƒ½æˆä¸ºäº†æˆ‘æœ€å–œæ¬¢çš„IDEï¼Œæ²¡æœ‰ä¹‹ä¸€ã€‚è™½ç„¶ä¿„ç½—æ–¯è€å§æœ‰ä¸€ç‚¹å£éŸ³ï¼Œä½†å¹¶ä¸å½±å“è¿™æ˜¯ä¸€æ¬¡è®©äººæ„Ÿåˆ°Bingoçš„æ¼”è®²ã€‚ åŒæ ·åœ¨ Pycon2017 ä¸Šï¼Œç¾ä¸½çš„Sofia Heislerå‘Šè¯‰äº†æˆ‘ä»¬ No More Sad Pandas Optimizing Pandas Code for Speed and Efficiency ã€‚è¿™åŒæ ·ä¹Ÿæ˜¯ä¸€æ¬¡æ—¢å®ç”¨è€Œåˆè®©äººèƒ½å­¦åˆ°å¾ˆå¤šæ–°çŸ¥çš„è®²è§£ï¼Œéå¸¸é«˜å…´èƒ½æœ‰å¾ˆå¤šä¼˜ç§€çš„å¥³æ€§å¼€å‘è€…å‚ä¸åˆ°pyconä¸­æ¥ã€‚ Pyjion Brett Cannonä»‹ç»äº†å„ç§pythonå®ç°ã€‚ IronPython å’Œ Jython åˆ†åˆ«æ˜¯pythonåŸºäºC#å’ŒJavaçš„å®ç°ï¼Œè¿™æ ·å®ƒä»¬å°±å¯ä»¥å…¼å®¹.Netå’ŒJavaçš„åº”ç”¨äº†ã€‚ PyPy æ˜¯æˆ‘ä¹‹å‰æ¯”è¾ƒå…³æ³¨çš„ä¸€ä¸ªå®ç°ã€‚å®ƒä¸»è¦æœ‰ä¸¤éƒ¨åˆ†ç»„æˆï¼Œä¸€æ˜¯å®ƒæœ‰ä¸€ç»„ä¸ºç¼–ç¨‹è¯­è¨€å®šåˆ¶JITçš„å·¥å…·ï¼Œä½ ä¸ä»…å¯ä»¥ä¸ºpythonæ¥å®ç°JITï¼Œä¹Ÿå¯ä»¥ç”¨Rpythonä¸ºå…¶ä»–è¯­è¨€å†™ä¸€ä¸ªJITçš„å®ç°ã€‚äºŒæ˜¯åˆšåˆšæåˆ°çš„Rpythonï¼Œè™½ç„¶ PyPy æ˜¯ç”±pythonç¼–å†™çš„ï¼Œä½†è¿™é‡Œçš„pythonå®é™…ä¸Šæ˜¯pythonçš„è¶…é›†Rpythonã€‚Rpythonæ˜¯é™æ€ç±»å‹ç‰ˆçš„pythonï¼Œå› æ­¤èƒ½ç¼–è¯‘æˆcä»£ç æé«˜è¿è¡Œçš„æ•ˆç‡ã€‚ IronPython ã€ Jython å’Œ PyPy æœ‰ä¸€ä¸ªå…±åŒçš„é—®é¢˜å°±æ˜¯æ— æ³•æœ‰æ•ˆçš„å…¼å®¹pythonçš„c apiï¼Œè‡´ä½¿ä½¿ç”¨è€…æ— æ³•åˆ©ç”¨å¾ˆå¤šä¼˜ç§€çš„cåº“ã€‚ IronPython å’Œ Jython ç”±äºå®ƒä»¬å¹¶éæ˜¯cè¯­è¨€å®ç°å…·æœ‰å¦‚ä¸Šå…¼å®¹æ€§é—®é¢˜éå¸¸å®¹æ˜“ç†è§£ï¼Œ PyPy åˆ™æ˜¯ç”±äºä½¿ç”¨CFFIæ¨¡å—çš„åŸå› å¯¹c apiåªæœ‰éƒ¨åˆ†çš„æ”¯æŒã€‚åƒ NumPy è¿™ç§æ¨¡å— PyPy åªèƒ½å¼€ä¸ªæ–°çš„é¡¹ç›®é‡å†™ï¼Œè¿™ä¹Ÿæ˜¯ PyPy ä½œä¸ºæœ€å¿«çš„Pythonå®ç°è€Œå¾—ä¸åˆ°ç§‘å­¦è®¡ç®—ç¤¾åŒºå¹¿æ³›åº”ç”¨çš„åŸå› æ‰€åœ¨ã€‚ Pyston æ˜¯DropboxèµåŠ©çš„é¡¹ç›®ï¼Œå®ƒçš„ç›®æ ‡æ˜¯ç”¨JITï¼ˆLLVM JITï¼‰æé«˜pythonè¿è¡Œé€Ÿåº¦çš„åŒæ—¶å°½å¯èƒ½åœ°å…¼å®¹pythonçš„c extensionï¼Œå› æ­¤å®ƒå†²ç”¨äº†å¤§éƒ¨åˆ† CPython çš„ä»£ç ã€‚ä½†æ¯”è¾ƒé—æ†¾çš„æ˜¯ Pyston ç°åœ¨åªæ”¯æŒpython2.7ç‰ˆæœ¬ã€‚ è€Œ Pyjion å­˜åœ¨çš„æ„ä¹‰åˆ™æ˜¯ç›´æ¥ä¸º Cpython æä¾›JITçš„åŒæ—¶å…¼å®¹æ›´å¤šçš„c extensionã€‚å®ƒç”±Dinoå‘èµ·ï¼Œä½¿ç”¨c++ç¼–å†™ï¼Œå•å‘æ”¯æŒpython3ç‰ˆæœ¬ã€‚ç°åœ¨JITæ˜¯åŸºäºcoreclrå®ç°çš„ï¼Œä½†åœ¨æ¼”è®²ä¸­ä»–ä»¬ä¹Ÿæåˆ°è¿™ç§å®ç°ä¹Ÿæ˜¯å¯ä»¥ä½œä¸ºä¸€ä¸ªåå°ç³»ç»Ÿæ›´æ¢çš„ã€‚ Brett Cannonä¹Ÿæåˆ°ï¼Œpythonç¤¾åŒºæ¨å¹¿python3çš„å…³é”®æ˜¯æé«˜python3çš„é€Ÿåº¦ï¼Œå› æ­¤æœ‰å¾ˆå¤šæ ¸å¿ƒå¼€å‘è€…åœ¨ä»äº‹è¿™æ–¹é¢çš„å·¥ä½œï¼Œ Pyjion ä¹Ÿæ˜¯å…¶ä¸­ä¹‹ä¸€ã€‚ç¤¾åŒºåœ¨å»ºç«‹ä¸€ä¸ªå¯¹è±¡çš„ç¼“å­˜ç³»ç»Ÿï¼šé€šè¿‡åˆ¤æ–­å¯¹è±¡çš„ç‰ˆæœ¬æ¥è‡ªçœå¯¹è±¡æ˜¯å¦è¢«æ”¹å˜ï¼Œå½“æœªæ”¹å˜å¯¹è±¡åœ¨ç¼“å­˜ä¸­æ—¶æˆ‘ä»¬å°±ä¸ç”¨å¯¹å‘½åç©ºé—´è¿›è¡Œå±‚å±‚ç­›é€‰æ¥è·å–å¯¹è±¡äº†ã€‚ å¦ä¸€ä¸ªè‡³å…³é‡è¦çš„ä¼˜åŒ–å°±æ˜¯ä¹‹å‰ä¸€ç¯‡ç¬”è®°ä¸­æåˆ°çš„å¯èƒ½ä¼šåœ¨python3.7ä¸­å®è£…çš„è°ƒç”¨å‡½æ•°é€Ÿåº¦çš„ä¼˜åŒ–ã€‚è°ƒç”¨å‡½æ•°ç“¶é¢ˆçš„äº§ç”Ÿæ˜¯ç”±äºpythonçš„å¤šç§å…¥å‚å½¢å¼ï¼ˆä½ç½®å‚æ•°ï¼Œå…³é”®å­—å‚æ•°ï¼Œ argsï¼Œ * kwargsï¼Œpython3ä¸­æ–°æ·»åŠ çš„åªå…è®¸å…³é”®å­—çš„å‚æ•°ï¼Œå‡½æ•°é—­åŒ…ï¼‰ã€‚è¿™äº›å…¥å‚å½¢å¼æ˜¯çš„äº†pythonåœ¨å…·å¤‡åŠ¨æ€æ€§çš„åŒæ—¶ä¸ä¸§å¤±å¤ªå¤šåŠŸèƒ½ï¼Œä½†åœ¨æ„å»ºå‚æ•°åˆ—è¡¨æ—¶åˆ™ä¼šå¯¹ç³»ç»Ÿäº§ç”Ÿæå¤§åœ°ç¬¦åˆã€‚Yurié’ˆå¯¹è¿™ç§æƒ…å†µå¼€å¼€å‘äº†æ–°çš„åŠ è½½å®ä¾‹æ–¹æ³•å’Œè°ƒç”¨å‡½æ•°çš„å­—èŠ‚ç ã€‚ Debug Pycharmä¸­çš„debugåŠŸèƒ½æ˜¯åŸºäº sys.settrace å‡½æ•°å®Œæˆçš„ã€‚è€Œè®¾ç½®æ–­ç‚¹çš„åŠŸèƒ½åˆ™æ˜¯åœ¨æ–­ç‚¹å‰æ’å…¥ä¸€ä¸ªå­—èŠ‚ç çº§åˆ«çš„ç›‘å¬ç”¨æˆ·è¾“å…¥çš„æ­»å¾ªç¯ã€‚åœ¨åŠ å…¥æ–°çš„å­—èŠ‚ç ä¹‹åï¼Œè¿˜éœ€è¦æ›´æ–°åŸæœ‰çš„å˜é‡å’Œå­—èŠ‚ç çš„åç§»é‡ã€‚å½“æˆ‘ä»¬ dis å¦‚ä¸‹å‡½æ•°æ—¶ï¼š def maximun ( a , b ): if a > b : return a else : return b å°†å¾—åˆ°è¿™äº›å­—èŠ‚ç ï¼š 2 0 LOAD_FAST 0 ( a ) 2 LOAD_FAST 1 ( b ) 4 COMPARE_OP 4 ( > ) 6 POP_JUMP_IF_FALSE 12 3 8 LOAD_FAST 0 ( a ) 10 RETURN_VALUE 5 >> 12 LOAD_FAST 1 ( b ) 14 RETURN_VALUE 16 LOAD_CONST 0 ( None ) 18 RETURN_VALUE æˆ‘ä»¬æƒ³è¦åœ¨ return a è¯­å¥è¿™ä¸€è¡Œæ‰“ä¸Šæ–­ç‚¹æ—¶ï¼Œæ’å…¥äº†ç±»ä¼¼è¿™æ ·çš„å‡½æ•°ï¼š def _stop_at_break (): # a lot of code here def breakpoint (): _stop_at_break () å­—èŠ‚ç ä¸ºï¼š 0 LOAD_GLOBAL 0 (_stop_at_break) 2 CALL_FUNCTION 0 4 POP_TOP 6 LOAD_CONST 0 (None) 8 RETURN_VALUE åœ¨python3.6ä¹‹å‰ï¼Œç”±äºPycharmä½¿ç”¨çš„æ˜¯ sys.settrace ï¼Œè¿è¡Œç¨‹åºæ—¶æ¯ä¸€è¡Œéƒ½ä¼šè§¦å‘ä¸€æ¬¡traceå‡½æ•°ï¼Œå› æ­¤è°ƒè¯•æ—¶çš„è¿è¡Œæ—¶é—´å°†ä¼šå¢åŠ 25å€ã€‚Debugä½¿å¾—æ—¶é—´æ•æ„Ÿçš„ç¨‹åºå¤±å»å‡†ç¡®æ€§ã€‚å¥½åœ¨python3.6ä¸­éƒ¨ç½²äº†PEP523ä¸­çš„frame evaluation apiã€‚PEP523ä¸­æœ‰ä¸¤ä¸ªä¸»è¦çš„å†…å®¹: Handle evaluation of frames Add a new field to code objects ä¸ºäº†æ›´å¥½çš„è®©æˆ‘ä»¬ç†è§£ï¼ŒElizaveta Shashkovaç»™äº†æˆ‘ä»¬c codeçš„pythonç‰ˆç¤ºä¾‹ï¼š def frame_eval ( frame , exc ): func_name = frame . f_code . co_name line_number = frame . f_lineno print ( line_number , func_name ) return _PyEval_EvalFrameDefault ( frame , exc ) def set_frame_eval (): state = PyThreadState_Get () state . interp . eval_frame = frame_eval è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥è°ƒç”¨ set_frame_eval æ¥æœ€ç»ˆframeäº†ã€‚å®ƒåªåœ¨æ¯æ¬¡è¿›å…¥frameæ—¶å€™è§¦å‘ï¼Œèƒ½å¤§å¤§å‡å°‘debugè¿è¡Œæ—¶å€™çš„æ•ˆç‡ã€‚ä½†æ˜¯å½“å‡ºç°é¢‘ç¹è°ƒç”¨å‡½æ•°è‡´ä½¿è¿›å…¥frameçš„æ¬¡æ•°è¿‡å¤šçš„æ—¶å€™ï¼Œæˆ‘ä»¬çš„debugè¿è¡Œæ•ˆç‡å°†ä¼šé€€åŒ–åˆ° sys.settrace çš„æ°´å¹³ã€‚ è¿™æ—¶å€™PEP523ä¸­çš„ç¬¬äºŒç‚¹å°±å¯ä»¥ä¸ºæˆ‘ä»¬æ‰€ç”¨äº†ã€‚è¿™ä¸ªç‰¹æ€§æ‹“å±•äº† PyCodeObject çš„ç»“æ„ï¼Œå¢åŠ äº† co_extra å±æ€§ã€‚åˆ©ç”¨è¿™ä¸ªå±æ€§æˆ‘ä»¬å¯ä»¥ä»¥ä¸æ’å…¥ breakpoint å‡½æ•°çš„æ–¹å¼æ¥æ ‡è®°ä»£ç ã€‚ç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š def frame_eval ( frame , exc ): flag = _PyCode_GetExtra ( frame . f_code , index ) if flag == NO_BREAKS_IN_FRAME : return _PyEval_EvalFrameDefault ( frame , exc ) # check for breakpoints æœ€ç»ˆçš„æ•ˆç‡æå‡æƒ…å†µå¤§è‡´å¦‚ä¸‹ï¼š Pandas Sofia Heisleræµ‹è¯•çš„å‡½æ•°å¦‚ä¸‹,æµ‹è¯•æ•°æ®æ–‡ä»¶ åœ¨æ­¤ ï¼š def haversine ( lat1 , lon1 , lat2 , lon2 ): miles_constant = 3959 lat1 , lon1 , lat2 , lon2 = map ( np . deg2rad , [ lat1 , lon1 , lat2 , lon2 ]) dlat = lat2 - lat1 dlon = lon2 - lon1 a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * np . sin ( dlon / 2 ) ** 2 c = 2 * np . arcsin ( np . sqrt ( a )) mi = miles_constant * c return mi æˆ‘ä»¬åˆ©ç”¨åˆ©ç”¨Jupyter notebookçš„ %%timeit é­”æœ¯æ–¹æ³•åŠ line_profiler æ¥è·‘åˆ†ã€‚é¦–å…ˆæˆ‘ä»¬ç”¨å¾ªç¯çš„æ–¹å¼æ¥éå†æ•´ä¸ªdf: %% timeit ### Haversine applied on rows via iteration haversine_series = [] for index , row in df . iterrows (): haversine_series . append ( haversine ( 40.671 , - 73.985 , \\ row [ 'latitude' ], row [ 'longitude' ])) df [ 'distance' ] = haversine_series å¾—åˆ°çš„ç»“æœæ˜¯ 197 ms Â± 6.65 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each) ã€‚ ä¹‹åæ˜¯applyæ–¹æ³•ï¼š % timeit df [ 'distance' ] = \\ df . apply ( lambda row : haversine ( 40.671 , - 73.985 , \\ row [ 'latitude' ], row [ 'longitude' ]), axis = 1 ) å¾—åˆ°çš„ç»“æœæ˜¯ 78.1 ms Â± 6.65 ms per loop (mean Â± std. dev. of 7 runs, 10 loop each) ã€‚å¦‚æœç”¨ line_profiler æ¥è¿›è¡Œåˆ†æï¼Œå°±ä¼šå‘ç°æ€§èƒ½ç“¶é¢ˆæ¥è‡ªäºé¢‘ç¹è°ƒç”¨å‡½æ•°çš„ç¬¬ä¸‰è¡Œå’Œç¬¬å…­è¡Œã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬å°†æ•°æ®å‘é‡åŒ–ã€‚åœ¨Pandasä¸­çš„å‘é‡åŒ–æ˜¯å¦‚æ­¤çš„ç®€å•ï¼š ### Vectorized implementation of Haversine applied on Pandas series % timeit df [ 'distance' ] = haversine ( 40.671 , - 73.985 , \\ df [ 'latitude' ], df [ 'longitude' ]) è·‘åˆ†çš„ç»“æœæ˜¯ 2.21 ms Â± 230 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each) ã€‚è°ƒç”¨ line_profiler åå‘ç°å‡½æ•°ç¬¬ä¸‰è¡Œçš„æ‰§è¡Œé¢‘ç‡ä¸‹é™åˆ°äº†å’Œå…¶ä»–è¯­å¥åŒä¸€æ•°é‡çº§ï¼ˆ529)ï¼Œç¬¬å…­è¡Œä¹Ÿä»ä¸€ä¸‡å…­åƒå¤šæ¬¡ä¸‹é™åˆ°äº†ä¸‰åƒäº”ç™¾å¤šæ¬¡ã€‚ä½†è¿™è¿˜ä¸æ˜¯æœ€ä¼˜çš„ç»“æœã€‚ ä¹‹åæˆ‘ä»¬å°†è¾“å…¥ç”±pd.Serieså˜ä¸ºnp.ndarrayï¼Œå‡å°‘äº†Pandas Seriesç´¢å¼•åŠæ£€æŸ¥æ•°æ®ç±»å‹ç­‰å¼€é”€: ### Vectorized implementation of Haversine applied on NumPy arrays % timeit df [ 'distance' ] = haversine ( 40.671 , - 73.985 , \\ df [ 'latitude' ] . values , df [ 'longitude' ] . values ) å¾—åˆ°çš„ç»“æœæ˜¯ 370 Âµs Â± 18 Âµs per loop (mean Â± std. dev. of 7 runs, 1000 loops each) ã€‚ Sofia Heisleræœ€åçš„å®éªŒæ˜¯ç”¨Cythonæ¥ä¼˜åŒ–å‡½æ•°æœ¬èº«çš„è¿ç®—é€Ÿåº¦ã€‚å› ä¸ºå¦‚æœæœ‰äº›åŸå› æˆ‘ä»¬ä¸èƒ½å°†æ•°æ®å‘é‡åŒ–äº¦æˆ–è€…å‘é‡åŒ–æ— æ³•è¡¨è¾¾å‡ºåŸæœ‰çš„ä¸šåŠ¡é€»è¾‘ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¿…é¡»è¿­ä»£æˆ‘ä»¬çš„æ•°æ®é›†äº†ã€‚ä¸ºäº†æé«˜æ•ˆç‡æˆ‘ä»¬å°†åŸå‡½æ•°å†™æˆè¿™æ ·ç„¶åç”¨ apply è¿­ä»£ï¼š %% cython - a ### Haversine cythonized from libc.math cimport sin , cos , acos , asin , sqrt cdef deg2rad_cy ( float deg ): cdef float rad rad = 0.01745329252 * deg return rad cpdef haversine_cy_dtyped ( float lat1 , float lon1 , float lat2 , float lon2 ): cdef : float dlon float dlat float a float c float mi lat1 , lon1 , lat2 , lon2 = map ( deg2rad_cy , [ lat1 , lon1 , lat2 , lon2 ]) dlat = lat2 - lat1 dlon = lon2 - lon1 a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * sin ( dlon / 2 ) ** 2 c = 2 * asin ( sqrt ( a )) mi = 3959 * c return mi % timeit df [ 'distance' ] = \\ df . apply ( lambda row : haversine_cy_dtyped ( 40.671 , - 73.985 , \\ row [ 'latitude' ], row [ 'longitude' ]), axis = 1 ) å°½ç®¡å¦‚æ­¤ï¼Œè·‘åˆ†çš„ç»“æœè¿˜æ˜¯ä¸å¦‚æˆ‘ä»¬çš„å‘é‡åŒ– 51.1 ms Â± 2.74 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each) ã€‚ æœ€ç»ˆçš„å®éªŒç»“æœå¦‚ä¸‹ï¼š Additional","tags":"Python","title":"Pyjionã€python debugã€pandasä¼˜åŒ–ç¬”è®°"},{"url":"instagram-python-migrationbi-ji.html","text":"Description Lisa Guoå’ŒHui Dingåœ¨ Pycon2017 çš„ keynote åˆ†äº«äº†InstagramæˆåŠŸä»python2.7ã€Django1.3å‡çº§åˆ°python3.6ã€Django1.8çš„ç»å†ã€‚ åœ¨Talk Python fmä¹‹å‰çš„episodeä¸­ï¼Œæˆ‘æƒŠå–œåœ°å‘ç°äº†æœ‰ä¸€æœŸMichael Kennedyé‚€è¯·åˆ°äº† David Beazley ã€‚åœ¨å“ªä¸€æœŸèŠ‚ç›®ä¸­ä»–ä»¬ç•…è°ˆäº†python concurrencyç›¸å…³åŠDavidåœ¨Githubä¸Šçš„asyncé¡¹ç›® Curio ã€‚ Instagram å¾ˆéš¾æƒ³è±¡Instagramèƒ½åœ¨ä¿æŒäº§å“åŠŸèƒ½é«˜é€Ÿè¿­ä»£çš„åŒæ—¶å®Œæˆä»python2.7ç‰ˆæœ¬åˆ°3.5ç‰ˆæœ¬çš„è·¨è¶Šã€‚ä»–ä»¬åœ¨ç‰ˆæœ¬æ›´æ–°é€”ä¸­åœ¨ä»£ç å±‚é¢é‡åˆ°çš„ä¸»è¦æœ‰ä»¥ä¸‹å‡ ç±»é—®é¢˜ã€‚ Unicode Python3æœ€æ˜¾è‘—çš„æ”¹åŠ¨å°±æ˜¯ä¸¥æ ¼åŒ–äº†UNICODE/STR/BYTEçš„è½¬æ¢ã€‚Instagramç¼–å†™äº†ä¸€äº›åŠŸèƒ½å‡½æ•°ï¼ˆ ensure_binary , ensure_str , ensure_text ï¼‰æ¥ç¡®ä¿ä¹‹å‰ä»£ç é‡Œçš„è¾“å…¥å’Œè¾“å‡ºç¬¦åˆpython3çš„æ ‡å‡†ã€‚ Data format incompatible åœ¨Instagramä¸­ç»å¸¸ç”¨åˆ°äº† pickle æ¨¡å—ã€‚è¯¥æ¨¡å—åœ¨python2å’Œ3ä¸­çš„åŒºåˆ«æ˜¯ï¼špython3çš„pickleçš„åè®®æœ€é«˜ç‰ˆæœ¬æå‡åˆ°äº†4ã€‚ä»–ä»¬å‘ç°å³ä½¿å°†åè®®ç‰ˆæœ¬hardcodeåˆ°python2é‡Œçš„2ï¼Œç”±äºç‰ˆæœ¬2å’Œ3çš„åŒæ—¶å­˜åœ¨ï¼Œä»–ä»¬ä¹‹é—´çš„ç›¸äº’åºåˆ—åŒ–çš„è½¬åŒ–ä¹Ÿä¼šå­˜åœ¨é—®é¢˜ã€‚å› æ­¤ä»–ä»¬å°†ä¸åŒç‰ˆæœ¬çš„pickleç»“æœéš”ç¦»ï¼Œåšåˆ°è‡ªå–è‡ªæ‹¿ã€‚ Iterator Python3ä¸­çš„è®¸å¤šå‡½æ•°çš„è¿”å›å€¼è¢«ä¿®æ”¹æˆäº†è¿­ä»£å™¨ï¼ˆ map , filter , dict.item ï¼‰ï¼Œè¿­ä»£å™¨ä½¿å¾—Instagramä¸­é‚£äº›ä¼šéå†ä¸¤éè¿™äº›å‡½æ•°è¿”å›ç»“æœçš„ä»£ç å…¨éƒ¨å¤±æ•ˆã€‚è¿™å…¶å®éå¸¸éš¾ä»¥è°ƒè¯•ï¼Œå› æ­¤ä»–ä»¬é¦–å…ˆå°†æ‰€æœ‰è¯¥ç±»å‡½æ•°çš„è¿”å›å€¼ç”¨ list æ–¹æ³•è¿˜åŸæˆåˆ—è¡¨ï¼Œç„¶åå°†ä¼˜åŒ–åªè¿­ä»£ä¸€éçš„å®ä¾‹ã€‚ Dictionary ordering ä¹‹å‰çš„ä¸€ç¯‡note ä¹Ÿè®²è¿‡ï¼Œç”±äºpythonå­—å…¸çš„ç‰ˆæœ¬æ”¹åŠ¨ï¼Œå­—å…¸ä¸­çš„è¿”å›å€¼å°†å¤§å¤§ä¸åŒã€‚ testdict = { 'a' : 1 , 'b' : 2 , 'c' : 3 } json . dumps ( testdict ) å„ç‰ˆæœ¬çš„è¿”å›ç»“æœå¤§è‡´ä¸ºï¼š python2 : { 'a' : 1 , 'c' : 2 , 'b' : 3 } ( hardcode hashcode ) python3 . 5 . 1 : ( random ) python3 . 6 ï¼š{ 'a' : 1 , 'b' : 2 , 'c' : 3 } ( keep order ) ä¸ºäº†è¿½æ±‚å…¼å®¹æ€§ï¼Œä»–ä»¬å¯¹ json.dumps å‡½æ•°åŠ äº†å‚æ•°ï¼š json . dumps ( testdict , sort_keys = True ) å¦å¤–ä»–ä»¬ä¹Ÿæåˆ°äº†ä»¥ä¸‹çš„ä¸€ä¸ªå°çš„Unicodeçš„æ”¹åŠ¨å°†Instagramçš„æ€§èƒ½æå‡äº†12%ï¼š if uwsgi . opt . get ( 'optimize_men' , None ) == 'True' optimize_men () to if uwsgi . opt . get ( 'optimize_men' , None ) == b 'True' optimize_men () æœªæ¥ä»–ä»¬è®¡åˆ’ä½¿ç”¨äº†python3å®Œå–„å¥½çš„ç‰¹æ€§type hintså’Œmypyæ¥æé«˜ä»–ä»¬codebaseçš„å¥å£®æ€§ï¼Œä½¿ç”¨asyncioåº“ç”¨å¼‚æ­¥æ¥å¤„ç†ä¹‹å‰çš„ä¸€äº›çº¿ç¨‹æ“ä½œã€‚ Curio David Beazleyä¸€ç›´æ˜¯ä¸€ä½æˆ‘éå¸¸å–œæ¬¢çš„pythonæˆä¸šè€…ï¼ŒåŒæ—¶ä¹Ÿæ˜¯python cookbookçš„ä½œè€…ã€‚ä»–åœ¨è¿™æ¬¡è®¿è°ˆä¸­æåˆ°äº†åœ¨pythonä¸­å®ç°asyncçš„å¦ä¸€ç§æ€è·¯ï¼Œä¹Ÿå°±æ˜¯ä»–å†™ Curio åº“çš„ç›®çš„ã€‚ åœ¨ä»¥æ•™æˆpythonä¸ºä¸šä¹‹å‰ï¼Œä»–æ˜¯æ•™è®¡ç®—æœºç§‘å­¦ç³»æ“ä½œç³»ç»Ÿè¯¾ç¨‹çš„æ•™æˆã€‚åœ¨è¯¾ä¸Šä»–ä¼šå‘Šè¯‰å­¦ç”Ÿä»¬å¦‚ä½•ç”¨Cè¯­è¨€æ¥å†™æ“ä½œç³»ç»Ÿçš„å†…æ ¸ï¼Œå†…æ ¸åšçš„äº‹æƒ…ä¸»è¦å°±æ˜¯å¤šä»»åŠ¡ç®¡ç†å’ŒIOï¼Œè¿™å’Œ asyncio åº“æ‰€åšçš„éå¸¸ç›¸ä¼¼ã€‚æ—¢ç„¶ asyncio åº“èƒ½å°† callback , futures , coroutine ç¥å¥‡åœ°ç»„åˆæˆä¸€ä¸ªå¥‡å¦™çš„ä»»åŠ¡ç®¡ç†ç³»ç»Ÿï¼Œä¸ºä»€ä¹ˆæˆ‘ä»¬ä¸èƒ½æ¨¡ä»¿ç³»ç»Ÿå†…æ ¸ä¹Ÿå»å®ç°ä¸€ä¸ªä»»åŠ¡ç®¡ç†ç³»ç»Ÿå‘¢ï¼Ÿæœ¬èº«asyncç¼–ç¨‹ä¹Ÿæ˜¯ä¸€ä¸ªç„•å‘ç¬¬äºŒæ˜¥çš„æ—§æƒ³æ³•ã€‚ Davidä¹Ÿæåˆ°ï¼Œç”±äºpython3.5ä¸­ async/await å…³é”®å­—çš„åŠ å…¥ï¼Œä»–ä¹‹å‰çš„è®¸å¤šæ¼”è®²å’Œæ•™ç¨‹éƒ½æœ‰äº›è¿‡æ—¶äº†ã€‚è¿™ä½¿ä»–è§‰å¾—ï¼Œæˆ‘ä»¬æˆ–è®¸ä¸è¯¥å…³æ³¨ayncåº•å±‚åˆ°åº•æ˜¯å¦‚ä½•å®ç°çš„ï¼šæ— è®ºæ˜¯ç”¨ callback è¿˜æ˜¯ç”¨å…¶ä»–æŠ€æœ¯ï¼Œè€Œæ˜¯å…³æ³¨æˆ‘ä»¬è¯¥å¦‚ä½•åˆ©ç”¨asyncç¼–ç¨‹æˆ–è€…è¯´æ˜¯asyncåº”è¯¥åœ¨çš„çš„é¢†åŸŸã€‚ å¯èƒ½ç°åœ¨asyncæœ€å¤§çš„é—®é¢˜å°±æ˜¯å®ƒçš„ä¼ æŸ“æ€§ï¼Œä¸€æ—¦ä½ ä»£ç ä¸­çš„ä¸€éƒ¨åˆ†å˜æˆasyncï¼Œæ‹¿å®ƒæ‰€å¯¹åº”çš„æ•´ä¸ªä»£ç ç”Ÿæ€é“¾ä¹Ÿå¿…é¡»æ˜¯asyncçš„ï¼Œå¦åˆ™å°å°çš„ä¸€æ®µåŒæ­¥ä»£ç å°±ä¼šé˜»å¡æ•´ä¸ªç¨‹åºã€‚è™½ç„¶æ²¡æœ‰ç‰¹åˆ«å¤¸å¼ ï¼Œä½†æ˜¯å¯¹äºçº¿ç¨‹ç¼–ç¨‹æ¥è¯´ï¼Œè¿™ä¸€ç‚¹ç¡®å®æ˜¯å€¼å¾—è€ƒè™‘çš„ã€‚è™½ç„¶asyncioåº“æä¾›äº†ä¸€ä¸ªå‡½æ•°ä½œä¸ºå¯¹asyncä¸­çº¿ç¨‹çš„æ”¯æŒï¼Œä½†æ˜¯å¹¶æ²¡æœ‰å°†çº¿ç¨‹çº³å…¥ eventloop å¤„ç†çš„èŒƒç•´ä¹‹ä¸­ï¼Œ coroutine ä¹Ÿä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚Davidçš„è®¾æƒ³å°±æ˜¯åœ¨ä¸è¿œçš„å°†æ¥èƒ½å°†çº¿ç¨‹å’Œasyncç»Ÿä¸€ç»“åˆèµ·æ¥ï¼Œä½¿å¾— eventloop èƒ½åŒæ—¶å…¼ä»»åœ°å¤„ç†åç¨‹å’Œçº¿ç¨‹ï¼Œè¿™æ ·å¯¹asyncçš„æœªæ¥å®šæ˜¯å¤§æœ‰è£¨ç›Šã€‚äº‹å®ä¸ŠDavidåœ¨ Curio ä¸­å·²ç»å®Œæˆäº†ä¸€ä¸ªç»Ÿä¸€é˜Ÿåˆ—çš„ç»„ä»¶ï¼ˆuniversal queue objectï¼‰ä½œä¸ºçº¿ç¨‹å’Œåç¨‹çš„äº¤æµåª’ä»‹ã€‚ Additional","tags":"Python","title":"Instagram python migrationç¬”è®°"},{"url":"python-asyncdictionarymachine-learning-moudlesbi-ji.html","text":"Description Jesse Jiryu Davisåœ¨ Pycon2014 çš„æ¼”è®² A. Jesse Jiryu Davis: What Is Async, How Does It Work, And When Should I Use It? åˆ†æäº†ä¸ºä»€ä¹ˆä»¥åŠåœ¨ä»€ä¹ˆæƒ…å†µä¸‹è¦ç”¨å¼‚æ­¥çš„æ–¹å¼å¤„ç†ioã€‚ä¹‹å‰åœ¨ 300line é‡Œï¼Œä»–å’ŒGuidoåˆè‘—çš„async crawleréƒ¨åˆ†é‡Œå°±ä»‹ç»äº†ä½¿ç”¨åç¨‹ç›¸å¯¹çº¿ç¨‹çš„ä¼˜åŠ¿ï¼šåœ¨pythoné‡Œçº¿ç¨‹éœ€è¦50Kçš„å†…å­˜ï¼Œè€Œåç¨‹åªéœ€è¦3Kã€‚åœ¨è¯¥æ¼”è®²ä¸­ï¼Œä»–è¿›ä¸€æ­¥é˜è¿°äº†åç¨‹çš„ä¼˜åŠ¿åŠåº”ç”¨åœºæ™¯ã€‚ Raymond Hettingeråœ¨ Pycon2017 çš„æ¼”è®² Modern Python Dictionaries A confluence of a dozen great ideas å’ŒBrandon Rhodesçš„ The Dictionary Even Mightier çš„ä¸»é¢˜æ˜¯pythonå­—å…¸åœ¨3.6ç‰ˆæœ¬çš„æå¤§æ”¹è¿›ï¼šå‡å°‘20%-30%çš„å†…å­˜å ç”¨åŠä¿æŒå…ƒç´ çš„æ’å…¥é¡ºåºã€‚ TalkPython ä¸­Pete Garcinçš„è®¿è°ˆ Top 10 machine learning libraries ä»‹ç»äº†ç›®å‰æœ€æµè¡Œçš„åä¸ªæœºå™¨å­¦ä¹ åº“ï¼Œè°ˆè®ºäº†å®ƒä»¬çš„å¼‚åŒä»¥åŠåˆå­¦è€…çš„å­¦ä¹ è·¯å¾„ã€‚ Async Jesseä¸¾äº†çº½çº¦ä¸‰ç§é¤å…çš„ä¾‹å­ä½œä¸ºä¸‰ç§ä¸åŒåœºæ™¯ã€‚ ç¬¬ä¸€ä¸ªæ˜¯ä¸‰æ˜æ²»å•†åº—ã€‚é¡¾å®¢åˆ°æŸœå°æ’é˜Ÿï¼Œå¨å¸ˆæ¥åˆ°è®¢å•å°±å¼€å§‹åˆ¶ä½œä¸‰æ˜æ²»ç›´åˆ°å®Œæˆä¸‰æ˜æ²»ã€‚è¿™ä¸ªä¾‹å­æè¿°çš„æ˜¯cpuå¯†é›†å‹æœåŠ¡çš„æœºåˆ¶ï¼Œè¿™é‡Œæ²¡æœ‰ä¹Ÿæ— æ³•ä½¿ç”¨å¼‚æ­¥æœºåˆ¶ï¼Œæ•´ä¸ªæœåŠ¡çš„ååé‡å—åˆ°è®¡ç®—èƒ½åŠ›çš„é™åˆ¶ã€‚ ç¬¬äºŒä¸ªæ˜¯æŠ«è¨åº—ã€‚é¡¾å®¢ç‚¹å•åï¼Œå¨å¸ˆéœ€è¦å°†åˆ¶ä½œå¥½çš„æŠ«è¨ç”¨å¾®æ³¢ç‚‰åŠ çƒ­åäº¤ç»™é¡¾å®¢ã€‚ç”±äºéœ€è¦ç­‰å¾…æŠ«è¨çš„åŠ çƒ­ï¼Œå› æ­¤å°±æœ‰äº†å¼‚æ­¥æ“ä½œçš„å¿…è¦æ€§ã€‚è¿™ç§æœåŠ¡çš„ååé‡å—åˆ°å†…å­˜çš„é™åˆ¶ï¼ŒæœåŠ¡å™¨ä¹Ÿéœ€è¦åå°æ¥å¤„ç†pendingçš„è¯·æ±‚ã€‚ ç¬¬ä¸‰ä¸ªæ˜¯ä¸€ç§å¯¿å¸åº—ã€‚åœ¨è¿™é‡Œé¡¾å®¢çš„éœ€æ±‚ç”±æœåŠ¡å‘˜å‘ŠçŸ¥å¨æˆ¿ï¼ŒåŒæ—¶å¨æˆ¿å®Œæˆçš„å¯¿å¸ä¹Ÿéœ€è¦æœåŠ¡å™¨é€åˆ°å®¢æˆ·é¢å‰ã€‚ç°å®ä¸­è¿™æ ·æœåŠ¡çš„ä¾‹å­å°±æ˜¯è°·æ­Œé‚®ç®±æœåŠ¡ï¼šå½“å®¢æˆ·ç™»å½•è°·æ­Œé‚®ç®±ä¹‹åå¹¶ä¸ä¼šåšå¤ªå¤šåŠ¨ä½œï¼Œå½“å®¢æˆ·æ”¶åˆ°é‚®ä»¶çš„è¿™ä¸€äº‹ä»¶å‘ç”Ÿçš„æ—¶å€™æœåŠ¡å™¨æ‰ä¼šå°†æ•°æ®æ¨åˆ°å®¢æˆ·çš„é¢å‰ã€‚è¿™å°±è‡´ä½¿äº†å¤§é‡é•¿è¿æ¥çš„äº§ç”Ÿã€‚è¿™äº›é“¾æ¥å¤§éƒ¨åˆ†çš„æ—¶é—´å¤„äºç©ºé—²çŠ¶æ€ï¼Œå¦‚æœå¯¹æ¯ä¸ªé“¾æ¥éƒ½åˆ›å»ºä¸€ä¸ªçº¿ç¨‹çš„è¯å¾ˆå¿«å°±ä¼šæ¶ˆè€—å®Œç³»ç»Ÿçš„å†…å­˜ã€‚è€Œå¼‚æ­¥æ­£æ˜¯ä¸ºäº†æœ€å°åŒ–æ¯ä¸ªé“¾æ¥æ¶ˆè€—çš„èµ„æºè€Œè¯ç”Ÿçš„ã€‚ åç¨‹ç›¸å¯¹çº¿ç¨‹å¦ä¸€ä¸ªåŒºåˆ«ä¸ä¼˜ç‚¹å°±æ˜¯ï¼Œå½“æˆ‘ä»¬è¿›è¡Œå¤šçº¿ç¨‹ç¼–ç¨‹æ—¶è¦æ—¶æ—¶æ³¨æ„ç«æ€ï¼Œå¯¼è‡´æˆ‘ä»¬ä¸å¾—ä¸ç”¨é”æ¥æ§åˆ¶å…±äº«èµ„æºã€‚è¿™æ˜¯ç”±äºçº¿ç¨‹æ˜¯ç¨‹åºå‘˜å¹¶æ²¡æœ‰å¯¹çº¿ç¨‹çš„å®Œå…¨æ§åˆ¶æƒå¯¼è‡´çš„ï¼Œæˆ‘ä»¬å¹¶ä¸èƒ½çŸ¥é“çº¿ç¨‹ä»€ä¹ˆæ—¶å€™åˆ‡æ¢ï¼Œä»€ä¹ˆæ—¶å€™è¿è¡Œå’Œé˜»å¡â€”â€”æˆ‘ä»¬å°†è¿™äº›éƒ½äº¤ç»™æ“ä½œç³»ç»Ÿæ¥å®Œæˆäº†ã€‚è€Œåç¨‹åˆ™åªä¼šåœ¨yieldå¤„æš‚åœå’Œæ¥å—è¾“å…¥ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥æ§åˆ¶æ•´ä¸ªå¼‚æ­¥è¿‡ç¨‹ã€‚ åœ¨æ¼”è®²çš„æœ€åï¼ŒJesseå‘Šè¯‰äº†æˆ‘ä»¬å“ªç±»æœåŠ¡é€‚åˆasyncè€Œå“ªç±»ä¸é€‚åˆï¼š ä»–è®¤ä¸ºç¬¬äºŒå’Œç¬¬ä¸‰ç§ç±»å‹çš„æœåŠ¡æ˜¯é€‚åˆasyncçš„æœåŠ¡ã€‚è¿™é‡Œä¹Ÿä¹ŸæŒ‡å‡ºäº†asyncçš„ä¸è¶³ä¹‹å¤„ï¼Œasyncè¦æ±‚æœåŠ¡å¤„ç†æ—¶è‡³ä¸Šè€Œä¸‹æ¯ä¸€éƒ¨åˆ†éƒ½æ˜¯å¼‚æ­¥çš„ã€‚å› æ­¤æˆ‘ä»¬çš„DB driverä¹Ÿéœ€è¦æ”¯æŒå¼‚æ­¥ï¼Œå¦åˆ™å®ƒå°†ä¼šé˜»å¡æ•´ä¸ªç¨‹åºã€‚è¿˜æœ‰ä¸€ç‚¹ï¼Œasyncç¨‹åºä¸çº¿ç¨‹ç¼–ç¨‹å°†ä¼šéå¸¸ä¸åŒï¼Œå› æ­¤å½“ä½ è¦å®ç°ä¸€ä¸ªå¼‚æ­¥æœåŠ¡æ—¶ï¼Œä¸€ä¸ªasyncä¸“å®¶æ˜¯å¿…ä¸å¯å°‘çš„ã€‚ Dictionary in 3.6 Brandon Rhodesåœ¨ä»–çš„æ¼”è®²ä¸­æåˆ°äº†åå‡ å¹´æ¥pythonå¼€å‘è€…ä¸ºäº†ä½¿å­—å…¸è¶Šæ¥è¶Šäººæ€§åŒ–æ‰€åšçš„åŠªåŠ›ï¼š - åœ¨python2.6ä¹‹å‰å­—å…¸æ²¡æœ‰ç±»ä¼¼åˆ—è¡¨æ¨å¯¼å¼çš„åŠŸèƒ½ï¼Œpythonåœ¨3ä¸­åŠ å…¥äº†å­—å…¸æ¨å¯¼å¼å¹¶ä¸”å›æ¨ç»™äº†2.7ï¼Œä½¿å¾—å­—å…¸ä¸å†æ˜¯ä¸€ä¸ªæ¨å¯¼å¼çš„ç‰¹ä¾‹ - å­—å…¸çš„ keys() ç­‰å‡½æ•°å˜æˆäº†ç”Ÿæˆå™¨ã€‚ä¸ºäº†å’Œä»¥å‰çš„å€Ÿå£ï¼Œè¿˜å®ç°äº† __contains__ , __sub__ , __and__ , __xor__ , isdisjoint , __iter__ æ–¹æ³•ã€‚è¿™ç‚¹ä¹Ÿå¾—ç›Šäºpythonåè®®å¼çš„è®¾è®¡ã€‚ - å†…å­˜å…±äº«ã€‚åŒä¸€ä¸ªç±»çš„å¤šä¸ªå®ä¾‹åœ¨å†…å­˜ä¸­å…±äº«ç›¸åŒçš„ hashcode å’Œ key çš„å‚¨å­˜ï¼Œä½¿å¾—pythonè¿è¡Œæ—¶åˆ»çš„å­—å…¸å†…å­˜å ç”¨å‡å°‘äº†10%-20%ã€‚å­—å…¸åˆ›å»ºåœ¨ä¸€ä¸ªç±»çš„ç¬¬ä¸€ä¸ªå®ä¾‹ __init__ æ—¶ï¼Œå› æ­¤æˆ‘ä»¬å»ºè®®åœ¨ç±»çš„ __init__ ä¸­åˆå§‹åŒ–å…¨éƒ¨å¯èƒ½å°†è¦ç”¨åˆ°çš„å®ä¾‹å˜é‡ï¼Œå¦åˆ™æ–°çš„å˜é‡è¢«æ·»åŠ æ—¶å€™å°†ä¼šç”¨ä¹‹å‰æœºåˆ¶çš„å˜é‡å­—å…¸ï¼Œä»è€Œå¯¼è‡´æ— æ³•äº«å—å†…å­˜å…±äº«çš„ä¼˜åŠ¿ã€‚ - pythonä¸ºäº†é˜²æ­¢å› ä¸ºhash conflictè€Œå¼•èµ·çš„DOSæ”»å‡»ï¼Œåœ¨3.3ç‰ˆæœ¬ä¸­å°†hashæ–¹æ³•çš„å› å­è®¾ç½®ä¸ºä¸€ä¸ªéšæœºå€¼ï¼Œå› æ­¤æˆ‘ä»¬æ¯æ¬¡ä»resizeåçš„å­—å…¸ä¸­å–å€¼æ—¶å°†ä¼šçš„åˆ°ä¸åŒé¡ºåºçš„æ•°å€¼ã€‚ - SipHashæ˜¯python3.4-3.6ç‰ˆæœ¬ä¸­å¯¹éšæœºhashçš„æ›¿ä»£ã€‚ - å—æ•°æ®åº“åŠç´¢å¼•çš„å¯å‘ï¼ŒRaymond Hettingeråœ¨python3.6ç‰ˆæœ¬ä¸­éƒ¨ç½²äº†æ–°çš„å­—å…¸æœºåˆ¶ã€‚åŸå…ˆçš„å­—å…¸æœºåˆ¶å°†ä¼šä½¿å­—å…¸å“ˆå¸Œè¡¨ä¿æŒ1/3çš„ç©ºé—´æ¥å‡å°‘hash conflitçš„äº§ç”Ÿã€‚è¿™æ ·æ¯ä¸ªç©ºé—²é”®å€¼å¯¹å°†ä¼šäº§ç”Ÿ24æ¯”ç‰¹çš„å†…å­˜æµªè´¹ã€‚æ–°çš„æœºåˆ¶ç”¨ä¸€ä¸ªç´¢å¼•æ•°ç»„æœºåˆ¶å»é™¤äº†è¿™äº›ç©ºé—´çš„æµªè´¹å¹¶ä¸”ä½¿å¾—å­—å…¸ä¸­çš„é”®å€¼å¯¹åœ¨å­—å…¸resizeåä¹Ÿèƒ½ä¿æŒé”®å€¼å¯¹çš„åŸæœ¬è¾“å…¥é¡ºåºã€‚è¿™ä¸ªæœºåˆ¶ç›¸è¾ƒäº3.5ç‰ˆæœ¬èƒ½å‡å°‘å­—å…¸20%è‡³25%çš„å†…å­˜ä½¿ç”¨ã€‚ - ç°åœ¨æ¯ä¸ªå­—å…¸ä¼šæœ‰ä¸ªç‰ˆæœ¬ï¼Œè¿™æ ·æˆ‘ä»¬å¤„ç†å½“ç›¸åŒç‰ˆæœ¬çš„å­—å…¸æ—¶å°±ä¸ç”¨ä»å¤´éå†æ¯ä¸€ä¸ªå­—å…¸äº†ã€‚ dit = { - 1 : 'a' } for i in range ( 27 , 20 , - 1 ): dit [ i ] = i print ( list ( dit . keys ())) for i in range ( 6 , 20 ): dit [ i ] = i print ( list ( dit . keys ())) ä»¥ä¸Šè¿™æ®µä»£ç åœ¨python2.7ä¸­ç”±äºresizeå¯èƒ½ä¼šå¾—åˆ°ä»¥ä¸‹çš„ç»“æœï¼š [ 21 , 22 , 23 , 24 , 25 , 26 , 27 , - 1 ] [ 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , - 1 ] è€Œåœ¨pytho3.6ä¸­åˆ™èƒ½ä¿æŒå…ƒç´ å½•å…¥çš„é¡ºåºï¼š [ - 1 , 27 , 26 , 25 , 24 , 23 , 22 , 21 ] [ - 1 , 27 , 26 , 25 , 24 , 23 , 22 , 21 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 ] Machine learning libraries åœ¨è¿™ä¸ªè°ˆè¯ä¸­ï¼ŒMichael Kennedyå’ŒPete Garcinè°ˆè®ºäº†ä»–ä»¬è®¤ä¸ºçš„pythonæœ€å¥½çš„åä¸ªåº“ã€‚ - Numpy å’Œ Scipy æ˜¯ä¸€åˆ‡æ¨¡å—çš„åŸºç¡€ã€‚ - Scikit-learn æ˜¯ä¸€ä¸ªè¾ƒæ—©çš„æ¨¡å—ï¼Œæ˜¯ Scipy å®¶æ—çš„ä¸€éƒ¨åˆ†ã€‚å®ƒæä¾›ç»™äº†æˆ‘ä»¬ä¸€äº›å¸¸ç”¨çš„æœºå™¨å­¦ä¹ ç®—æ³•å’Œåˆ†ç±»ï¼Œèšç±»ï¼Œå›å½’ï¼Œæ¨¡å‹å·¥å…·ã€‚å®ƒéå¸¸ç®€æ˜ç›´æ¥ï¼Œä½†ç¼ºå°‘å¯¹GPUè¿ç®—çš„æ”¯æŒã€‚ - Keras æ˜¯ä¸€ä¸ªæ¯”è¾ƒæ–°çš„high-levelæ¨¡å—ï¼Œå¯ä»¥ Theano , Tensorflow , CNTK ä¸­çš„ä»»æ„ä¸€ä¸ªæ¨¡å—ä½œä¸ºåå°ã€‚å®ƒçš„è®¾è®¡ç›®æ ‡æ˜¯æœºå™¨å­¦æœŸç¨‹åºçš„å¿«é€Ÿå¼€å‘ï¼Œå› æ­¤å…·æœ‰æé«˜çš„æ˜“ç”¨æ€§ã€‚ - Tensorflow æ˜¯ç°åœ¨çƒ­åº¦æœ€é«˜çš„æœºå™¨å­¦ä¹ æ¨¡å—ï¼Œå®ƒèƒ½å……åˆ†åˆ©ç”¨GPUçš„çŸ©é˜µåŠå¹¶è¡Œè®¡ç®—ä¼˜åŠ¿ã€‚è€Œä»Googleè¦æ¨å‡ºTPUè¿™ä¸€ä¸¾æªæ¥çœ‹ï¼ŒGoogleä¹Ÿæ­£åœ¨å¤§åŠ›æ¨å¹¿è¿™ä¸€æ¨¡å—ã€‚ - Theano æ¯”è¾ƒè€è¿ˆï¼Œä¹Ÿæ˜¯åŒ Tensorflow ä¸€æ ·çš„low-levelçš„æœºå™¨å­¦ä¹ æ¨¡å—ã€‚ç”±äºå®ƒçš„æ ¸å¿ƒå¼€å‘éƒ½è·‘å»è°·æ­Œäº†ï¼Œæ‰€ä»¥å®ƒå’Œ Tensorflow å…¶å®éå¸¸ç›¸åƒã€‚ - é™¤äº†æœºå™¨å­¦ä¹ ç®—æ³•ï¼Œä¸ºäº†è·å¾—å¹²å‡€çš„æ•°æ®ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦ Pandas æ¥å¸®åŠ©æˆ‘ä»¬å¤„ç†çŸ©é˜µæ•°æ®ã€‚å®ƒä¹Ÿæ˜¯ Scipy å®¶æ—çš„ä¸€éƒ¨åˆ†ã€‚ - Caffe å’Œ Caffe2 æ˜¯ç”±Facebookåœ¨èƒŒåæ”¯æŒçš„æœºå™¨è§†è§‰é¡¹ç›®ã€‚å®ƒä»¬é’ˆå¯¹äº’è”ç½‘åŠç§»åŠ¨éƒ¨ç½²åšäº†ç›¸å¯¹çš„ä¼˜åŒ–ã€‚ - Jupyter æ”¹å˜äº†æ•°æ®ç§‘å­¦å®¶ä»¬äº¤æµå’Œå‘è¡¨ç ”ç©¶æˆæœçš„æ–¹å¼ã€‚ - CNTK æ˜¯å¾®è½¯æœ€æ–°çš„æœºå™¨å­¦ä¹ æ¨¡å—ï¼Œæ“…é•¿low-levelçš„è®¡ç®—ï¼Œå¦‚æœ‰å‘å›¾ã€‚ - NLTK æ˜¯ä¸€ä¸ªç›¸å¯¹æˆç†Ÿè‡ªç„¶è¯­è¨€å¤„ç†æ¨¡å—ï¼Œæ“…é•¿æ–‡æœ¬åˆ†æå’Œå¤„ç†ã€‚ Pete Garcinæœ€åå‘åˆå­¦è€…æ¨èäº† Keras ä½œä¸ºäº†è§£æœºå™¨å­¦ä¹ çš„å…¥å£ã€‚ Additional","tags":"Python","title":"Python asyncï¼Œdictionaryï¼Œmachine learning moudlesç¬”è®°"},{"url":"python-yield-tutorial-markdown.html","text":"Description æœ¬æ–‡æ˜¯æˆ‘çš„ jupyter notebook çš„markdownç‰ˆæœ¬ã€‚ An introduction to Python yield WHAT A function and a generater def fun (): return 'fun' def gen (): yield 'gen' fun () 'fun' gen () <generator object gen at 0x0000000007503780> A range() like example for ... in range() loop is used quite often when iterating objects in python . In below example, we made a generator to mock range() function. def counter ( top ): n = 0 while n < top : yield n n += 1 for i in counter ( 10 ): print ( i ) 0 1 2 3 4 5 6 7 8 9 Under the covers Generator object runs in response to next() or send() def counter_sample ( top ): n = 0 while n < top : print ( '-> before yield' ) yield n print ( '-> after yield' ) n += 1 c = counter_sample ( 5 ) print ( next ( c )) -> before yield 0 StopIteration raised when function returns print ( c . send ( None )) -> after yield -> before yield 1 Create coroutine with yield You can send data to a coroutine. def generator (): item = yield print ( 'item = {} ' . format ( item )) yield 10 Prime the coroutine g = generator () g . send ( None ) Send data value = g . send ( 20 ) item = 20 print ( 'value = {} ' . format ( value )) value = 10 A coroutine which receives data as well as produces data def averager (): total , count , average = 0.0 , 0 , None while True : term = yield average total += term count += 1 average = total / count avg = averager () avg . send ( None ) avg . send ( 10 ) 10.0 avg . send ( 20 ) 15.0 avg . send ( 30 ) 20.0 Three features of coroutines: - When a coroutine run into yield , it will suspend - A caller should schedule the coroutine when it suspended - When a coroutine suspended, it will return control to the caller WHY A tornado example import time import tornado.ioloop import tornado.web import tornado.gen class BadStupidHandler ( tornado . web . RequestHandler ): def get ( self ): for i in range ( 20 ): self . write ( ' {} <br>' . format ( i )) self . flush () time . sleep ( 0.5 ) class GoodStupidHandler ( tornado . web . RequestHandler ): @tornado . gen . coroutine def get ( self ): for i in range ( 20 ): self . write ( ' {} <br>' . format ( i )) self . flush () yield tornado . gen . sleep ( 0.5 ) app = tornado . web . Application ([ ( r '/bad' , BadStupidHandler ), ( r '/good' , GoodStupidHandler ) ]) Refer to documentation Frequently Asked Questions . HOW Use coroutine to simplfy your context manager A context manager is to change: try : f = open ( 'some.txt' ) print ( f . readline ()) # do something with f finally : f . close () coroutine To: with open ( 'some.txt' ) as f : print ( f . readline ()) # do something with f coroutine You can define your own context manager with a class implements __enter__ and __exit__ method class Mirror : def __init__ ( self , num ): self . num = num def __enter__ ( self ): import sys def reverse_write ( text ): self . original_write ( text [:: - 1 ]) self . original_write = sys . stdout . write sys . stdout . write = reverse_write return 'This is mirror {} ' . format ( self . num ) def __exit__ ( self , exc_type , exc_value , traceback ): import sys sys . stdout . write = self . original_write with Mirror ( 1000 ) as first_string : print ( first_string ) print ( 123456789 ) print ( 'Out there' ) 0001 rorrim si sihT 987654321 Out there Use decorator contextlib.contextmanager and generator to simplfy your own context manager import contextlib @contextlib . contextmanager def Mirror_new ( num ): import sys def reverse_write ( text ): original_write ( text [:: - 1 ]) original_write = sys . stdout . write sys . stdout . write = reverse_write yield 'This is mirror {} ' . format ( num ) sys . stdout . write = original_write with Mirror_new ( 1000 ) as first_string : print ( first_string ) print ( 123456789 ) print ( 'Out there' ) 0001 rorrim si sihT 987654321 Out there How does it work? We define a warpper class to proxy our generator: class GeneratorCM : def __init__ ( self , func ): self . _func = func def __call__ ( self , * args , ** kwargs ): self . _gen = self . _func ( * args , ** kwargs ) return self def __enter__ ( self ): return self . _gen . send ( None ) def __exit__ ( self , exc_type , exc_value , traceback ): try : self . _gen . send ( None ) except StopIteration : return True @GeneratorCM def Mirror_custom ( num ): import sys original_write = sys . stdout . write def reverse_write ( text ): original_write ( text [:: - 1 ]) sys . stdout . write = reverse_write yield 'This is mirror {} ' . format ( num ) sys . stdout . write = original_write with Mirror_custom ( 1000 ) as first_string : print ( first_string ) print ( 123456789 ) print ( 'Out there' ) 0001 rorrim si sihT 987654321 Out there GeneratorCM with full try catch is listed below: class GeneratorCM : def __init__ ( self , func ): self . _func = func def __call__ ( self , * args , ** kwargs ): self . _gen = self . _func ( * args , ** kwargs ) return self def __enter__ ( self ): return self . _gen . send ( None ) def __exit__ ( self , exc_type , exc_value , traceback ): try : if exc_type is None : next ( self . _gen ) else : self . _gen . throw ( exc_type , exc_value , traceback ) raise RuntimeError ( \"Generator didn't stop\" ) except StopIteration : return True except : if sys . exc_info ()[ 1 ] is not exc_value : raise Inlined yield Following statement is very common in tornado framwork from tornado import gen @gen . coroutine def fetch_coroutine ( url ): http_client = AsyncHTTPClient () response = yield http_client . fetch ( url ) raise gen . Return ( response . body ) How does it work? First,define a slow function to mock http.fetch : import time import random def func ( x , y ): sleep_time = random . random () * 3 time . sleep ( sleep_time ) print ( 'sleep for {} seconds' . format ( sleep_time )) return x + y We need to our function work like this: from concurrent.futures import ThreadPoolExecutor , Future pool = ThreadPoolExecutor ( max_workers = 8 ) @inlined_future def do_func(x, y): result = yield pool.submit(func, x, y) print('Got:', result) Inspired by @contextmanagerï¼š import wrapt class Task : def __init__ ( self , gen ): self . _gen = gen initive = Future () initive . set_result ( None ) self . step ( initive ) def step ( self , future ): try : next_future = self . _gen . send ( future . result ()) except StopIteration as exc : if exc . value is not None : raise exc else : next_future . add_done_callback ( self . step ) @wrapt . decorator def inlined_future ( wrapped , instance , args , kwargs ): Task ( wrapped ( * args , ** kwargs )) @inlined_future def do_func ( x , y ): result = yield pool . submit ( func , x , y ) print ( 'Got:' , result ) def do_func_slow ( x , y ): result = func ( x , y ) print ( 'Got:' , result ) for i in range ( 5 ): do_func_slow ( i , i ) sleep for 2.4873064812324777 seconds Got: 0 sleep for 1.4432468827933995 seconds Got: 2 sleep for 1.9532320529696823 seconds Got: 4 sleep for 0.584825861467138 seconds Got: 6 sleep for 1.8091265383050155 seconds Got: 8 for i in range ( 5 ): do_func ( i , i ) Additional: How coroutine work import dis import inspect def gen_fn (): result = yield 1 print ( 'result of yield: {} ' . format ( result )) result2 = yield 2 print ( 'result of 2nd yield: {} ' . format ( result2 )) return 'done' def normal_fn (): return 1 a = gen_fn () a . send ( None ) 1 gen_fn <function __main__.gen_fn> normal_fn <function __main__.normal_fn> bool ( gen_fn . __code__ . co_flags & inspect . CO_GENERATOR ) True bin ( inspect . CO_GENERATOR ) '0b100000' bool ( normal_fn . __code__ . co_flags & inspect . CO_GENERATOR ) False gen1 = gen_fn () type ( gen1 ) generator gen1 . gi_code . co_name 'gen_fn' All generators from calls to gen_fn point to this same code. But each has its own stack frame. This stack frame is not on any actual stack, it sits in heap memory. gen2 = gen_fn () gen1 . gi_code is gen2 . gi_code True gen1 . gi_frame is gen2 . gi_frame False gen1 . send ( None ) gen1 . gi_frame . f_lasti 2 dis . dis ( gen1 ) 5 0 LOAD_CONST 1 ( 1 ) 2 YIELD_VALUE 4 STORE_FAST 0 ( result ) 6 6 LOAD_GLOBAL 0 ( print ) 8 LOAD_CONST 2 ( 'result of yield: {}' ) 10 LOAD_ATTR 1 ( format ) 12 LOAD_FAST 0 ( result ) 14 CALL_FUNCTION 1 16 CALL_FUNCTION 1 18 POP_TOP 7 20 LOAD_CONST 3 ( 2 ) 22 YIELD_VALUE 24 STORE_FAST 1 ( result2 ) 8 26 LOAD_GLOBAL 0 ( print ) 28 LOAD_CONST 4 ( 'result of 2nd yield: {}' ) 30 LOAD_ATTR 1 ( format ) 32 LOAD_FAST 1 ( result2 ) 34 CALL_FUNCTION 1 36 CALL_FUNCTION 1 38 POP_TOP 9 40 LOAD_CONST 5 ( 'done' ) 42 RETURN_VALUE gen1 . send ( 'hello' ) gen1 . gi_frame . f_lasti result of yield : hello 22 gen1 . gi_frame . f_locals {'result': 'hello'} gen1 . send ( 'world' ) result of 2 nd yield : world --------------------------------------------------------------------------- StopIteration Traceback ( most recent call last ) < ipython - input - 124 - b432c08ca417 > in < module > () ----> 1 gen1.send('world') StopIteration : done sleep for 0 . 9637312558255126 seconds Got : 8 sleep for 1 . 0164703671835906 seconds Got : 2 sleep for 1 . 0941822049442602 seconds Got : 4 sleep for 2 . 2731928774129755 seconds Got : 0 sleep for 2 . 4067928659249773 seconds Got : 6 Reference Generators: The Final Frontier Effective Pythonï¼šConsider Coroutines to Run Many Functions Concurrently Python Cookbook 3: ä¸ç”¨é€’å½’å®ç°è®¿é—®è€…æ¨¡å¼ 500 line or less:A Web Crawler With asyncio Coroutines ä¸€ä¸ªç®€å•çš„æ–‡æœ¬è§£æè®¡ç®—å™¨","tags":"Python","title":"Python yield tutorial markdown"},{"url":"pythonla-ji-chu-li-ji-zhi.html","text":"Description æœ¬æ–‡ç¯å¢ƒä¸ºpython3.6ã€‚ä¸cä¸­æ‹¥æœ‰çš„mallocå’Œfreeä¸åŒï¼Œpythonä¸­çš„å†…å­˜æ˜¯ç¼–è¯‘å™¨è‡ªåŠ¨å®Œæˆï¼Œå› æ­¤æˆ‘ä»¬å¹¶ä¸éœ€è¦æ—¶åˆ»å…³å¿ƒå†…å­˜çš„ä½¿ç”¨æƒ…å†µã€‚åœ¨ Things you need to know about garbage collection in Python ä¸€æ–‡ä¸­ç»™æˆ‘ä»¬è¯¦ç»†ä»‹ç»äº†python gcçš„å…·ä½“å®ç°åŠç»†èŠ‚ï¼Œæœ¬æ–‡ä¸»è¦å‚è€ƒè¯¥åšå®¢æ¥å¯¹pythonåƒåœ¾å¤„ç†æœºåˆ¶åšä¸€äº›æ€»ç»“ã€‚ å†…å­˜ç®¡ç† åœ¨pythonä¸­å°äº512kçš„å¯¹è±¡æ˜¯ä¼šåœ¨å†…å­˜ä¸­ç¼“å­˜çš„ï¼Œè¿™å°±å¯¼è‡´å°äº256çš„æ•´å½¢åŠä¸€äº›çŸ­å­—ç¬¦ä¸²åœ¨ç¨‹åºä¸­å®é™…å…±äº«äº†åŒä¸€ä¸ªå†…å­˜åœ°å€ã€‚åƒè¿™æ ·ï¼Œpythonä¸ºäº†æé«˜å¯¹å†…å­˜æ“ä½œçš„æ•ˆç‡åŠå‡å°‘ç¢ç‰‡ï¼Œåœ¨é€šç”¨å†…å­˜åˆ†é…å™¨ä¸Šå‡è®¾äº†ä¸€ä¸ªç‰¹æ®Šçš„ç®¡ç†å™¨â€”â€”â€”â€” PyMalloc ã€‚åœ¨ cpython ä¸­ï¼Œå†…å­˜æ¨¡å‹è¢«å½¢å®¹ä¸ºå¤§è‡´å¦‚ä¸‹ï¼š _____ ______ ______ ________ [ int ] [ dict ] [ list ] ... [ string ] Python core | +3 | <----- Object-specific memory -----> | <-- Non-object memory --> | _______________________________ | | [ Python's object allocator ] | | +2 | ####### Object memory ####### | <------ Internal buffers ------> | ______________________________________________________________ | [ Python's raw memory allocator (PyMem_ API) ] | +1 | <----- Python memory (under PyMem manager's control) ------> | | __________________________________________________________________ [ Underlying general-purpose allocator (ex: C library malloc) ] 0 | <------ Virtual memory allocated for the python process -------> | ========================================================================= _______________________________________________________________________ [ OS-specific Virtual Memory Manager (VMM) ] -1 | <--- Kernel dynamic storage allocation & management (page-based) ---> | __________________________________ __________________________________ [ ] [ ] -2 | <-- Physical memory: ROM/RAM --> | | <-- Secondary storage (swap) --> | pythonä¸­å ç”¨å†…å­˜è¾ƒå¤§çš„å¯¹è±¡ä¼šè¢«åˆ†é…åˆ°æ ‡å‡†çš„cå†…å­˜åˆ†é…å™¨ï¼Œå°å¯¹è±¡åˆ†é…å™¨åˆ™ç”±ä¸‰ä¸ªçº§åˆ«çš„æŠ½è±¡æ„æˆ Arena ã€ Pool ã€ Block ã€‚ Block Blockï¼ˆå—ï¼‰æ˜¯å›ºå®šå¤§å°ï¼ˆ8-512kï¼‰çš„å†…å­˜å—ã€‚ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œè¿™äº›å—è¢«åˆ†ä¸º64ç±»ï¼š Request in bytes Size of allocated block size class idx 1-8 8 0 9-16 16 1 17-24 24 2 25-32 32 3 33-40 40 4 41-48 48 5 ... ... ... 505-512 512 63 Pool Poolï¼ˆæ± ï¼‰æ˜¯ç›¸åŒå¤§å°Blockï¼ˆå—ï¼‰çš„é›†åˆã€‚é€šå¸¸æ¥è¯´ï¼Œæ± çš„å¤§å°ç­‰äºå†…å­˜é¡µçš„å¤§å°ã€‚å›ºå®šå—çš„å¤§å°èƒ½å‡å°‘å†…å­˜ç¢ç‰‡çš„äº§ç”Ÿâ€”â€”â€”â€”å½“ä¸€ä¸ªå¯¹è±¡è¢«é”€æ¯çš„æ—¶å€™ï¼Œå†…å­˜ç®¡ç†å™¨èƒ½è½»æ¾åœ°å°†ç›¸åŒå¤§å°çš„å¯¹è±¡è£…è½½å…¥å—ä¸­ã€‚ åœ¨cpythonä¸­ï¼Œæ± è¢«å®šä¹‰ä¸ºå¦‚ä¸‹ç»“æ„ï¼š /* Pool for small blocks. */ struct pool_header { union { block * _padding ; uint count ; } ref ; /* number of allocated blocks */ block * freeblock ; /* pool's free list head */ struct pool_header * nextpool ; /* next pool of this size class */ struct pool_header * prevpool ; /* previous pool \"\" */ uint arenaindex ; /* index into arenas of base adr */ uint szidx ; /* block size class index */ uint nextoffset ; /* bytes to virgin block */ uint maxnextoffset ; /* largest valid nextoffset */ }; æ± ä½¿ç”¨çš„æ˜¯åŒå‘é“¾è¡¨çš„ç»“æ„ï¼Œ nextpool å’Œ prevpool å­—æ®µæŒ‡å‘é“¾è¡¨èŠ‚ç‚¹ã€‚ szidx å­—æ®µä¿å­˜äº†ä¸Šæ–‡æåˆ°çš„è¯¥æ± çš„å¤§å°ç±»åˆ«çš„åºå·ï¼ˆsize class indexï¼‰ï¼Œè€Œ ref.count å­—æ®µåˆ™å‚¨å­˜äº†è¢«å ç”¨äº†çš„å—çš„æ•°é‡ã€‚ arenaindex å‚¨å­˜äº†è¯¥æ± åœ¨æ‰€åœ¨çš„å†…å­˜ç©ºé—´çš„åºå·ã€‚å¯¹äº freeblock åˆ™æ˜¯è¿™ä¹ˆè§£é‡Šçš„ï¼š pool -> freeblock points to the start of a singly - linked list of free blocks within the pool . When a block is freed , it 's inserted at the front of its pool' s freeblock list . Note that the available blocks in a pool are * not * linked all together when a pool is initialized . Instead only \"the first two\" ( lowest addresses ) blocks are set up , returning the first such block , and setting pool -> freeblock to a one - block list holding the second such block . This is consistent with that pymalloc strives at all levels ( arena , pool , and block ) never to touch a piece of memory until it 's actually needed. So long as a pool is in the used state, we' re certain there * is * a block available for allocating , and pool -> freeblock is not NULL . If pool -> freeblock points to the end of the free list before we 've carved the entire pool into blocks, that means we simply haven' t yet gotten to one of the higher - address blocks . The offset from the pool_header to the start of \"the next\" virgin block is stored in the pool_header nextoffset member , and the largest value of nextoffset that makes sense is stored in the maxnextoffset member when a pool is initialized . All the blocks in a pool have been passed out at least once when and only when nextoffset > maxnextoffset . å¤§æ¦‚å°±æ˜¯è¯´ï¼Œ freeblock å­—æ®µæŒ‡å‘äº†ä¸€ä¸ªå•é¡¹é“¾è¡¨ï¼Œè¿™ä¸ªé“¾è¡¨è¿æ¥äº†è¯¥æ± ä¸­çš„ä¸€éƒ¨åˆ†å¯ç”¨çš„å—ã€‚ä¹‹æ‰€ä»¥è¯´æ˜¯â€˜ä¸€éƒ¨åˆ†'æ˜¯å› ä¸ºåœ¨åˆå§‹åŒ–æ± çš„æ—¶å€™ç³»ç»Ÿåªä¼šç»™å‰ä¸¤ç»™å†…å­˜å—åˆ†é…å†…å­˜ï¼Œè¿™æ ·ä½¿å¾—åªæœ‰å½“éœ€è¦åˆ†é…æ–°å†…å­˜çš„æ—¶å€™æ‰ä¼šè®©æ± å ç”¨æ–°çš„å—ç©ºé—´ï¼ŒèŠ‚çœäº†å†…å­˜çš„æ¶ˆè€—ã€‚åˆå§‹åŒ–æ± çš„æ—¶ä¼šè¿›è¡Œçš„å¦ä¸€ä¸ªæ“ä½œæ˜¯è®¾ç½® maxnextoffset å­—æ®µï¼Œå³å†…å­˜æŒ‡é’ˆæœ€å¤§åç§»é‡ã€‚å½“éœ€è¦æ‹“å±•æ–°çš„å—ç©ºé—´æ—¶ï¼Œé€šè¿‡ szidx åŠ nextoffset å­—æ®µè®¡ç®—å‡ºæ–°å—æ‰€å ç”¨çš„å†…å­˜åœ°å€åŒºåŸŸå¹¶åˆ†é…å†…å­˜ã€‚æœ€åï¼Œå½“ nextoffset å¤§äº maxnextoffset æ—¶ï¼Œæ•´ä¸ªæ± çš„å°±æ»¡äº†ã€‚ ä¸ºäº†æ›´æœ‰æ•ˆåœ°è¿›è¡Œæ± çš„ç®¡ç†ï¼Œpythonå¼•å…¥äº† usedpools æ•°ç»„æ¥å‚¨å­˜å„ä¸ª size class çš„å—ï¼š å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå—å’Œæ± å¹¶ä¸æ˜¯ç›´æ¥åˆ†é…å†…å­˜ï¼Œå®ƒä»¬æ‰€åˆ†é…çš„å†…å­˜æ¥è‡ªäºå…¶æ‰€åœ¨çš„Arenaï¼ˆå†…å­˜ç©ºé—´ï¼‰ã€‚ Arena Arenaï¼ˆå†…å­˜ç©ºé—´ï¼‰æ˜¯ç”±64ä¸ªæ± ç»„æˆçš„åœ¨å †ä¸Šçš„256kçš„ç©ºé—´ï¼ŒåŒæ ·ä¹Ÿæ˜¯åŒå‘é“¾è¡¨ã€‚å®ƒçš„ç»“æ„å¦‚ä¸‹ï¼š struct arena_object { uintptr_t address ; block * pool_address ; uint nfreepools ; uint ntotalpools ; struct pool_header * freepools ; struct arena_object * nextarena ; struct arena_object * prevarena ; }; å…¶ä¸­ ntotalpools å’Œ nfreepools å‚¨å­˜äº†å†…å­˜ç©ºé—´ä¸Šå¯ç”¨æ± çš„ä¿¡æ¯ã€‚ freepools æŒ‡å‘ä¸€ä¸ªå¯ç”¨æ± çš„é“¾è¡¨ã€‚ pythonä¸­çš„åƒåœ¾å¤„ç† pythonä¸­çš„åƒåœ¾å¤„ç†æœºåˆ¶ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼š å¼•ç”¨è®¡æ•°ï¼ˆ reference counting ï¼‰ åˆ†ä»£åƒåœ¾æ”¶é›†å™¨ï¼ˆ generational garbage collector ï¼‰ å¼•ç”¨è®¡æ•°æ˜¯æˆ‘ä»¬æ— æ³•æŸ“æŒ‡åªèƒ½äº†è§£çš„ä¸€éƒ¨åˆ†ï¼Œä½†å®ƒçš„æœºåˆ¶ä¹Ÿå¾ˆç®€å•ï¼Œå°±æ˜¯ä¸ºæ¯ä¸ªå¯¹è±¡ç»´æŠ¤ä¸€ä¸ªå¼•ç”¨è®¡æ•°ï¼Œå½“è¿™ä¸ªå¼•ç”¨è®¡æ•°è½ä¸º0çš„æ—¶å€™ç«‹åˆ»é‡Šæ”¾å¯¹è±¡æ‰€å å†…å­˜ã€‚å®ƒæ— æ³•å¤„ç†å¾ªç¯å¼•ç”¨çš„æƒ…å†µï¼Œåˆ†ä»£åƒåœ¾æ”¶é›†å™¨å³ gc æ¨¡å—åˆ™æ˜¯ä¸ºäº†åº”å¯¹è¿™ç§æƒ…å†µè€Œäº§ç”Ÿã€‚è¿™ä¸¤ç§æŠ€æœ¯ç›¸è¾…ç›¸æˆç»„æˆäº†pythonä¸­çš„åƒåœ¾å¤„ç†æœºåˆ¶ã€‚ åŸºäºå¼•ç”¨è®¡æ•°çš„åƒåœ¾æ”¶é›†æœºåˆ¶æ˜¯ä¸€ç§ç›¸å¯¹ç®€å•çš„æœºåˆ¶ã€‚åœ¨ä¸€äº›å…¶ä»–è¯­è¨€ä¸­ï¼Œæœ‰ä¸€äº›æ›´ç°ä»£çš„æœºåˆ¶ï¼Œå¦‚javaä¸­çš„å¯è¾¾æ€§ç®—æ³•ã€‚è¿™ä¸ªç®—æ³•çš„åŸºæœ¬æ€è·¯å°±æ˜¯é€šè¿‡ä¸€ç³»åˆ—çš„ç§°ä¸º GC Roots çš„å¯¹è±¡ä½œä¸ºèµ·å§‹ç‚¹ï¼Œä»è¿™äº›èŠ‚ç‚¹å¼€å§‹å‘ä¸‹æœç´¢æ‰€æœ‰èµ°è¿‡çš„è·¯å¾„ä½œä¸ºå¼•ç”¨é“¾ï¼Œå½“ä¸€ä¸ªå¯¹è±¡åˆ° GC Roots æ²¡æœ‰ä»»ä½•å¼•ç”¨é“¾ç›¸è¿æ—¶å€™ï¼Œåˆ™è¯æ˜æ­¤å¯¹è±¡ä¸å¯ç”¨ã€‚è¿™ä¸€ç§ç®—æ³•ä¹Ÿèƒ½å¤Ÿé¿å…å¾ªç¯å¼•ç”¨çš„äº§ç”Ÿã€‚ å¼•ç”¨è®¡æ•° åœ¨pythonçš„ c apiæ–‡æ¡£ä¸­ æè¿°äº†cpythonä¸­å¼•ç”¨è®¡æ•°çš„åº•å±‚å®ç°ã€‚ cpythonä¸­é€šè¿‡ Py_INCREF å’Œ Py_DECREF ä¸¤ä¸ªå®æ¥æ§åˆ¶å¼•ç”¨è®¡æ•°çš„å¢åŠ å’Œå‡å°‘ã€‚å¯¹è±¡ææ„å™¨ä¼šè§¦å‘ Py_DECREF å®ï¼Œè¯¥å®ä¼šæ£€æŸ¥å¯¹è±¡çš„å¼•ç”¨è®¡æ•°æ˜¯å¦ä¼šè¢«é™ä¸º0â€”â€”â€”â€”ä¸º0æ—¶åˆ™ç«‹åˆ»é‡Šæ”¾è¯¥å¯¹è±¡çš„å†…å­˜ï¼Œè¿™å°±ä½¿å¾—å¼•ç”¨è®¡æ•°é‡Šæ”¾å†…å­˜å…·æœ‰å³æ—¶æ€§ã€‚ ä½ å¯ä»¥ä½¿ç”¨ sys.getrefcount æ–¹æ³•æ¥å–å¾—æŸä¸ªå¯¹è±¡çš„å¼•ç”¨è®¡æ•°ï¼š import sys foo = [] ### 2 references, 1 from the foo var and 1 from getrefcount print ( sys . getrefcount ( foo )) def bar ( a ): # 4 references # from the foo var, function argument, getrefcount and Python's function stack print ( sys . getrefcount ( a )) bar ( foo ) ### 2 references, the function scope is destroyed print ( sys . getrefcount ( foo )) åˆ†ä»£åƒåœ¾æ”¶é›†å™¨ å¼•ç”¨è®¡æ•°è¿™ä¸ªç®€å•çš„æœºåˆ¶ä¼šå¸¦æ¥è®¸å¤šé—®é¢˜ï¼Œå¦‚æ— æ³•è§£å†³å¾ªç¯å¼•ç”¨ã€éœ€è¦çº¿ç¨‹é”åŠæ•ˆç‡ä½ä¸‹ã€‚ä¸ºäº†è§£å†³å¾ªç¯å¼•ç”¨çš„é—®é¢˜ï¼Œ gcæ¨¡å— åœ¨python 1.5ç‰ˆæœ¬ä¸­è¢«åŠ å…¥ã€‚ ç”±äºå¾ªç¯å¼•ç”¨åªä¼šåœ¨containerå®¹å™¨ç±»å‹ä¸­å‘ç”Ÿï¼Œæ‰€ä»¥ gc æ¨¡å—å¹¶ä¸ä¼šè¿½è¸ªpythonä¸­æ‰€æœ‰çš„å¯¹è±¡ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ gc.is_tracked å‡½æ•°æ¥åˆ¤æ–­æŸä¸ªå¯¹è±¡æ˜¯å¦è¢«è¿½è¸ªï¼š >>> gc . is_tracked ( 0 ) False >>> gc . is_tracked ( \"a\" ) False >>> gc . is_tracked ([]) True >>> gc . is_tracked ({}) #è¿™ä¸ªå­—å…¸ä¸ºç©ºï¼Œå› æ­¤æœªè¢«è¿½è¸ª False >>> gc . is_tracked ({ \"a\" : 1 }) #è¿™ä¸ªå­—å…¸æ‰€æœ‰å…ƒç´ éƒ½ä¸ºåŸå­ç±»å‹ï¼Œå› æ­¤æœªè¢«è¿½è¸ª False >>> gc . is_tracked ({ \"a\" : []}) True ä¸å¼•ç”¨è®¡æ•°æœºåˆ¶çš„å³æ—¶è§¦å‘ä¸åŒçš„æ˜¯ï¼Œä¸ºäº†ä¿è¯æ€§èƒ½ gc å¹¶ä¸æ˜¯å®æ—¶è§¦å‘çš„ã€‚ é¦–å…ˆè¦æåˆ°çš„æ˜¯ gc çš„ åˆ†ä»£æœºåˆ¶ ã€‚ä½œä¸ºä¸€ä¸ªåˆ†ä»£åƒåœ¾æ”¶é›†å™¨ï¼Œæ‰€æœ‰è¢« gc è¿½è¸ªçš„å¯¹è±¡è¢«åˆ†ä¸ºä¸‰ä»£ï¼šæ–°ç”Ÿä»£ã€ä¸­å¹´ä»£å’Œè€å¹´ä»£ï¼Œè¾ƒæ–°ä»£çš„å¯¹è±¡å°†ä¼šè¢«æ›´é¢‘ç¹çš„å¤„ç†ã€‚æ‰€æœ‰æ–°å¯¹è±¡ä¼šè¢«ç•Œå®šä¸ºæ–°ç”Ÿä»£ï¼Œåªæœ‰å½“æŸä¸ªå¯¹è±¡åœ¨ä¸€æ¬¡ gc ä¸­å­˜æ´»ä¸‹æ¥æ—¶å®ƒæ‰ä¼šä½œä¸ºä¸€ä¸ªå¹´è¿ˆçš„å¯¹è±¡è¢«æ ‡è®°ä¸ºæ›´è€çš„ä¸€ä»£ã€‚åˆ†ä»£æœºåˆ¶åœ¨ä¸€å®šç¨‹åº¦ä¸Šä¼˜åŒ–äº† gc çš„æ€§èƒ½ã€‚ å½“æŸä¸€ä»£åŠ å…¥çš„å¯¹è±¡æ•°é‡è¶…è¿‡ä¸€ä¸ªé˜ˆå€¼æ—¶ï¼Œå°±ä¼šè§¦å‘ gc å¤„ç†è¿™ä¸€ä»£åŠæ›´æ–°ä»£çš„å¯¹è±¡ã€‚è¿™ä¸€é˜ˆå€¼å¯ä»¥ä½¿ç”¨ gc.get_threshold æ–¹æ³•è·å¾—ï¼Œå¦‚æ ‡å‡†çš„é˜ˆå€¼ä¸º(700,10,10)åˆ†åˆ«å¯¹åº”æ–°ä¸­è€ä¸‰ä»£çš„é˜ˆå€¼ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œä¸ºäº†æå‡æ€§èƒ½ï¼Œå¯¹ç¬¬ä¸‰ä»£çš„â€˜é•¿å¯¿'å¯¹è±¡çš„æ”¶é›†ï¼ˆå³å…¨å±€åƒåœ¾æ”¶é›†ï¼‰éœ€è¦è¾¾åˆ° ä¸€ä¸ªç‰¹æ€§çš„æ ‡å‡† â€”â€”â€”â€” long_lived_pending / long_lived_total çš„æ¯”ä¾‹å¤§äº25%ã€‚ long_lived_total ä¸ºåœ¨æœ€è¿‘ä¸€æ¬¡å…¨å±€ gc ä¸­å­˜æ´»ä¸‹æ¥çš„å¯¹è±¡çš„æ•°é‡ï¼Œ long_lived_pending ä¸ºåœ¨æ‰€æœ‰éå…¨å±€ gc ä¸­å­˜æ´»ä¸‹æ¥çš„ï¼Œç°åœ¨å¤„åœ¨è€å¹´ä»£çš„å¯¹è±¡çš„æ•°é‡ã€‚ å…¶æ¬¡æˆ‘ä»¬è¦æ¢è®¨çš„æ˜¯pythonä¸­ æ‰¾å‡ºå¼•ç”¨å¾ªç¯çš„ç®—æ³• ã€‚æˆ‘ä»¬ç»å¸¸çœ‹åˆ°å¯¹è¯¥ç®—æ³•çš„æè¿°ä¸ºï¼šæ‰¾åˆ°ç³»ç»Ÿçš„ æ ¹ å¯¹è±¡ï¼Œä»è¯¥å¯¹è±¡å¼€å§‹éå†æ‰€æœ‰è¢«è¿½è¸ªçš„å®¹å™¨å¯¹è±¡ï¼Œè¿™äº›å¯åˆ°è¾¾çš„å¯¹è±¡æ˜¯æ´»ç€çš„ï¼›é‡Šæ”¾æ‰€æœ‰å…¶ä»–å¯¹è±¡ã€‚ç„¶è€Œå› ä¸ºæˆ‘ä»¬æ— æ³•å®Œå…¨æ‰¾åˆ°æ‹“å±•æ¨¡å—çš„ æ ¹ å¯¹è±¡ï¼Œè¿™ç§ä¼ ç»Ÿçš„æ–¹å¼å·²ç»ä¸èƒ½å†å½“ä»Šç‰ˆæœ¬çš„pythonä¸­ä½¿ç”¨äº†ï¼Œå› æ­¤æˆ‘ä»¬å¾—é‡‡å–ä¸€ç§æ–°çš„å¤„ç†å¼•ç”¨å¾ªç¯çš„ç®—æ³•ã€‚æˆ‘ä»¬åªéœ€è¦å¤„ç†è¢«è¿½è¸ªçš„å®¹å™¨å¯¹è±¡ï¼Œå¾—ç›Šäºè¿™ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥è¾ƒå°çš„ä»£ä»·å°†æ‰€æœ‰è¢«è¿½è¸ªçš„å¯¹è±¡ç”¨åŒå‘é“¾è¡¨ä¸²è”èµ·æ¥ï¼ˆå‡å°‘åœ¨ä»»æ„ä½ç½®æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹çš„ä»£ä»·ï¼‰ï¼Œå¹¶åšå¦‚ä¸‹å¤„ç†ï¼š å¯¹é“¾è¡¨ä¸­çš„æ¯ä¸ªå¯¹è±¡ï¼Œè®¾ç½®ä¸€ä¸ª gc_ref så­—æ®µä½¿å…¶ç­‰äºè¯¥å¯¹è±¡çš„å¼•ç”¨è®¡æ•°å€¼ï¼› å¯¹äºé“¾è¡¨ä¸­çš„æ¯ä¸ªå¯¹è±¡ï¼Œæ‰¾åˆ°å®ƒæ‰€å¼•ç”¨çš„ç›®æ ‡å¯¹è±¡å¹¶å‡1è¯¥å®¹å™¨çš„ gc_refs å€¼ï¼› æ‰€æœ‰ gc_refs å€¼å¤§äº1çš„å¯¹è±¡æ˜¯æœ‰è¢«ç«‹æ¡ˆè¡¨å¤–å¯¹è±¡å¼•ç”¨çš„å¯¹è±¡ï¼Œå› æ­¤æˆ‘ä»¬ä¸èƒ½é‡Šæ”¾å®ƒä»¬çš„å†…å­˜ï¼Œå°†å®ƒä»¬ç§»è‡³å¦ä¸€ä¸ªé›†åˆä¸­å»ï¼ˆæ›´å¹´è¿ˆçš„ä»£ï¼‰ï¼› æ‰€æœ‰è¢«è¿™äº›è½¬ç§»çš„å®¹å™¨å¯¹è±¡å¼•ç”¨çš„é“¾è¡¨ä¸­å¯¹è±¡ä¹Ÿä¸èƒ½å¤Ÿè¢«é‡Šæ”¾ï¼Œä¹Ÿå°†å®ƒä»¬ç§»åˆ°å¦ä¸€ä¸ªé›†åˆä¸­ï¼Œå¯¹è¢«å®ƒä»¬å¼•ç”¨çš„å¯¹è±¡åšç›¸åŒçš„æ“ä½œï¼› ç°åœ¨æˆ‘ä»¬çš„é“¾è¡¨é‡Œå‰©ä¸‹å¯¹è±¡å°±æ˜¯è¢«å¾ªç¯å¼•ç”¨çš„çš„å¯¹è±¡ï¼Œå°†å®ƒä»¬é‡Šæ”¾ï¼› æ€»ç»“ å°½ç®¡æœ‰åˆ†ä»£åƒåœ¾æ”¶é›†å™¨å¸®åŠ©æˆ‘ä»¬å¤„ç†å¾ªç¯å¼•ç”¨çš„é—®é¢˜ï¼Œä½†åœ¨æˆ‘ä»¬çš„ä»£ç ä¸­æˆ‘ä»¬è¿˜æ˜¯è¦æ³¨æ„é¿å…å‡ºç°å¾ªç¯å¼•ç”¨ã€‚å› ä¸ºå¦‚æœå‡ºç°å¤§é‡å¾ªç¯å¼•ç”¨çš„è¯ï¼Œå¯åŠ¨ gc æœºåˆ¶ä¾ç„¶è¦è€—è´¹å¤§é‡çš„èµ„æºã€‚åœ¨è¿™é‡ŒåŸä½œè€…ç»™å¤§å®¶çš„å»ºè®®æ˜¯ä½¿ç”¨pythonä¸­çš„ weakref æ¨¡å—ï¼Œå¼±å¼•ç”¨å¹¶ä¸ä¼šå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œå½“å®ƒå¼•ç”¨çš„å¯¹è±¡ä¸å­˜åœ¨æ—¶å®ƒä¼šè¿”å›Noneç»™è°ƒç”¨æ–¹ã€‚ å¦å¤–ï¼Œå¼•ç”¨è®¡æ•°æ˜¯ä¸€ä¸ªæˆ‘ä»¬ä¸èƒ½æ§åˆ¶çš„æœºåˆ¶ï¼Œä½†åˆ†ä»£åƒåœ¾æ”¶é›†æœºåˆ¶ç¡®æ˜¯å¯ä»¥ç”¨ gc æ¨¡å—hackçš„ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ gc.disable() æ¥å…³é—­åˆ†ä»£åƒåœ¾æ”¶é›†å™¨ï¼Œå¹¶ä¸”ä½¿ç”¨ gc.collect() å‡½æ•°æ¥æ‰‹åŠ¨è§¦å‘åƒåœ¾æ”¶é›†ã€‚ä½†å¾ˆå¤šä»ä¸šäººå‘˜å¹¶ä¸æå€¡è¿™ä¸€ç‚¹ã€‚ Additional å‚è€ƒæ–‡çŒ®ï¼š 1. Things you need to know about garbage collection in Python 2. Python internals: Memory management 3. Objects, Types and Reference Counts 4. Garbage Collector interface 5. Garbage Collection for Python","tags":"Python","title":"Pythonåƒåœ¾å¤„ç†æœºåˆ¶"},{"url":"replace-asyncio-with-native-coroutine.html","text":"Description åœ¨David Beazleyçš„ Topics of Interest(Python Asyncio) æ¼”è®² ä¸­ï¼Œä»–ä»‹ç»äº†ç”±äºasyncåœ¨pythonä¸­çš„ç§ç§å†å²é—ç•™ï¼Œasyncioåº“åœ¨ aync/await è¯­å¥åŠ å…¥ä¹‹åå·²ç»ä¸æ˜¯ä¸€ç§æœ€ç›´æ¥æœ‰æ•ˆçš„python asyncå®ç°ã€‚åœ¨å†™äº†ä¸€ä¸ªç®€å•ç¨‹åºæ›¿ä»£asyncioåº“å¹¶ä¸å…¶åŠgeventåº“çš„æ•ˆç‡åšæ¯”è¾ƒä¹‹åï¼Œæˆ‘ä»¬å‘ç°äº†python3.5ç‰ˆæœ¬ä¸­å¼•å…¥çš„åŸç”Ÿåç¨‹åœ¨å¤„ç†å¼‚æ­¥æ–¹é¢å…·æœ‰éå¸¸é«˜çš„æ•ˆç‡ã€‚åœ¨æ¼”è®²çš„æœ€åä»–æå‡ºï¼Œå¯èƒ½æˆ‘ä»¬éœ€è¦çš„asyncå¹¶ä¸æ˜¯ä¸€ä¸ªåº“è€Œæ›´åƒæ˜¯ä¸€äº›apiæ¥ä¾›æˆ‘ä»¬æ›´æœ‰æ•ˆåœ°åšåº•å±‚çš„ä½¿ç”¨ã€‚ è¿™æ¬¡çš„æ¼”è®²å¯è¿ªäº†æˆ‘è®¸å¤šï¼Œä½†ç¢äºå¹¶æ²¡æœ‰ç›¸å…³çš„pptå’Œææ–™æä¾›ä¸‹è½½ï¼ˆæœ‰éƒ¨åˆ†æ˜¯Davidåœ¨å°ä¸Šå…‰é€ŸLive codingçš„åŸå› ï¼‰ï¼Œæˆ‘åªèƒ½å°†å…¶ä»£ç èªŠå†™ä¸‹æ¥ï¼Œä»¥ä¾›æ£€éªŒåŠç ”ç©¶ï¼Œä½œä¸ºä¸ªäººçš„è¯»ä¹¦ç¬”è®°ã€‚ Core programing of async server å‡†å¤‡å·¥ä½œ æœ¬æ–‡æµ‹è¯•ç¯å¢ƒä¸ºpython3.6ç‰ˆæœ¬ï¼ŒIntel Core i5-6500,8G RAMï¼Œwin10ã€‚ Davidç”¨äº†ä»¥ä¸‹ç¨‹åºæ¥åšasyncæœåŠ¡å™¨çš„æµ‹è¯•ã€‚è¯¥ç¨‹åºä¼šå‘é€10000ä¸ªè¯·æ±‚å¹¶è®¡ç®—æœåŠ¡å™¨å¤„ç†è¯·æ±‚çš„é€Ÿç‡ï¼š #benchmark.py import time from socket import socket , AF_INET , SOCK_STREAM , SOL_SOCKET , SO_REUSEADDR def benchmark ( addr , nmessages ): sock = socket ( AF_INET , SOCK_STREAM ) sock . connect ( addr ) start = time . time () for n in range ( nmessages ): sock . send ( b 'x' ) resp = sock . recv ( 10000 ) end = time . time () print ( nmessages / ( end - start ), 'message/sec' ) benchmark (( 'localhost' , 25000 ), 100000 ) asyncioæœåŠ¡å™¨ é¦–å…ˆæˆ‘ä»¬ç”¨asyncioæ¥æ­å»ºä¸€ä¸ªå¼‚æ­¥æœåŠ¡å™¨ï¼Œä»£ç å¦‚ä¸‹ï¼š #asyncio_server.py import asyncio from socket import socket , AF_INET , SOCK_STREAM , SOL_SOCKET , SO_REUSEADDR loop = asyncio . get_event_loop () async def echo_server ( address ): sock = socket ( AF_INET , SOCK_STREAM ) sock . setsockopt ( SOL_SOCKET , SO_REUSEADDR , 1 ) sock . bind ( address ) sock . listen ( 5 ) sock . setblocking ( False ) while True : client , addr = await loop . sock_accept ( sock ) print ( 'Connection from' , addr ) loop . create_task ( echo_handler ( client )) async def echo_handler ( client ): with client : while True : data = await loop . sock_recv ( client , 10000 ) if not data : break await loop . sock_sendall ( client , b 'Got:' + data ) print ( 'Connection closed' ) loop . create_task ( echo_server (( '' , 25000 ))) loop . run_forever () è®©æˆ‘ä»¬å¯åŠ¨æœåŠ¡å¹¶è¿è¡Œ benchmark.py åšæµ‹è¯•ï¼Œå¾—åˆ°çš„ç»“æœä¸º 9660.489944352334 message/sec ã€‚ åŸç”Ÿåç¨‹å®ç°eventloop è§‚å¯Ÿä»¥ä¸ŠasyncioæœåŠ¡å™¨çš„ä»£ç ï¼Œä¸éš¾å‘ç°å…¶ä¸­ä¸ä»…æœ‰asyncioçš„eventloopï¼ˆåº•å±‚ç”¨ç”Ÿæˆå™¨åç¨‹å’Œ yield from å®ç°ï¼‰è¿˜æœ‰æ–°å¼•å…¥çš„ aync/await åŸç”Ÿåç¨‹ï¼Œæ˜¯ä¸€ç§è·¨ç•Œç»„åˆçš„çŠ¶æ€ã€‚é‚£ä¹ˆèƒ½ä¸èƒ½å°†eventloopä¹Ÿç”¨åŸç”Ÿåç¨‹ä¹Ÿå®ç°å‘¢ï¼ŸDavidç»™å‡ºäº†ä¸€ä¸ªç®€å•çš„æ–¹æ¡ˆï¼š #native_coroutine_asyncio.py from types import coroutine from collections import deque from selectors import DefaultSelector , EVENT_READ , EVENT_WRITE @coroutine def read_wait ( sock ): yield 'read_wait' , sock @coroutine def write_wait ( sock ): yield 'write_wait' , sock class Loop : def __init__ ( self ): self . ready = deque () self . selector = DefaultSelector () async def sock_recv ( self , sock , maxbytes ): await read_wait ( sock ) return sock . recv ( maxbytes ) async def sock_accept ( self , sock ): await read_wait ( sock ) return sock . accept () async def sock_sendall ( self , sock , data ): while data : try : nsent = sock . send ( data ) data = data [ nsent :] except BlockingIOError : await write_wait ( sock ) def create_task ( self , coro ): self . ready . append ( coro ) def run_forever ( self ): while True : while not self . ready : events = self . selector . select () for key , _ in events : self . ready . append ( key . data ) self . selector . unregister ( key . fileobj ) while self . ready : self . current_task = self . ready . popleft () try : op , * args = self . current_task . send ( None ) # run to the yield getattr ( self , op )( * args ) # sneaky method call except StopIteration : pass def read_wait ( self , sock ): self . selector . register ( sock , EVENT_READ , self . current_task ) def write_wait ( self , sock ): self . selector . register ( sock , EVENT_WRITE , self . current_task ) è¿™æ®µä»£ç é‡Œæœ‰äº›æ¯”è¾ƒä¸è§„èŒƒçš„åšæ³•ï¼Œæ¯”å¦‚getattr(self,op)(* args)è¯­å¥ç”¨å­—ç¬¦ä¸²æ¥è¿è¡Œå‡½æ•°ï¼Œä½†æ— ä¼¤å¤§é›…ï¼Œæˆ‘ä»¬çš„ç›®çš„æ˜¯æ£€éªŒå°†eventloopæ¢æˆåŸç”Ÿåç¨‹å®ç°çš„è¯ä¼šæ€æ ·ã€‚ æˆ‘ä»¬å°†asyncioo_serverä¸­çš„eventloopæ¢æˆåˆšåˆšå®ç°çš„ç‰ˆæœ¬,å…¶ä»–ä»£ç ä¿æŒä¸å˜ï¼š import native_coroutine_asyncio as native loop = native . Loop () è¿è¡Œ benchmark.py å‘ç°æ¯ç§’è¯·æ±‚å¤„ç†æ•°å˜ä¸ºäº† 19515.515222278125 message/sec ï¼Œæ•ˆç‡æå‡äº†è¶…è¿‡äº†100%ã€‚ geventæœåŠ¡å™¨ ä¸ºäº†åšå¹³è¡Œæµ‹è¯•ï¼ŒDavidåˆç”¨äº†geventè¿™ä¸ªåº•å±‚ç”±cå®ç°çš„åº“æ¥æ£€æµ‹åŸç”Ÿåç¨‹çš„æ•ˆç‡ç©¶ç«Ÿå¦‚ä½•ï¼Œä»£ç å¦‚ä¸‹ï¼š #gevent_server.py from gevent.server import StreamServer ### this handler will be run for each incoming connection in a deficated greenlet def echo ( socket , address ): print ( 'New connection from {} ' . format ( address )) while True : data = socket . recv ( 100000 ) if not data : break socket . sendall ( b 'Got:' + data ) socket . close () if __name__ == '__main__' : server = StreamServer (( '0.0.0.0' , 25000 ), echo ) server . serve_forever () åœ¨python3.6ä¸‹å®ƒçš„æ¯ç§’å¤„ç†çš„è¯·æ±‚æ•°ä¸º 16807.0229190064 message/sec ï¼ŒåŸç”Ÿåç¨‹ç”šè‡³æ¯”å®ƒè¿˜é«˜ä¸€ç‚¹ã€‚åœ¨Davidçš„çº¿ç¨‹æµ‹è¯•çš„æ—¶å€™ï¼Œä»–è°ƒç”¨äº†python2.7çš„ç¯å¢ƒï¼Œä½¿å®ƒå’ŒåŸç”Ÿåç¨‹çš„æ•ˆç‡æ˜¯å·®ä¸å¤šã€‚ ç»“è¯­ asyncioåº“å…¶å®æœ‰å¾ˆå¤§çš„å†å²åŒ…è¢±ã€‚pythonä¸­çš„åç¨‹ä»å•çº¯çš„yieldç”Ÿæˆå™¨å¼€å§‹ï¼Œç»å†äº†ä¸€ä¸ªä¸€ä¸ªç‰ˆæœ¬çš„å˜è¿ï¼Œç”Ÿæˆå™¨å¾—åˆ°å¯ä»¥ç”¨ send ã€ yield ï¼Œ throw ä¸å¤–ç•Œé€šä¿¡çš„åŠŸèƒ½æˆä¸ºäº†æ„ä¹‰ä¸Šçš„åç¨‹ï¼›ä¹‹åpython3.3ç‰ˆæœ¬ä¸­åŠ å…¥çš„ yield from ç»™äºˆäº†ç”Ÿæˆå™¨åç¨‹æ›´å¤šçš„ä¾¿åˆ©ä¸å¯èƒ½ï¼›ä¸ºæœŸä¸‰å¹´çš„éƒé‡‘é¦™é¡¹ç›®é€æ¸å­µåŒ–å‡ºasyncioåˆç»“åˆäº†ä»¥ä¸Šçš„è¿™äº›åç¨‹ç”Ÿæˆå™¨ç»„ä»¶åŠfuturesã€callbackã€pollingåœ¨3.4ç‰ˆæœ¬ç»™æˆ‘ä»¬å¸¦æ¥äº†æ–°çš„asyncæ¨¡å—ã€‚ä½†è¦æ¼”åŒ–å‡ºè¿™ä¹ˆä¸€ä¸ªæ¨¡å—æ‰€ç»å†çš„ä¸€åˆ‡å®åœ¨æ˜¯å¤ªä¹…å¤ªé•¿ï¼Œæˆ‘ä»¬é¢ä¸´çš„é—®é¢˜æ˜¯ï¼šç»è¿‡äº†è¿™ä¹ˆå¤šç‰ˆæœ¬å’Œè¿™ä¹ˆä¹…çš„æ—¶é—´å˜è¿åæ˜¯å¦å®ƒæ˜¯æœ€å¥½çš„å‘¢ï¼Ÿæœ‰æ²¡æœ‰ä¸€ä¸ªä¸€æ­¥åˆ°ä½çš„åç¨‹æ¥è®©æˆ‘ä»¬ä½¿ç”¨å‘¢ï¼Ÿ åœ¨3.5ç‰ˆæœ¬ä¸­åŸç”Ÿåç¨‹å‡ºç°äº†ï¼Œç»è¿‡ä¸Šé¢çš„å®éªŒæˆ‘ä»¬å¯ä»¥åˆæ­¥åˆ¤æ–­å®ƒæ˜¯ä¸€ä¸ªæ›´å…·æ•ˆç‡çš„åç¨‹å®ç°æ–¹æ¡ˆã€‚è¿™ä¹Ÿè®©pythonæœ‰äº†æ–°çš„ä¼˜è‰¯ç‰¹æ€§ï¼Œä¹Ÿè®©pythonåœ¨ayncæ–¹å‘å‰è¿›äº†ä¸€å¤§æ­¥ã€‚ åœ¨ How the heck does async/await work in Python 3.5? ä¸€æ–‡ä¸­è¯¦ç»†çš„ä»‹ç»äº†python asyncçš„å†å²ï¼š å—åˆ° Iconè¯­è¨€ çš„å¯å‘ï¼Œpython2.2ä¸­ç”Ÿæˆå™¨é¦–æ¬¡è¢« PEP255 - simple generators å¼•å…¥ã€‚ è€Œpython2.5ä¸­yieldè¯­æ³•çš„åŠ å…¥ä½¿å¾—è¿™ä¸€ä½¿ç”¨æ›´å°‘å†…å­˜æ¥è¿­ä»£åºåˆ—çš„æƒ³æ³•æ›´åŠ å®ç”¨ã€‚åœ¨è¿™ä¸€ç‰ˆæœ¬ä¸­ï¼Œ PEP342 - coroutine via enhanced generators ä½¿å¾—pythonä¸­çš„ç”Ÿæˆå™¨ä¸å†è¯•ä¸€ç‚¹å•çº¯çš„è¿­ä»£å™¨ï¼Œè¢«æš‚åœçš„ç”Ÿæˆå™¨ä¹Ÿæ‹¥æœ‰äº†å¯ä»¥è¢«sendä¿¡æ¯ï¼Œä¸å¤–ç•Œäº¤äº’çš„èƒ½åŠ›ã€‚ ç”Ÿæˆå™¨åç¨‹åœ¨ç›¸å®‰æ— äº‹äº†æ•°ä¸ªç‰ˆæœ¬ä¹‹åï¼Œç»ˆäºåœ¨python3.3ç‰ˆæœ¬ä¸­ PEP380 - syntax for delegating to a subgenerator å¢åŠ äº†æ–°çš„è¯­æ³•yield fromç®€åŒ–äº†åç¨‹ä¹‹é—´çš„ç®¡é“å¼è°ƒç”¨ã€‚åŒä¸€ä¸ªç‰ˆæœ¬ä¸­Guidoä¸»å¯¼çš„asyncioåº“ä½œä¸ºå®éªŒæ€§å‘å¸ƒï¼Œå¹¶ä¸”åœ¨python3.4ä¸­æ­£å¼æˆä¸ºæ ‡å‡†åº“çš„ä¸€å‘˜ã€‚ python3.5ä¸­åç¨‹è¿æ¥äº†æ–°çš„çºªå…ƒï¼Œ PEP492 - Coroutine with async and await syntax åŠ å…¥async defã€async withã€async forã€awaitè¯­æ³•åŠç›¸å¯¹åº”çš„åº•å±‚åè®®ã€‚ä¸ºäº†ä»¥ç¤ºåŒºåˆ†ï¼Œç”¨è¿™äº›è¯­æ³•æ„æˆçš„åç¨‹ç§°ä¹‹ä¸ºåŸç”Ÿåç¨‹ã€‚åŸç”Ÿåç¨‹ä¸å¯ä»¥awaitä¸€ä¸ªéåç¨‹ç”Ÿæˆå™¨ï¼Œå½»åº•å°†ç”Ÿæˆå™¨ä¸åç¨‹çš„ç•Œé™åˆ’åˆ†å¼€æ¥ã€‚ Additional æºä»£ç ï¼š 1. asyncio_server.py 2. native_coroutine_asyncio.py 3. gevnet_server.py 4. benchmark.py","tags":"Python","title":"Replace asyncio with native coroutine"},{"url":"how-to-run-pypy.html","text":"Description PyPy æ˜¯ç›®å‰é€Ÿåº¦æœ€å¿«çš„pythonè§£é‡Šå™¨ã€‚å…ˆä¸è¯´å®ƒæƒŠäººçš„ç”¨pythonæ¥ç¼–å†™pythonè§£é‡Šå™¨çš„ç†å¿µï¼Œä¹‹å‰åœ¨planet pythoné‡Œçœ‹åˆ°ä¸€ç¯‡ PyPy è®¡åˆ’ç§»é™¤GILçš„ æ–‡ç«  å°±å·²ç»è®©æˆ‘æƒŠä¸ºå¤©äººäº†ã€‚ å¬äº†David Beazleyåœ¨2012å¹´å…³äº PyPy å’Œ Rpython çš„å‡ ä¸ªæ¼”è®²ä¹‹å( Additional 1,2,3)ï¼Œå°±å¯¹è¿™ä¸ªé¡¹ç›®èµ·äº†æµ“åšçš„å…´è¶£ã€‚ Download and install å¯ä»¥åœ¨ https://pypy.org/download.html ä¸‹è½½åˆ° PyPy çš„æœ€æ–°ç‰ˆæœ¬ã€‚ PyPy å·²ç»æ”¯æŒpython2.7å’Œ3.5.3äº†ï¼Œä½†åŸºäºpython3çš„ PyPy ä¾æ—§æ˜¯ä¸€ä¸ªbetaç‰ˆæœ¬ï¼Œå¹¶ä¸”å£°ç§°æ¯” PyPy 2çš„é€Ÿåº¦æ…¢å¾ˆå¤šã€‚å› ä¸ºæˆ‘ä»¬é€‰æ‹©å®‰è£…äº†åŸºäºUbuntuçš„64ä½ PyPy ã€‚è§£å‹åï¼Œä¸ºäº†æ—¥åä½¿ç”¨æˆ‘ä»¬ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åœ¨ /usr/local/bin ä¸‹åˆ›å»ºä¸€ä¸ªè½¯è¿æ¥,å…¶ä¸­ç¬¬ä¸€ä¸ªç›®å½•ä¸º PyPy çš„å®‰è£…ç›®å½•ï¼š ln -s ~/Program/pypy2-v5.8.0-linux64/bin/pypy /usr/local/bin ç°åœ¨æˆ‘ä»¬å¯ä»¥ç”¨ pypy å‘½ä»¤è¿›å…¥ PyPy çš„shelläº†ã€‚ Performance test Davidç»™äº†ä¸€æ®µæ–æ³¢é‚£å¥‘æ•°åˆ—çš„æµ‹è¯•ä»£ç ,å…¶ä¸­ PyPy æ˜¯å°† target å‡½æ•°ä¸ºå…¥å£å‡½æ•°çš„ã€‚ç»è¿‡æµ‹è¯•ï¼Œè¿™ä¸ª PyPy ç‰ˆæœ¬å·²ç»ä¸éœ€è¦è¿™ä¸ªå…¥å£å‡½æ•°äº†ï¼Œä¹Ÿä¸éœ€è¦å‘Davidåœ¨ Pycon çš„åˆ†äº«ä¸­é‚£æ ·ç”¨ translate.py å…ˆè¿›è¡Œç¼–è¯‘å†æ‰§è¡Œcæºç ã€‚ï¼ˆå½“ç„¶ä¹Ÿå¯èƒ½æ˜¯åªæœ‰ Rpython éœ€è¦è¿™ä¹ˆåšã€‚ï¼‰æœ¬æ–‡æ‰€ç”¨çš„æ–æ³¢é‚£å¥‘æ•°åˆ—çš„æºç å¦‚ä¸‹ï¼š #fib.py import sys def fib ( n ): if n < 2 : return n else : return fib ( n - 1 ) + fib ( n - 2 ) def main ( argv ): print ( fib ( int ( argv [ 1 ]))) return 0 if __name__ == '__main__' : main ( sys . argv ) æˆ‘ä»¬ç”¨python2.7ï¼Œpython3.6ï¼Œpypy5.8è¿™ä¸‰ä¸ªç¯å¢ƒåšæ€§èƒ½æµ‹è¯•ï¼š python2.7 >> time python fib . py 41 165580141 real 0 m47 . 026 s user 0 m46 . 564 s sys 0 m0 . 024 s python3.6 >> time python fib . py 41 165580141 real 1 m9 . 771 s user 1 m8 . 992 s sys 0 m0 . 004 s pypy5.8 >> time pypy fib . py 41 165580141 real 0 m4 . 208 s user 0 m3 . 392 s sys 0 m0 . 736 s ä»¥ä¸Šç»“æœæ˜¯åœ¨è™šæ‹Ÿæœºé‡Œæµ‹è¯•çš„ï¼Œä»…ä¾›å‚è€ƒã€‚å¯ä»¥å‘ç° PyPy çš„è¿ç®—é€Ÿåº¦æ¯” Cpython å¿«äº†éå¸¸å¤šï¼Œä½†python3æ¯”python2è¿˜æ…¢è›®å¤šçš„ç¡®å®è®©æˆ‘å¾ˆæ°”å•Šã€‚å½“ç„¶ï¼Œè¿™åªæ˜¯ä¸€ä¸ªçº¯cpuå¯†é›†å‹ç¨‹åºçš„è¿ç®—ç»“æœï¼Œæ ¹æ® PyPy çš„ç½‘ç«™æ‰€è¯´ï¼Œå¾—ç›ŠäºJITä»¥åŠStacklessï¼Œ PyPy çš„å¹³å‡é€Ÿåº¦åº”è¯¥æ˜¯ Cpython çš„å››å€å·¦å³ã€‚ å€¼å¾—ä¸€æçš„æ˜¯ï¼ŒDavidåœ¨ Pycon æ¼”ç¤ºçš„é‚£ä¸ªå…ˆç¼–è¯‘å†è¿è¡Œçš„ PyPy ç‰ˆæœ¬ï¼Œè¿è¡Œçš„æ–æ³¢é‚£å¥‘æ•°åˆ—çš„é€Ÿåº¦ç”šè‡³è¶…è¿‡äº†æœªä¼˜åŒ–çš„cï¼Œä¸€ç§’é’Ÿå°±ä½ å®Œæˆè¯¥è¿ç®—ï¼Œä½†åœ¨è¿™ä¸ªç‰ˆæœ¬çš„pypyä¸­æ²¡æœ‰ç¼–è¯‘çš„è¿‡ç¨‹å¹¶ä¸”ä¼¼ä¹æ²¡æœ‰äº†Daivdæåˆ°çš„ Restrict æ•°æ®ç±»å‹çš„é™åˆ¶ã€‚ Type restrict feature ä¸ºäº†è¯´æ˜ PyPy çš„ç¼ºä¹åŠ¨æ€ç±»å‹çš„æ”¯æŒï¼ŒDaivdä¸¾äº†ä»¥ä¸‹çš„ä¾‹å­ï¼š lst = [ 1 , 2 , 3 , 'Hello' ] for item in lst ï¼š print ( lst ) class A ( object ): def __int__ ( self , x , y ): self . x = x self . y = y a = A ( 1 , 2 ) b = B ( 'Hello' , 'world' ) è¿™äº›ä»£ç æ˜¯é€šä¸è¿‡å½“æ—¶ç‰ˆæœ¬ PyPy çš„ç¼–è¯‘çš„ï¼Œç„¶è€Œåœ¨ç°åœ¨ç‰ˆæœ¬ä¸­å¯ä»¥æ­£å¸¸è¿è¡Œï¼Œè¿™ç‚¹ç€å®è®©æˆ‘æƒŠè®¶ã€‚Davidæåˆ°çš„ä¸€ä¸ª PyPy çš„ç‹¬ç‰¹å¤„ç†æ–¹å¼ï¼Œå°±æ˜¯è®²çº¯pythonä»£ç å’Œrpythonä»£ç åˆ†å¼€ç¼–è¯‘ï¼Œæˆ‘æƒ³è¿™å¤§æ¦‚æ˜¯å…¶ä¸­åŸå› ã€‚ Additional Understanding RPython Low Level RPython Let's Talk About PyPy PyPy documentation","tags":"Python","title":"How to run PyPy"},{"url":"leetcode-integer-break.html","text":"Description Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4). Note: You may assume that n is not less than 2 and not larger than 58. Source link Best practice ç»è¿‡æšä¸¾å¯ä»¥å‘ç°ï¼Œè¾“å…¥å…ƒç´ æœ€ç»ˆçš„ä¸å¯åˆ†å•ä½ä¸º2å’Œ3ï¼ˆæ‰€ç»™ä¾‹å­ä¸­çš„10æœ€å°å¯è¢«åˆ†ä¸º3+3+2+2ï¼‰ã€‚ç”±æ­¤å¯è§æˆ‘ä»¬åªéœ€è¦åœ¨åªäº§ç”Ÿè¿™ä¸¤ç§ä¸å¯åˆ†å…ƒç´ çš„æƒ…å†µä¸‹å°½å¯èƒ½è´ªå©ªçš„è·å–æ›´å¤š3å°±èƒ½ä½¿è¢«breakçš„å…ƒç´ ç§¯æœ€å¤§äº†ã€‚æ›´æ·±å…¥å‘ç°ï¼Œè‹¥æ¬²ä½¿å…ƒç´ ç§¯æœ€å¤§ï¼Œåªä¼šå‡ºç°ä¸€ä¸ª2å’Œä¸¤ä¸ª2å…ƒç´ çš„æƒ…å†µï¼Œå› æ­¤æˆ‘ä»¬è®¾è®¡çš„ä»£ç å¦‚ä¸‹ã€‚ python version 1 class Solution ( object ): def integerBreak ( self , n ): \"\"\" :type n: int :rtype: int \"\"\" if n < 4 : return n - 1 if n % 3 == 0 : return 3 ** ( n // 3 ) if ( n - 2 ) % 3 == 0 : return 3 ** (( n - 2 ) // 3 ) * 2 if ( n - 4 ) % 3 == 0 : return 3 ** (( n - 4 ) // 3 ) * 2 ** 2 Mark: 32 ms è¿™æ˜¯leetcodeä¸Šçš„popçš„ç­”æ¡ˆï¼Œåè®¡ç®—æœºæ€ç»´ã€‚ç”¨æ¯”ç›®æ ‡å…ƒç´ å°çš„å…ƒç´ çš„ç”Ÿæˆç»“æœæ¥è®¡ç®—ä¹‹åçš„ç»“æœï¼Œå…¶å®å¤šäº†å¾ˆå¤šå¾ªç¯ï¼Œä½†ä¸çŸ¥é“ä¸ºä»€ä¹ˆleetcodeå£°ç§°è¿è¡Œèµ·æ¥æ›´å¿«ã€‚ python version 2 class Solution ( object ): def integerBreak ( self , n ): \"\"\" :type n: int :rtype: int \"\"\" if n < 4 : return n - 1 res = [ 0 , 1 , 2 , 3 ] for i in xrange ( 4 , n + 1 ): res [ i % 4 ] = max ( res [( i - 2 ) % 4 ] * 2 , res [( i - 3 ) % 4 ] * 3 ) return res [ n % 4 ] Mark: 28 ms Additional","tags":"Python","title":"LeetCode - Integer Break"},{"url":"python-descriptor-behavior-ii.html","text":"Description åœ¨ä¹‹å‰ä¸€ç¯‡ æ–‡ç«  ä¸­æˆ‘ä»¬è®¨è®ºäº†pythonæè¿°ç¬¦ä»¥åŠå…¶è¡Œä¸ºï¼Œä¹Ÿåšäº†ä¸€äº›æ€»ç»“ã€‚ä½†ä¸ªäººèƒ½åŠ›æœ‰é™ï¼Œå¯¹æè¿°ç¬¦è®¿é—®çš„ä¼˜å…ˆè§„åˆ™è§£é‡Šçš„ä¸æ˜¯éå¸¸æ¸…æ¥šã€‚ è¿‘æ—¥çœ‹åˆ°ä¸€ç¯‡æ–‡ç« ï¼š Pythonä¸­çš„å±æ€§è®¿é—®ä¸æè¿°ç¬¦ ä¸­å¯¹äºå±æ€§è®¿é—®ä¼˜å…ˆè§„åˆ™çš„éƒ¨åˆ†è§£é‡Šçš„å¾ˆæ¸…æ™°ï¼Œé‚è®°å½•ä¸‹æ¥å­¦ä¹ ã€‚ å±æ€§è®¿é—®çš„ä¼˜å…ˆè§„åˆ™ å±æ€§è®¿é—®çš„å…¥å£ç‚¹æ˜¯ __getattribute__ æ–¹æ³•ã€‚å®ƒçš„å®ç°ä¸­å®šä¹‰äº†Pythonä¸­å±æ€§è®¿é—®çš„ä¼˜å…ˆè§„åˆ™ã€‚Pythonå®˜æ–¹æ–‡æ¡£ä¸­å¯¹ __getattribute__ çš„åº•å±‚å®ç°æœ‰ç›¸å…³çš„ä»‹ç»ï¼Œæœ¬æ–‡æš‚æ—¶åªæ˜¯è®¨è®ºå±æ€§æŸ¥æ‰¾çš„è§„åˆ™ï¼Œç›¸å…³è§„åˆ™å¯è§ä¸‹å›¾ï¼š ä¸Šå›¾æ˜¯æŸ¥æ‰¾b.xè¿™æ ·ä¸€ä¸ªå±æ€§çš„è¿‡ç¨‹ã€‚åœ¨è¿™é‡Œè¦å¯¹æ­¤å›¾è¿›è¡Œç®€å•çš„ä»‹ç»ï¼š æŸ¥æ‰¾å±æ€§çš„ç¬¬ä¸€æ­¥æ˜¯æœç´¢åŸºç±»åˆ—è¡¨ï¼Œå³type(b). mro ï¼Œç›´åˆ°æ‰¾åˆ°è¯¥å±æ€§çš„ç¬¬ä¸€ä¸ªå®šä¹‰ï¼Œå¹¶å°†è¯¥å±æ€§çš„å€¼èµ‹å€¼ç»™ descr åˆ¤æ–­descrçš„ç±»å‹ã€‚å®ƒçš„ç±»å‹å¯åˆ†ä¸ºæ•°æ®æè¿°ç¬¦ã€éæ•°æ®æè¿°ç¬¦ã€æ™®é€šå±æ€§ã€æœªæ‰¾åˆ°ç­‰ç±»å‹ã€‚è‹¥descrä¸ºæ•°æ®æè¿°ç¬¦ï¼Œåˆ™è°ƒç”¨desc. get (b, type(b))ï¼Œå¹¶å°†ç»“æœè¿”å›ï¼Œç»“æŸæ‰§è¡Œã€‚å¦åˆ™è¿›è¡Œä¸‹ä¸€æ­¥ å¦‚æœ descr ä¸ºéæ•°æ®æè¿°ç¬¦ã€æ™®é€šå±æ€§ã€æœªæ‰¾åˆ°ç­‰ç±»å‹ï¼Œåˆ™æŸ¥æ‰¾å®ä¾‹bçš„å®ä¾‹å±æ€§ï¼Œå³b. dict ã€‚å¦‚æœæ‰¾åˆ°ï¼Œåˆ™å°†ç»“æœè¿”å›ï¼Œç»“æŸæ‰§è¡Œã€‚å¦åˆ™è¿›è¡Œä¸‹ä¸€æ­¥ï¼› å¦‚æœåœ¨b. dict æœªæ‰¾åˆ°ç›¸å…³å±æ€§ï¼Œåˆ™é‡æ–°å›åˆ° descr å€¼çš„åˆ¤æ–­ä¸Šã€‚ è‹¥ descr ä¸ºéæ•°æ®æè¿°ç¬¦ï¼Œåˆ™è°ƒç”¨desc. get (b, type(b))ï¼Œå¹¶å°†ç»“æœè¿”å›ï¼Œç»“æŸæ‰§è¡Œ è‹¥ descr ä¸ºæ™®é€šå±æ€§ï¼Œç›´æ¥è¿”å›ç»“æœå¹¶ç»“æŸæ‰§è¡Œï¼› è‹¥ descr ä¸ºç©ºï¼ˆæœªæ‰¾åˆ°ï¼‰ï¼Œåˆ™æœ€ç»ˆæŠ›å‡º AttributeError å¼‚å¸¸ï¼Œç»“æŸæŸ¥æ‰¾ã€‚ Additional","tags":"Python","title":"Python Descriptor Behavior II"},{"url":"leetcode-maximum-xor-of-two-numbers-in-an-array.html","text":"Description Given a non-empty array of numbers, $$ a_0, a_1, a_2, â€¦ , a_{n-1}, where 0 â‰¤ a_i < 2&#94;{31} $$ . Find the maximum result of a_i XOR a_j, where 0 â‰¤ i, j < n . Could you do this in O(n) runtime? Example: Input : [ 3 , 10 , 5 , 25 , 2 , 8 ] Output : 28 Explanation : The maximum result is 5 &#94; 25 = 28 . Source link Best practice æˆ‘ä»¬ä»å·¦è‡³å³å¯¹æ¯ä¸€ä½è¿›è¡Œåˆ¤æ–­ï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­é€æ¸ç¼©å°è¢«æˆ‘ä»¬é€‰ä¸­çš„å…ƒç´ èŒƒå›´ã€‚å‡è®¾è¾“å…¥åˆ—è¡¨åŒ…å«26ä¸ªæ•´æ•°ï¼ˆåœ¨è¿™é‡Œæˆ‘ä»¬ä»¥a,b,c,dè‡³zæ¥è¡¨ç¤ºï¼‰ã€‚å‘å³éå†æ—¶ï¼Œå½“æŸå‡ ä¸ªæ•°a,d,e,h,uåœ¨æœ€å¤§äºŒè¿›åˆ¶ä½ä¸Šä¸åŒæ—¶ï¼Œå°±å¯ä»¥ç¡®å®šè¯¥ä½ä¸ºæˆ‘ä»¬æœ€ç»ˆç­”æ¡ˆçš„æœ€å¤§äºŒè¿›åˆ¶ä½äº†ã€‚å› ä¸ºè¯¥ä½ä¸º1çš„æƒ…å†µå¤§äºè¯¥ä½å³ä¾§æ‰€æœ‰ä½ä¸º1çš„æƒ…å†µã€‚åœ¨ä¸‹æ¬¡éå†æ—¶æˆ‘ä»¬å°±å¯ä»¥æ£€æŸ¥è¿™å‡ ä¸ªæ•°ä¸­çš„æ¬¡å¤§äºŒè¿›åˆ¶ä½æ˜¯å¦ä¸åŒï¼Œä¹Ÿå°±å¯ä»¥ç¡®å®šæ¬¡å¤§äºŒè¿›åˆ¶ä½çš„å€¼ï¼Œæˆ‘ä»¬çš„å€™é€‰ç»„ä¹Ÿä¼šä»a,d,e,h,uç¼©å°è‡³a,e,hçš„æƒ…å†µã€‚è¿™ä¸ªé—®é¢˜çš„ç‰¹æ€§æ˜¯ï¼Œæ¯æ¬¡æˆ‘ä»¬ç¼©å°å€™é€‰å…ƒç´ èŒƒå›´æ—¶ï¼Œæˆ‘ä»¬ä¸éœ€è¦å…³å¿ƒå“ªäº›å…ƒç´ ç•™ä¸‹æ¥äº†ï¼Œåªéœ€è¦çŸ¥é“æˆ‘ä»¬çš„æœ€ç»ˆç­”æ¡ˆæ˜¯å¤šå°‘ã€‚ python version class Solution ( object ): def findMaximumXOR ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" max , mask = 0 , 0 for i in reversed ( range ( 32 )): mask = mask | ( 1 << i ) #prefix set prefixes = { num & mask for num in nums } temp = max | ( 1 << i ) for prefix in prefixes : # å› ä¸º1&#94;0=1,1&#94;1=0,0&#94;0=0,æ‰€ä»¥å½“a&#94;b=cæ—¶ï¼Œa&#94;c=b # item1&#94;item2=temp,item1&#94;temp=item2 if prefix &#94; temp in prefixes : max = temp break return max Mark: 129 ms Additional","tags":"Python","title":"LeetCode - Maximum XOR of Two Numbers in an Array"},{"url":"leetcode-total-hamming-distance.html","text":"Description The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers. Example: Input : 4 , 14 , 2 Output : 6 Explanation : In binary representation , the 4 is 0100 , 14 is 1110 , and 2 is 0010 ( just showing the four bits relevant in this case ). So the answer will be : HammingDistance ( 4 , 14 ) + HammingDistance ( 4 , 2 ) + HammingDistance ( 14 , 2 ) = 2 + 2 + 2 = 6 . Note: 1. Elements of the given array are in the range of 0 to 10&#94;9 2. Length of the array will not exceed 10&#94;4 . Source link Best practice ç»è¿‡è§‚å¯Ÿå¯ä»¥å‘ç°ï¼Œæ‰€æœ‰åˆ—è¡¨ä¸­å…ƒç´ çš„æ±‰æ˜è·ç¦»ä¹Ÿå¯ä»¥ç”¨ä»–ä»¬å„ä¸ªä½ä¸­çš„0å’Œ1çš„åˆ†å¸ƒæƒ…å†µæ¥å¾—å‡ºã€‚ä¾‹å¦‚å…±æœ‰å…«ä¸ªå…ƒç´ ï¼Œæ‰€æœ‰å…ƒç´ çš„2&#94;0ä½æœ‰ä¸‰ä¸ª1äº”ä¸ª0ï¼Œåˆ™è¯¥ä½å¯¹æ•´ä½“æ±‰æ˜è·ç¦»çš„è´¡çŒ®ä¸º3 5ã€‚æœ¬é¢˜ä¸­æ‰€æè¿°çš„total hamming distanceå¯ä»¥ç”±æ‰€æœ‰ä½äº§ç”Ÿçš„æ±‰æ˜è·ç¦»çš„å’Œè¡¨ç¤ºã€‚è¿™æ ·çš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä½O(n m),mä¸ºå…ƒç´ äºŒè¿›åˆ¶ä½å¹³å‡é•¿åº¦ã€‚ python version from collections import defaultdict class Solution ( object ): def totalHammingDistance ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" result = 0 for i in range ( 32 ): count = 0 # åˆ—è¡¨ä¸­æ‰€æœ‰å…ƒç´ ç¬¬iä½ä¸­çš„1çš„æ•°é‡ bit = ( 1 << i ) # å‚ç…§äºŒè¿›åˆ¶æ•° for item in nums : if item & bit : count += 1 result += count * ( len ( nums ) - count ) return result Mark: 268 ms Additional","tags":"Python","title":"LeetCode - Total Hamming Distance"},{"url":"leetcode-maximum-length-of-pair-chain.html","text":"Description You are given n pairs of numbers. In every pair, the first number is always smaller than the second number. Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c . Chain of pairs can be formed in this fashion. Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order. Example 1: Input: [[1,2], [2,3], [3,4]] Output: 2 Explanation: The longest chain is [1,2] -> [3,4] Note: 1. The number of given pairs will be in the range [1, 1000]. Source link Best practice æœ¬é¢˜çš„å…³é”®åœ¨äºå‡å°‘æ—¶é—´å¤æ‚åº¦ã€‚å°è¯•äº†æ’åºåå‘ç°ï¼Œå°†åˆ—è¡¨å…ƒç»„æŒ‰ç¬¬äºŒä¸ªå…ƒç´ æ’åºæ˜¯ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸ºoï¼ˆnï¼‰çš„è§£å†³æ–¹æ¡ˆã€‚ä¸¾ä¾‹æ¥è¯´ï¼Œ[5,6]å‰æ‰€èƒ½æ¥çš„å…ƒç´ é“¾é•¿åº¦æ€»å¤§äºç­‰äº[4,6]ï¼Œå› æ­¤æŒ‰æ­¤æ’åºåä»ç¬¬ä¸€ä¸ªå…ƒç´ å¼€å§‹éå†ç­›é€‰å°±å¯ä»¥äº†ã€‚è¿™é‡Œæˆ‘ä»¬æ²¡æœ‰åœ¨é‡åˆ°æ‹¥æœ‰ç›¸åŒç¬¬äºŒä¸ªå…ƒç´ çš„å…ƒç»„æ—¶ä½¿ç”¨å–æœ€å¤§å€¼çš„æ–¹æ³•ï¼Œå› ä¸ºæ™®é€šçš„é¡ºåºéå†å°±èƒ½å¾—åˆ°oï¼ˆnï¼‰å¤æ‚åº¦çš„ç®—æ³•äº†ã€‚ python version from operator import itemgetter class Solution ( object ): def findLongestChain ( self , pairs ): \"\"\" :type pairs: List[List[int]] :rtype: int \"\"\" last , n = None , 0 for item in sorted ( pairs , key = itemgetter ( 1 )): if last is None : last , n = item , 1 elif item [ 0 ] > last [ 1 ]: last , n = item , n + 1 return n Mark: 75 ms Additional","tags":"Python","title":"LeetCode - Maximum Length of Pair Chain"},{"url":"yi-ge-jian-dan-de-wen-ben-jie-xi-ji-suan-qi.html","text":"Description ä¹‹å‰åœ¨ã€Špython cookbookã€‹ä¸Š8.22èŠ‚çœ‹åˆ°äº†ç”¨éé€’å½’çš„æ–¹å¼å®ç°è®¿é—®è€…æ¨¡å¼çš„ æ–¹æ³• ï¼Œé€šè¿‡å·§å¦™åœ°ä½¿ç”¨ç”Ÿæˆå™¨çš„æ–¹å¼åœ¨æ ‘éå†æˆ–è€…æœç´¢ç®—æ³•ä¸­ä¸­æ¶ˆé™¤é€’å½’ã€‚ä»è€Œé¿å…äº†åœ¨ä½¿ç”¨è®¿é—®è€…æ¨¡å¼éå†æ·±å±‚åµŒå¥—æ ‘å½¢æ•°æ®ç»“æ„æ—¶ï¼Œå› ä¸ºè¶…è¿‡åµŒå¥—å±‚çº§é™åˆ¶è€Œå¤±è´¥çš„æƒ…å†µã€‚ åŸæ–‡æ˜¯David DabeazåŸºäºpython3.3ç‰ˆæœ¬æ„å»ºçš„ï¼Œå¾ˆä¸å‡‘å·§çš„æ˜¯ï¼Œåœ¨python3.4ç‰ˆæœ¬åˆæ¨å‡ºäº†ä¸€ä¸ªéå¸¸å¼ºå¤§çš„åç¨‹å’Œç”Ÿæˆå™¨çš„æ–°ç‰¹æ€§ï¼š yield from ï¼Œè¿™æ— ç–‘ä¸ºæˆ‘ä»¬å¢æ·»äº†æ–°çš„ç©å…·ã€‚ 2014å¹´ï¼ŒDabeazçš„ Final generator è®²åº§å…¨é¢åœ°ä»‹ç»äº†è®¸å¤šåç¨‹ç¼–å†™çš„è¯€çªå¹¶ä¸”ç‚¸æ¯äº†è®¸å¤šå¬ä¼—çš„å¤§è„‘ï¼ˆåŒ…æ‹¬ç¬”è€…çš„ï¼‰ï¼Œåœ¨è¯¾ç¨‹çš„æœ€åä¸€éƒ¨åˆ†ä»–åˆä»å¤´ç”¨åç¨‹ä»£æ›¿äº†ç»å…¸çš„è®¿é—®è€…æ¨¡å¼ï¼Œç”¨äºè®¡ç®—ç®—æœ¯è¡¨è¾¾å¼ã€‚å—ä»–çš„è¯¾ç¨‹çš„å¼•å¯¼å’Œå¯å‘ä¾¿æœ‰äº†æœ¬æ–‡ã€‚ ä»£ç å®ç° æˆ‘ä»¬å¸Œæœ›å®ç°çš„è®¡ç®—å™¨èƒ½å¤Ÿè¿™æ ·ä½¿ç”¨ï¼š cal = Calculator () cal . caculate ( '1+2*4-5&#94;2' ) >>> - 16 ä»é€»è¾‘ä¸Šæ¥è¯´ï¼Œè¿™ä¸ªæ–‡æœ¬è®¡ç®—å™¨ä¼šä¸ºæˆ‘ä»¬åˆ†ä¸‰æ­¥åšäº‹æƒ…ï¼š è§£æä¼ å…¥æ–‡æœ¬ï¼Œå°†æ–‡æœ¬è½¬æ¢æˆå¯è¯†åˆ«å•å…ƒã€‚å¾ˆå®¹æ˜“æƒ³åˆ°çš„æ˜¯ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ¥è§£ææ–‡æœ¬ã€‚ ç¡®å®šè¿ç®—çš„å…ˆåé¡ºåºï¼Œå¦‚ä¹˜é™¤ä¼˜å…ˆäºåŠ å‡ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬å°†è¯†åˆ«å¥½çš„å•å…ƒæ„é€ æˆæ ‘æ¥ä½“ç°è¿ç®—çš„ä¼˜å…ˆçº§ã€‚ æ·±åº¦éå†ç”Ÿæˆæ ‘ï¼Œè®¡ç®—å¹¶è¾“å‡ºç»“æœã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬å°±æ¥ä¸€æ­¥ä¸€æ­¥å®ç°è¿™ä¸€ç®€æ˜“ç¼–è¯‘å™¨ã€‚ å‡†å¤‡å·¥ä½œ æœ¬æ–‡ä»£ç ç¯å¢ƒä¸ºpython3.6ã€‚ é¦–å…ˆå®šä¹‰å¥½æ­¤æ¬¡æ‰€éœ€çš„æ•°æ®ç»“æ„ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬åˆ©ç”¨äº†Davidåœ¨ Python 3 Metaprogramming ä¸­æ‰€æè¿°çš„å…ƒç¼–ç¨‹çš„æ–¹å¼æ¥æ‰¹é‡åœ°æ„é€ ç®€å•ç»“æ„ç±»å‹ã€‚è¿™é‡Œæˆ‘ä»¬å¯¹ä»–çš„ä»£ç ç¨ä½œæ”¹è¿›ï¼Œä½¿å…¶æ”¯æŒé»˜è®¤å‚æ•°åŠå‚æ•°æ³¨é‡Šã€‚è¿™ä¹Ÿç®—æˆ‘ä»¬å¯¹å…ƒç¼–ç¨‹çš„ä¸€ä¸ªå°å°å®è·µï¼Œè¯»è€…ä¸éœ€è¦ç†è§£è¿™éƒ¨åˆ†çš„å†…å®¹å°±å¯ä»¥å®Œæˆä½™ä¸‹çš„é˜…è¯»ã€‚ è¿™é‡Œä¹Ÿç”¨åˆ°äº†python3çš„æ–°ç‰¹æ€§ï¼Œ inpect æ¨¡å—çš„signatureéƒ¨åˆ†ï¼Œå…·ä½“å¯å‚è§ å®˜æ–¹æ–‡æ¡£ ã€‚ å®šä¹‰æ•°æ®ç»“æ„çš„ä»£ç å¦‚ä¸‹ï¼š import re import types from collections import namedtuple from functools import singledispatch from inspect import Parameter , Signature def make_signature ( names ): \"\"\"ç”¨ä¸€ä¸ªåˆ—è¡¨æ¥äº§ç”Ÿå‚æ•°ç­¾åçš„æ¨¡å—å‡½æ•°,ä¹Ÿå¯ä»¥æ”¾åœ¨StructureMetaå†…éƒ¨\"\"\" parameters = [] #æŠ“å‡ºå‚æ•°çš„åç§°ã€é»˜è®¤å€¼å’Œæ³¨é‡Š parameter_re = re . compile ( r '&#94;(?P<name>\\w+)(\\s*=\\s*(?P<default>\\w+))?(\\s*:\\s*(?P<annotation>\\w+))?$' ) for name in names : re_result = parameter_re . match ( name ) if not re_result : raise SyntaxError ( 'Invalid parameter syntaxï¼š {} ' . format ( name )) parameters . append ( Parameter ( kind = Parameter . POSITIONAL_OR_KEYWORD , ** re_result . groupdict ())) #æ”¯æŒå‚æ•°é»˜è®¤å€¼å’Œæ³¨é‡Š return Signature ( parameters ) class StructureMeta ( type ): \"\"\" Structureç±»çš„å…ƒç±»ï¼Œåœ¨ç”Ÿæˆclassçš„æ—¶å€™å°†_fieldsé‡Œæä¾›çš„å±æ€§è½¬åŒ–ä¸º å‚æ•°ç­¾åç±»å±æ€§ã€‚ \"\"\" def __new__ ( cls , name , bases , clsdict ): clsobj = super () . __new__ ( cls , name , bases , clsdict ) sig = make_signature ( clsobj . _fields ) setattr ( clsobj , '__signature__' , sig ) return clsobj class Structure ( metaclass = StructureMeta ): \"\"\"ç®€æ˜“æ•°æ®ç»“æ„æ„é€ çˆ¶ç±»\"\"\" _fields = [] def __init__ ( self , * args , ** kwargs ): # è¿™é‡Œå®é™…ä¸Šå–çš„æ˜¯self.__class___.__signature__ bound = self . __signature__ . bind ( * args , ** kwargs ) for name , val in bound . arguments . items (): setattr ( self , name , val ) class Number ( Structure ): \"\"\"æ•°å­—å‹\"\"\" _fields = [ 'value' ] class BinOp ( Structure ): \"\"\"æ“ä½œç¬¦å·å‹\"\"\" _fields = [ 'op' , 'left' , 'right' ] å…¶æ¬¡åˆ™æ˜¯è¦ä½¿ç”¨çš„Calculatorçš„åŸºæœ¬æ¡†æ¶ï¼Œä¸‰ä¸ªå…³é”®æ­¥éª¤çš„å‡½æ•°è®²åœ¨ä½™ä¸‹èŠ‚å†…å®¹ä¸€ä¸€å®ç°ï¼š class Calculator : # å¯ä»¥è¢«tokenizeå‡½æ•°è§£æçš„å­—ç¬¦ TOKENS = [ r '(?P<NUM>\\d+)' , r '(?P<PLUS>\\+)' , r '(?P<MINUS>-)' , r '(?P<TIMES>\\*)' , r '(?P<DIVIDE>/)' , r '(?P<POWER>\\&#94;)' , r '(?P<WS>\\s+)' , ] # å‚¨å­˜å­—ç¬¦ç±»å‹å’Œå€¼çš„å…ƒç»„ Token = namedtuple ( 'Token' , [ 'type' , 'value' ]) def __init__ ( self , token = None ): if token : self . TOKENS = token # é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼ self . MASTER_RE = re . compile ( '|' . join ( self . TOKENS )) def caculate ( self , text ): \"\"\"è§£æå¹¶è®¡ç®—è¡¨è¾¾å¼\"\"\" self . text = text try : token = self . _tokenize ( text ) tree = self . _parse ( token ) result = self . _evaluate ( tree ) except Exception as e : raise e return result def _tokenize ( self , text ): \"\"\"ä»å­—ç¬¦ä¸²å¼€å§‹æ‰«ææ‰€æœ‰åŒ¹é…å­—ç¬¦,è¾“å‡ºæ‰€æœ‰éç©ºå…ƒç´ \"\"\" pass def _parse ( self , toks ): \"\"\"å°†tokenizeåçš„å…ƒç´ parseæˆæ ‘ç»“æ„\"\"\" pass def _evaluate ( self , node ): \"\"\"éå†ç”Ÿæˆæ ‘è®¡ç®—ç»“æœ\"\"\" pass å¯¹äºæ•°æ®ç»“æ„ç±»æˆ‘ä»¬ä½¿ç”¨äº†ä¸€ç§ç®€å•ç²—æš´çš„æ„é€ æ–¹æ³•ï¼šç›´æ¥è®¾ç½®æˆç±»çš„å±æ€§ã€‚å…¶å®è¿™ä¹Ÿæ˜¯ä¸€ç§è›®å¸¸ç”¨çš„æ–¹æ³•ï¼Œé€‚åˆæ„é€ å¤§é‡ç®€å•æ•°æ®ç»“æ„ç±»ã€‚ å¯¹äºè®¡ç®—å™¨ç±»ï¼Œæˆ‘ä»¬å¼€æ”¾äº†caculate apiæ¥å—ä¼ å…¥çš„å­—ç¬¦ä¸²ï¼Œå¹¶ç»è¿‡ä¸Šæ–‡è®ºè¿°çš„ä¸‰ä¸ªæ­¥éª¤æ¥è¾“å‡ºç»“æœã€‚å½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥ç›´æ¥è°ƒç”¨è¿™ä¸‰ä¸ªæ­¥éª¤çš„æ–¹æ³•æ¥è¿›è¡Œè°ƒè¯•å’Œç»´æŠ¤ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥çš„ä»»åŠ¡å°±æ˜¯åˆ†åˆ«å®ç°è¿™ä¸‰ä¸ªæ–¹æ³•ã€‚ Tokenize def _tokenize ( self , text ): \"\"\"ä»å­—ç¬¦ä¸²å¼€å§‹æ‰«ææ‰€æœ‰åŒ¹é…å­—ç¬¦,è¾“å‡ºæ‰€æœ‰éç©ºå…ƒç´ \"\"\" try : scan = self . MASTER_RE . scanner ( text ) except Exception as e : raise e return ( self . Token ( m . lastgroup , m . group ()) for m in iter ( scan . match , None ) if m . lastgroup != 'WS' ) Tokenize æ–¹æ³•æ ¹æ®ç±»å˜é‡ TOKENS é‡Œçš„æ­£åˆ™è¡¨è¾¾å¼æ•è·åŒ¹é…å­—ç¬¦ç»„å¹¶ä¸”å°†å®ƒä»¬å‘½åï¼Œä¹‹åè¿”å›æ‰€æœ‰éç©ºæ ¼çš„å­—ç¬¦å…ƒç´ ã€‚ è¿™é‡Œå€¼å¾—ä¸€æçš„æ˜¯ re æ¨¡å—çš„ scanner æ–¹æ³•ã€‚ä¸çŸ¥é“æ˜¯ä¸æ˜¯åˆ»æ„è€Œä¸ºä¹‹ï¼Œå®ƒæ²¡æœ‰ä»»ä½•å®˜æ–¹çš„æ–‡æ¡£ã€‚åœ¨æˆ‘ä»¬è¿™ä¸ªç®€å•ç¼–è¯‘å™¨çš„æƒ…æ™¯ä¸‹ï¼Œå®ƒé€ä¸ªæ‰«æä¼ å…¥å­—ç¬¦ä¸²é‡Œçš„æ‰€æœ‰ç¬¦åˆæ­£åˆ™è¡¨è¾¾å¼çš„å…ƒç´ å¹¶è¾“å‡ºã€‚ å¯¹äº 1+2*4-5&#94;2 æˆ‘ä»¬å°†ç”Ÿæˆè¿™äº›å…ƒç´ ï¼š cal = Calculator () cal . text = '1+2*4-5&#94;2' for item in cal . _tokenize ( cal . text ): print ( item ) >>> Token ( type = 'NUM' , value = '1' ) Token ( type = 'PLUS' , value = '+' ) Token ( type = 'NUM' , value = '2' ) Token ( type = 'TIMES' , value = '*' ) Token ( type = 'NUM' , value = '4' ) Token ( type = 'MINUS' , value = '-' ) Token ( type = 'NUM' , value = '5' ) Token ( type = 'POWER' , value = '&#94;' ) Token ( type = 'NUM' , value = '2' ) Parse def _parse ( self , toks ): \"\"\"å°†tokenizeåçš„å…ƒç´ parseæˆæ ‘ç»“æ„\"\"\" lookahead , current = next ( toks , None ), None def accept ( * toktypes ): \"\"\"åˆ¤æ–­ç”Ÿæˆå™¨toksçš„ä¸‹ä¸ªå…ƒç´ æ˜¯å¦ä¸ºä¼ å…¥ç±»å‹\"\"\" nonlocal lookahead , current if lookahead and lookahead . type in toktypes : current , lookahead = lookahead , next ( toks , None ) return True # è¡¨è¾¾å¼ç»“æ„ï¼š # expr ::= term { +|- term }* # term ::= pow { *|/ pow}* # pow ::= factor { &#94; factor}* # factor ::= NUM def expr (): left = term () while accept ( 'PLUS' , 'MINUS' ): left = BinOp ( current . value , left ) left . right = term () return left def term (): left = pow () while accept ( 'TIMES' , 'DIVIDE' ): left = BinOp ( current . value , left ) left . right = pow () return left def pow (): left = factor () while accept ( 'POWER' ): left = BinOp ( current . value , left ) left . right = factor () return left def factor (): if accept ( 'NUM' ): return Number ( int ( current . value )) else : raise SyntaxError () return expr () Parse æ–¹æ³•é€šè¿‡ accept å‡½æ•°æ¥éå† tokenize è¿”å›çš„å­—ç¬¦å…ƒç´ è¿­ä»£å™¨ï¼Œå¹¶é€šè¿‡æ ‘çŠ¶çš„å‡½æ•°ç»“æ„æ¥ç”Ÿæˆä¸€æ£µçœŸæ­£çš„æ ‘ã€‚éå¸¸æ¬£èµå®ƒçš„æ¨¡ä»¿èƒ½åŠ›ã€‚ å®ƒå°†è¡¨è¾¾å¼åœ¨è¯­æ„ä¸Šåˆ†ä¸ºä¸‰ç§ç±»å‹ï¼štermï¼Œpowï¼Œfactor (å®é™…ä¸Šè¿™äº›åå­—æ²¡ä»€ä¹ˆç‰¹åˆ«çš„æ„æ„ä¹‰)ã€‚ä¾‹å¦‚ 1+2*4-5&#94;2 è¿™ä¸ªè¡¨è¾¾å¼ï¼Œfactorä¸ºæœ€å°å•å…ƒå³æ•°å­—ï¼Œfactorç»„æˆpowå³ 1 2 4 5&#94;2 ä¸ºæ¬¡å°å•å…ƒï¼Œpowç»„æˆterm 1 2*4 5&#94;2 ,termç»„æˆè¡¨è¾¾å¼æ¥ä½“ç°è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ã€‚ å¯¹äº 1+2*4-5&#94;2 æˆ‘ä»¬å¯ä»¥è¿™æ ·ç”Ÿæˆæ ‘ï¼š cal = Calculator () cal . text = '1+2*4-5&#94;2' print ( cal . _parse ( cal . _tokenize ( cal . text ))) Evaluate def _evaluate ( self , node ): \"\"\"éå†ç”Ÿæˆæ ‘è®¡ç®—ç»“æœ\"\"\" @singledispatch def visit ( obj ): raise NotImplemented @visit . register ( BinOp ) def _ ( node ): \"\"\" åç¨‹ã€‚ visit method for BinOp \"\"\" left = yield node . left right = yield node . right # TODO: could be more dynamic switch = { '+' : lambda x , y : x + y , '-' : lambda x , y : x - y , '*' : lambda x , y : x * y , '/' : lambda x , y : x / y , '&#94;' : lambda x , y : x ** y , } try : return switch . get ( node . op , None )( left , right ) # äº§ç”ŸStopIterationå¹¶è¿”å›ç»“æœ except TypeError as e : pass @visit . register ( Number ) def _ ( node ): \"\"\"visit method for number\"\"\" return node . value def gen_visit ( node ): \"\"\" å§”æ´¾ç”Ÿæˆå™¨ã€‚ è¿”å›è¾“å…¥æ•°å€¼åŠä¸­é—´å€¼ã€‚ \"\"\" result = visit ( node ) return ( yield from result ) if isinstance ( result , types . GeneratorType ) else result stack = [ gen_visit ( node )] # å°†æ ¹èŠ‚ç‚¹çš„åç¨‹æ”¾å…¥æ ˆ result = None while stack : try : node = stack [ - 1 ] . send ( result ) # send(None)é¢„æ¿€åç¨‹ï¼Œsendï¼ˆresultï¼‰å°†è®¡ç®—å¥½çš„å€¼å­˜å…¥åç¨‹ stack . append ( gen_visit ( node )) # æ·±åº¦éå†æ·»åŠ åç¨‹ï¼Œç­‰å¾…å¤„ç† result = None except StopIteration as e : stack . pop () result = e . value # å–å¾—numberçš„å€¼æˆ–è¡¨è¾¾å¼è®¡ç®—å€¼ return result Evalute å‡½æ•°éå† parse æ‰€ç”Ÿæˆçš„æ ‘å¹¶è®¡ç®—ç»“æœã€‚åœ¨è¿™é‡Œæˆ‘ä»¬ç”¨3.4æ–°åŠ å…¥çš„ singledispatch æ¥æ›¿ä»£åŸå…ˆDabeazä½¿ç”¨çš„æ–¹å¼ï¼š methname = 'visit_' + type ( node ) . __name__ meth = getattr ( self , methname , None ) æ¯”è¾ƒå®¹æ˜“è®©äººç‚¸è„‘çš„æ˜¯ç”¨listæ¥ç®¡ç†æ ˆçš„è¿‡ç¨‹ã€‚ä»¥ 1+2*4-5 è¿™ä¸ªè¡¨è¾¾å¼ä¸¾ä¾‹ï¼Œä¼ å…¥ evaluate æ–¹æ³•çš„ç”Ÿæˆæ ‘æ˜¯è¿™æ ·çš„ã€‚ ç¬¬ä¸€å±‚: BinOp \"-\" Number ç¬¬äºŒå±‚ï¼š Number \"+\" BinOp 5 ç¬¬ä¸‰å±‚ï¼š 1 Number \"*\" Number ç¬¬å››å±‚ï¼š 2 4 å¦‚æœä½ å‘ç°è‡ªå·±æ— æ³•ç†è§£æˆ‘çš„ç»˜ç”»ä½œå“çš„è¯ä¸å¦¨è·‘ä¸‹ parse æ–¹æ³•ã€‚ æˆ‘ä»¬å…ˆå°†åˆå§‹åŒ–æ ¹èŠ‚ç‚¹çš„å§”æ´¾ç”Ÿæˆå™¨å…¥æ ˆï¼Œè®°è¯¥å§”æ´¾ç”Ÿæˆå™¨ gen_visit ä¸º A ï¼Œä¼ å…¥Noneé¢„æ¿€ A , visit(BinOp('-',x,y)) è¿”å›åç¨‹ a ï¼Œç”±äºè¯¥åç¨‹ä¸ºç”Ÿæˆå™¨å­ç±»ï¼Œè¿›å…¥ return è¯­å¥ä¸­çš„ yield from result å­å¥ä»£ç†çš„åç¨‹ a ï¼Œ yield å‡º BinOp('-',x,y) çš„å·¦èŠ‚ç‚¹ BinOp('+',x,y) ã€‚å°†å…¶ä¼ å…¥å§”æ´¾ç”Ÿæˆå™¨ B å¹¶å…¥æ ˆã€‚æ­¤æ—¶åç¨‹ a èµ°è‡³ left = yield node.left è¯­å¥çš„ç­‰å·å³è¾¹ã€‚ ä¼ å…¥Noneé¢„æ¿€å§”æ´¾ç”Ÿæˆå™¨ B , visit(BinOp('+',x,y)) è¿”å›åç¨‹ b ï¼Œè¿›å…¥ yield from result ä»£ç†çš„åç¨‹ b ä¸­ yield å‡º BinOp('+',x,y) çš„å·¦èŠ‚ç‚¹ Number(1) ã€‚å°†å…¶ä¼ å…¥å§”æ´¾ç”Ÿæˆå™¨ C å¹¶å…¥æ ˆã€‚æ­¤æ—¶åç¨‹ b èµ°è‡³ left = yield node.left è¯­å¥çš„ç­‰å·å³è¾¹ã€‚ ä¼ å…¥Noneé¢„æ¿€å§”æ´¾ç”Ÿæˆå™¨ C , visit(Number(1)) è¿”å›æ•´å½¢ 1 ï¼Œ æ­¤æ—¶ return å°†è¿”å› result ï¼ŒæŠ›å‡º StopIteration å¼‚å¸¸ã€‚æˆ‘ä»¬æ•è·å¼‚å¸¸è·å¾— result çš„å€¼ 1 å¹¶å°† C å‡ºæ ˆã€‚ å°† 1 ä¼ å…¥å§”æ´¾ç”Ÿæˆå™¨ B ä»£ç†çš„åç¨‹ b ï¼Œæ­¤æ—¶ left = yield node.left ä¸­å˜é‡ left è·å¾—ä¼ å…¥å€¼å¹¶ç»§ç»­ yield å‡ºå³èŠ‚ç‚¹ BinOp('*',x,y) ä¸­é—´é‡å¤è¿‡ç¨‹ä¸å†ç´¯è¿°ï¼Œå½“åç¨‹èµ°è‡³ return switch.get(node.op, None)(left, right) åˆ™ä¼šæŠ›å‡º StopIteration å¼‚å¸¸å’Œè¯¥è¡¨è¾¾å¼çš„è¿ç®—ç»“æœï¼Œä»¥æ­¤å±‚å±‚å›æº¯å¾—åˆ°æœ€ç»ˆçš„ç»“æœã€‚ æ€»ç»“ è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆå¯¹ Calculator ç±»çš„ç¼–å†™ã€‚ å…¶å®æˆ‘ä»¬å®Œå…¨å¯ä»¥ç”¨pythonè‡ªå¸¦çš„ eval æ–¹æ³•æ¥æ‰§è¡Œä»»æ„å­—ç¬¦ä¸²ä»£ç ã€‚ä½†ä¹‹æ‰€ä»¥æˆ‘ä»¬è¦å¤§è´¹å‘¨ç« åœ°ç”¨åç¨‹å®ç°è¿™ä¸€æ–‡æœ¬è®¡ç®—å™¨ï¼Œæ˜¯ä¸ºäº†åœ¨pythonä¸­å®è·µ stackless çš„æ€æƒ³ã€‚ æ¯”å¦‚è¦è®¡ç®— cal.caculate('+'.join(str(i) for i in range(2017))) ,æˆ‘ä»¬çš„ parse å‡½æ•°ä¼šç”Ÿæˆä¸€æ£µè¶…è¿‡ä¸¤åƒæ·±åº¦çš„æ ‘ï¼Œè¿™æ—¶å€™å°±æ— æ³•ç”¨é€’å½’çš„æ–¹å¼æ¥éå†æ ‘äº†ã€‚ å¦å¤–ï¼Œå¦‚cookbooké‡Œè¯´çš„ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ç”¨å¦ä¸€ç§æ²¡æœ‰ yield è¯­å¥çš„æ–¹æ¡ˆï¼Œæˆ‘ä»¬ä¸å¾—ä¸å¤„ç†å¾ˆå¤šæ£˜æ‰‹çš„é—®é¢˜ã€‚ä¾‹å¦‚ï¼Œä¸ºäº†æ¶ˆé™¤é€’å½’ï¼Œæˆ‘ä»¬å¿…é¡»è¦ç»´æŠ¤ä¸€ä¸ªæ ˆç»“æ„ã€‚å¦‚æœä¸ä½¿ç”¨ç”Ÿæˆå™¨ï¼Œä»£ç å°±ä¼šå˜å¾—å¾ˆè‡ƒè‚¿ï¼Œåˆ°å¤„éƒ½æ˜¯æ ˆæ“ä½œè¯­å¥ã€ä¼šæ‰å‡½æ•°ç­‰ã€‚å› æ­¤ä½¿ç”¨ yield å¯ä»¥è®©ä½ å†™å‡ºéå¸¸æ¼‚æµçš„ä»£ç ï¼Œå®ƒæ¶ˆé™¤äº†é€’å½’ä½†çœ‹ä¸Šå»åˆå¾ˆåƒæ˜¯é€’å½’å®ç°ï¼Œä»£ç å¾ˆç®€æ´ã€‚ Additional ä»£ç æºæ–‡ä»¶: 1. text_calculator.py","tags":"Python","title":"ä¸€ä¸ªç®€å•çš„æ–‡æœ¬è§£æè®¡ç®—å™¨"},{"url":"pythonzhuang-shi-qi-de-zheng-que-da-kai-fang-shi-2.html","text":"Description è£…é¥°å™¨æ˜¯pythonè¯­è¨€çš„ä¸€ä¸ªéå¸¸å¸¸ç”¨åŠpythonicçš„ç‰¹æ€§ï¼Œä½†å¾€å¾€ç”±äºå¿½è§†pythonä¸­çš„å†…çœï¼Œæˆ‘ä»¬ä¼šå†™å‡ºä¸€äº›ä¸æ˜¯ç‰¹åˆ«å®Œç¾çš„è‡ªå®šä¹‰è£…é¥°å™¨ã€‚Graham Dumpletonå†™äº†ä¸€ç³»åˆ— åšå®¢ ï¼Œæ·±å…¥å‰–æäº†å¦‚ä½•å®ç°è¡Œä¸ºè‰¯å¥½çš„è£…é¥°å™¨ã€‚æ­¤å¤–ä»–è¿˜æ˜¯ wraptæ¨¡å— çš„ä½œè€…,ä»–å°†ä»–å¯¹è£…é¥°å™¨çš„æ·±åšçŸ¥è¯†å……åˆ†åº”ç”¨åˆ°è¿™ä¸ªæ¨¡å—ä¹‹ä¸­ã€‚è¿™ä¸ªæ¨¡å—çš„ä½œç”¨æ˜¯ç®€åŒ–è£…é¥°å™¨å’ŒåŠ¨æ€å‡½æ•°åŒ…è£…èµ·çš„å®ç°ï¼Œä½¿å¾—å¤šå±‚è£…é¥°ä¹Ÿæ”¯æŒå†…çœä¸”è¡Œä¸ºæ­£ç¡®ï¼Œæ—¢å¯ä»¥åº”ç”¨åˆ°æ–¹æ³•ä¸Šï¼Œä¹Ÿå¯ä»¥ä½œä¸ºæè¿°ç¬¦ä½¿ç”¨ã€‚ æœ¬æ–‡æ‹¾å–äº†Graham Dumpletonåœ¨wraptæ¨¡å—ä¸­é™„å¸¦çš„ä¸€ç³»åˆ—åšæ–‡çš„ç‰™æ…§ï¼Œæ—¨åœ¨å¸¦æ¥å¯¹pythonè£…é¥°å™¨æ›´æ·±çš„ç†è§£å’Œæ›´å¥½çš„è®¾è®¡ã€‚ ä¸Šä¸€ç¯‡æ–‡ç«  è®ºè¿°äº†æ™®é€šè£…é¥°å™¨å¯èƒ½å¸¦æ¥çš„ä¸€äº›å†…çœç¼ºé™·ï¼Œå¹¶æå‡ºäº†ä¸€äº›è§£å†³æ–¹æ¡ˆã€‚æœ¬æ–‡æ¥ä¸Šæ–‡æ›´æ·±å…¥åœ°ä»‹ç»pythonè£…é¥°å™¨çš„é«˜çº§ç”¨æ³•ä»¥ä¾¿ä¹‹åç»§ç»­æ¢è®¨å…³äºå†…çœç¼ºé™·çš„è§£å†³æ–¹æ¡ˆã€‚ å¸¦å‚æ•°çš„è£…é¥°å™¨ æ¥ä¸Šæ–‡ï¼Œæˆ‘ä»¬è‡³ä»Šä¸ºæ­¢çš„æ‰€åˆ›å»ºçš„æ‰€æœ‰è£…é¥°å™¨éƒ½ä¸èƒ½ä¼ å…¥ä»»ä½•å‚æ•°ï¼Œä½†è¦çŸ¥é“é€šè¿‡ä¼ å…¥å‚æ•°æ¥æ”¹å˜è£…é¥°å™¨çš„éƒ¨åˆ†è£…é¥°è¡Œä¸ºæ˜¯ä¸€ç§å¾ˆå¸¸è§å¹¶ä¸”å¼ºå¤§çš„ç‰¹æ€§ã€‚é€šå¸¸æˆ‘ä»¬åªè¦ç”¨ä¸€ä¸ªæ¥å—å‚æ•°çš„å‡½æ•°é—­åŒ…å°±èƒ½æ„æˆä¸€ä¸ªå¸¦å‚æ•°çš„è£…é¥°å™¨ã€‚ def with_arguments ( arg ): @decorator def _wrapper ( wrapped , instance , args , kwargs ): return wrapped ( * args , ** kwargs ) return _wrapper @with_arguments ( arg = 1 ) def function (): pass å¦‚æœç»™è£…é¥°å™¨å‚æ•°argä¸€ä¸ªé»˜è®¤å€¼çš„è¯ï¼Œå°±èƒ½ä»¥ @with_arguments() çš„æ–¹å¼è°ƒç”¨å®ƒäº†ã€‚ä½†è¿™ç§è°ƒç”¨æ–¹å¼ä¼šå’Œæˆ‘ä»¬ä¹‹å‰ä½¿ç”¨è£…é¥°å™¨çš„æ–¹å¼ä¸ä¸€è‡´ã€‚ä½†æ˜¯æˆ‘ä»¬å¯ä»¥ç”¨å‚æ•°é»˜è®¤å€¼å’Œ partial å‡½æ•°ç»“åˆçš„æ–¹æ³•æ¥å®ç°è¿™ä¸€å‰åçš„ç»Ÿä¸€ï¼š def optional_arguments ( wrapped = None , * , arg = 1 ): if wrapped is None : return functools . partial ( optional_arguments , arg = arg ) @decorator def _wrapper ( wrapped , instance , args , kwargs ): return wrapped ( * args , ** kwargs ) return _wrapper ( wrapped ) @optional_arguments ( arg = 2 ) def function1 (): pass @optional_arguments def function2 (): pass å½“wrappedå‚æ•°ä¸ºç©ºæ—¶ï¼Œåˆ™è¿”å›ä¸€ä¸ªå·²ç»å…·æœ‰é»˜è®¤å‚æ•° arg çš„è£…é¥°å™¨ functools.partial(optional_arguments, arg=arg) æ¥è£…é¥°å‡½æ•°ã€‚ ç»™è¢«è£…é¥°çš„å‡½æ•°æ·»åŠ ç¼“å­˜åŠŸèƒ½ å¾ˆå¤šæ—¶å€™ï¼Œå½“æˆ‘ä»¬å¤šéè°ƒç”¨æŸä¸ªå‡½æ•°çš„æ—¶å€™å°±ä¼šå¸Œæœ›è¯¥å‡½æ•°èƒ½å¤Ÿ\"è®°å½•\"ä¸‹æ¥å®ƒä¹‹å‰æ‰€è¿è¡Œçš„ç»“æœï¼Œå¹¶ä¸”åœ¨ä¸‹æ¬¡ä¼ å…¥ç›¸åŒå‚æ•°çš„æ—¶å€™ä¸å†å»åšå®ƒå†…éƒ¨é‚£äº›å¤æ‚çš„è¿ç®—è€Œæ˜¯ç›´æ¥è¿”å›ç¼“å­˜çš„å€¼ã€‚è¿™å¬èµ·æ¥æ˜¯ä¸€ä¸ªæœ‰äº›éº»çƒ¦çš„éœ€æ±‚ã€‚å¹¸è¿çš„æ˜¯ï¼Œé€šè¿‡åœ¨è£…é¥°å™¨ä¸­å®šä¹‰ä¸€ä¸ªç¼“å­˜ç»“æ„ï¼Œèƒ½è®©æˆ‘ä»¬æ–¹ä¾¿åœ°è®©ä»»æ„ä¸€ä¸ªå‡½æ•°æ‹¥æœ‰è¿™ä¸€ç¥å¥‡çš„åŠŸèƒ½ã€‚ è¿™é‡Œæˆ‘ä»¬ä¹Ÿç”¨åˆ°äº†ä¸Šä¸€èŠ‚æ‰€æåˆ°çš„é»˜è®¤å‚æ•°å’Œ partial å‡½æ•°ç»“åˆçš„è£…é¥°å™¨è®¾è®¡ï¼š def cache ( wrapped = None , d = None ): if wrapped is None : return functools . partial ( cache , d = d ) if d is None : d = {} @decorator def _wrapper ( wrapped , instance , args , kwargs ): try : key = ( args , frozenset ( kwargs . items ())) #æ­¤æ¬¡ä¼ å…¥çš„å‚æ•°é›†åˆ return d [ key ] #å½“å‚æ•°é›†åˆå·²ç¼“å­˜æ—¶ç›´æ¥è¿”å›ä¹‹å‰çš„ç»“æœ except KeyError : result = d [ key ] = wrapped ( * args , ** kwargs ) #å½“ä¸ºæ–°å‚æ•°çš„ç¼“å­˜åˆ°è£…é¥°å™¨çš„å­—å…¸ä¸­ return result return _wrapper ( wrapped ) @cache def function1 (): return time . time () _d = {} #å½“ä¼ å…¥åŒä¸€ä¸ªå­—å…¸çš„æ—¶å€™ï¼Œè¢«è£…é¥°çš„ä¸åŒå‡½æ•°ä¼šæ‹¥æœ‰ç›¸åŒçš„ç¼“å­˜ã€‚ @cache ( d = _d ) def function2 (): return time . time () @cache ( d = _d ) def function3 (): return time . time () ä¸ä¹‹å‰ç›¸åŒï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†è¿™ä¸€ç¼“å­˜è£…é¥°å™¨å†™æˆç±»çš„ç‰ˆæœ¬ï¼š class cache ( object ): def __init__ ( self , wrapped ): self . wrapped = wrapped self . d = {} def __call__ ( self , * args , ** kwargs ): try : key = ( args , frozenset ( kwargs . items ())) return self . d [ key ] except KeyError : result = self . d [ key ] = self . wrapped ( * args , ** kwargs ) return result @cache def function (): return time . time () pythonä¸­çš„åŒæ­¥è£…é¥°å™¨ åœ¨Javaä¸­ï¼Œå¦‚æœæˆ‘ä»¬å¸Œæœ›ä¸€ä¸ªæ–¹æ³•æ˜¯åŒæ­¥ (synchronized) çš„ï¼Œæœ‰ä¸¤ç§æ–¹å¼ç»™æˆ‘ä»¬çš„ä»£ç å¢åŠ åŒæ­¥ç‰¹æ€§ï¼š //ç¬¬ä¸€æ˜¯ä½¿ç”¨synchronizedå…³é”®å­—çš„æ–¹å¼ä½¿æ•´ä¸ªæ–¹æ³•å…·æœ‰åŒæ­¥ç‰¹æ€§ public class SynchronizedCounter { private int c = 0 ; public synchronized void increment () { c ++ ; } public synchronized void decrement () { c -- ; } public synchronized int value () { return c ; } } //ç¬¬äºŒæ˜¯ä½¿ç”¨synchronizedè¯­å¥ä½¿å¾—è¢«åŒ…è£¹çš„ä»£ç å—å…·æœ‰åŒæ­¥ç‰¹æ€§ //ä¸ç¬¬ä¸€ä¸ªæ–¹æ³•ä¸åŒçš„æ˜¯ï¼Œæˆ‘ä»¬å¿…é¡»åˆ¶å®šä¸€ä¸ªæä¾›å†…åœ¨é”çš„å¯¹è±¡(è¿™ //é‡Œæ˜¯this) public void addName ( String name ) { synchronized ( this ) { lastName = name ; nameCount ++ ; } nameList . add ( name ); } ç®€å•çš„æ¥è¯´ï¼ŒåŒæ­¥ç‰¹æ€§å³æ˜¯è®©æ¯ä¸ªç±»çš„å®ä¾‹éƒ½æ‹¥æœ‰ä¸€ä¸ªå†…åœ¨çš„é”ï¼Œå½“ä¸€ä¸ªæ–¹æ³•æˆ–ä¸€æ®µä»£ç è¢«è§¦å‘çš„æ—¶å€™å°±å–å¾—é”ï¼Œå½“è¯¥æ–¹æ³•è¿”å›æ—¶éšåè¯¥é”å°±è¢«é‡Šæ”¾ã€‚è¿™ç§é”è¢«ç§°ä¸º é‡å…¥é” ã€‚å½“ä¸€ä¸ªçº¿ç¨‹è·å–å¯¹è±¡é”ä¹‹åï¼Œè¿™ä¸ªçº¿ç¨‹å¯ä»¥ä¸ç”¨é˜»å¡åœ°å†æ¬¡è·å–æœ¬å¯¹è±¡ä¸Šçš„é”ï¼Œè€Œå…¶ä»–çš„çº¿ç¨‹æ˜¯ä¸å¯ä»¥çš„ã€‚è¿™å°±ä½¿å¾—ä»ä¸€ä¸ªåŒæ­¥çš„æ–¹æ³•è¿è¡Œåœ¨åŒä¸€å¯¹è±¡ä¸­çš„å¦ä¸€ä¸ªåŒæ­¥æ–¹æ³•æˆä¸ºäº†å¯èƒ½ã€‚ åˆæ¢åŒæ­¥è£…é¥°å™¨ åœ¨pythonä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨å’Œthreadingæ¨¡å—çš„é”æ–¹æ³•æ¥ç¡®ä¿è¢«æˆ‘ä»¬è£…é¥°çš„å‡½æ•°å…·æœ‰åŒæ­¥ç‰¹æ€§ã€‚ import threading def synchronized ( wrapped ): lock = threading . RLock () @functools . wraps ( wrapped ) def _wrapper ( * args , ** kwargs ): with lock : return wrapped ( * args , ** kwargs ) return _wrapper @synchronized def function (): pass å½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨ä¸Šä¹‹å‰æåˆ°çš„å¸¦å‚è£…é¥°å™¨æŠ€æœ¯ä½¿æˆ‘ä»¬çš„åŒæ­¥é”è£…é¥°å™¨æ›´åŠ çµæ´»,å†åŠ ä¸Š decorator è£…é¥°å™¨æ¥è·å–ä¹‹å‰çš„è‡ªçœç‰¹æ€§ã€‚ def synchronized ( wrapped = None , lock = None ): if wrapped is None : return functools . partial ( synchronized , lock = lock ) if lock is None : lock = threading . RLock () @decorator def _wrapper ( wrapped , instance , args , kwargs ): with lock : return wrapped ( * args , ** kwargs ) return _wrapper ( wrapped ) @synchronized def function1 (): pass lock = threading . Lock () @synchronized ( lock = lock ) def function2 (): pass è¿™ä½¿å¾—æˆ‘ä»¬çš„è£…é¥°å™¨èƒ½å¤Ÿé€‚ç”¨åœ¨å®ä¾‹ã€ç±»å’Œé™æ€æ–¹æ³•ã€‚ä½†ä»”ç»†æƒ³æƒ³ä»¥ä¸Šä»£ç çš„è¯ä¼šå‘ç°è¿™ä¸€ç®€å•çš„å®ç°å…¶å®å¹¶ä¸å®ç”¨ã€‚å› ä¸ºåŒæ­¥é”åªå¯¹ä¸åŒçº¿ç¨‹è®¿é—®è¢«è£…é¥°çš„æ–¹æ³•æ—¶æ‰èµ·ä½œç”¨å¹¶ä¸”ä»–ä¼šä½œç”¨äºç€ä¸ªç±»çš„æ‰€æœ‰å®ä¾‹ï¼Œè¿™å’Œæˆ‘ä»¬å¸Œæœ›åœ¨javaä¸­çœ‹åˆ°çš„è¡¨ç°ä¸å°½ç›¸åŒã€‚ æˆ‘ä»¬æƒ³è¦çš„è¡Œä¸ºæ˜¯ï¼šå¯¹äºæŸä¸ªç±»çš„ä¸€ä¸ªå®ä¾‹çš„æ‰€æœ‰è¢«synchronizedè£…é¥°è¿‡çš„å®ä¾‹æ–¹æ³•ï¼Œå®ƒä»¬ä¼šåŒæ­¥å…³è”ä¸€ä¸ªç±»å®ä¾‹çš„å•é”å¯¹è±¡ã€‚ åŒæ—¶ï¼Œæˆ‘ä»¬è¦è€ƒè™‘ä¸€ä¸ªé¢å¤–çš„é—®é¢˜ï¼Œå‘ç”Ÿç«äº‰åˆ›å»ºé”å…³ç³»æ—¶æˆ‘ä»¬è¯¥å¦‚ä½•ä¿è¯æˆ‘ä»¬çš„çº¿ç¨‹å®‰å…¨æ€§ã€‚ åœ¨å¯¹è±¡ä¸­å‚¨å­˜åŒæ­¥é” è®©æˆ‘ä»¬é‡æ–°è€ƒè™‘ä¸€ä¸‹é—®é¢˜ï¼Œé™¤äº†ä¼ å…¥é”æˆ–è€…åœ¨å‡½æ•°é—­åŒ…ä¸­åˆ›å»ºå®ƒï¼Œæˆ‘ä»¬å¯ä¸å¯ä»¥è®©è¢«è£…é¥°å¯¹è±¡è‡ªå·±å‚¨å­˜é”å¹¶é€šè¿‡åŒ…è£…å‡½æ•°æ¥ç®¡ç†ï¼Ÿ ç­”æ¡ˆæ˜¯è‚¯å®šçš„ã€‚è®©æˆ‘ä»¬æ¥çœ‹ä»¥ä¸‹ä»£ç ï¼š @decorator def synchronized ( wrapped , instance , args , kwargs ): if instance is None : owner = wrapped #å½“è¢«è£…é¥°çš„ä½æ™®é€šå‡½æ•°æˆ–é™æ€æ–¹æ³•æ—¶å°†åŒæ­¥é”ç»‘åœ¨å‡½æ•°æˆ–æ–¹æ³•ä¸Š else : owner = instance #å½“è¢«è£…é¥°çš„ä¸ºå®ä¾‹æ–¹æ³•æˆ–ç±»æ–¹æ³•æ—¶å°†åŒæ­¥é”ç»‘åœ¨å®ä¾‹æˆ–ç±»ä¸Š lock = vars ( owner ) . get ( '_synchronized_lock' , None ) if lock is None : #ä½¿ç”¨metalockæ¥ç¡®ä¿åˆ›å»ºåŒæ­¥é”æ—¶ä¸ä¼šå‡ºç°ç«äº‰å…³ç³» meta_lock = vars ( synchronized ) . setdefault ( '_synchronized_meta_lock' , threading . Lock ()) with meta_lock : #å†æ¬¡ç¡®è®¤é”çš„å­˜åœ¨çŠ¶æ€ï¼Œé˜²æ­¢åœ¨ç”Ÿæˆmeta_lockæ—¶åŒæ­¥é”å·²ç»è¢«å…¶ä»–çº¿ç¨‹ç”Ÿæˆ lock = vars ( owner ) . get ( '_synchronized_lock' , None ) if lock is None : lock = threading . RLock () setattr ( owner , '_synchronized_lock' , lock ) with lock : return wrapped ( * args , ** kwargs ) #å¯¹åº”çš„ç»‘å®šå…³ç³»å¦‚ä¸‹ @synchronized # lock bound to function1 def function1 (): pass @synchronized # lock bound to function2 def function2 (): pass @synchronized # lock bound to Class class Class ( object ): @synchronized # lock bound to instance of Class def function_im ( self ): pass @synchronized # lock bound to Class @classmethod def function_cm ( cls ): pass @synchronized # lock bound to function_sm @staticmethod def function_sm (): pass åœ¨å®ç°æˆ‘ä»¬çš„è®¾è®¡çš„æ—¶å€™ä¸€ä¸ªå…³é”®çš„äº‹æƒ…å°±æ˜¯åœ¨ç¬¬ä¸€æ¬¡åˆ›å»ºåŒæ­¥é”çš„æ—¶å€™æˆ‘ä»¬éœ€è¦åˆ¤æ–­é”æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨çš„è¯å°±è¿”å›åŸæœ‰çš„é”ã€‚æˆ‘ä»¬é€šè¿‡ lock = vars(wrapped).get('_synchronized_lock', None) è·å–é”ã€‚ å½“æˆ‘ä»¬é‡åˆ°å¤šä¸ªçº¿ç¨‹ç«äº‰åˆ›å»ºé”æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ lock = vars(wrapped).setdefault('_synchronized_lock', threading.RLock()) é»˜è®¤å­—å…¸çš„å½¢å¼æ¥é˜²æ­¢ä»»ä¸€çº¿ç¨‹åˆ›å»ºçš„é”è¢«å¦ä¸€ä¸ªçº¿ç¨‹è¦†ç›–ã€‚ä½†å¦‚æœæˆ‘ä»¬ä½¿ç”¨è¿™ä¸€æ–¹æ³•çš„è¯ï¼Œæˆ‘ä»¬ä¼šåœ¨è£…é¥°ç±»æ–¹æ³•ä¸Šé‡åˆ°é—®é¢˜ã€‚å› ä¸ºç±»çš„å­—å…¸ dictproxy å¹¶æ²¡æœ‰setdefaultæ–¹æ³•ï¼Œå› æ­¤æˆ‘ä»¬åªèƒ½ä½¿ç”¨ setattr(Object, '_synchronized_lock', threading.RLock()) æ¥ä¸ºç±»è®¾ç½®åŒæ­¥é” è®©åŒæ­¥é”è£…é¥°å™¨å…·æœ‰ä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„åŠŸèƒ½ è‡³æ­¤ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å®ç°äº†javaçš„åŒæ­¥çš„ç¬¬ä¸€ä¸ªåŠŸèƒ½äº†ã€‚å¯¹äºç¬¬äºŒä¸ªåŠŸèƒ½ï¼Œåœ¨pythonä¸­æ˜¯ä¸€ä¸ªå’Œä¸Šä¸‹æ–‡ç®¡ç†å™¨ç›¸ä¼¼çš„è¡Œä¸ºã€‚æˆ‘ä»¬æƒ³è®©æˆ‘ä»¬çš„synchronizedè£…é¥°å™¨èƒ½å¤Ÿè¿™æ ·ä½¿ç”¨æ¥åŒæ­¥æ–¹æ³•æˆ–å‡½æ•°ä¸­çš„éƒ¨åˆ†ä»£ç ï¼š ```python class Object(object): @synchronized def function_im_1 ( self ) : pass def function_im_2 ( self ) : with synchronized ( self ) : pass ``` ä¸ºäº†æ‹¥æœ‰ä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„åŠŸèƒ½ï¼Œæˆ‘ä»¬å¿…é¡»è®©è£…é¥°å™¨å‡½æ•°è¿”å›ä¸€ä¸ªå…·æœ‰ __enter__ and __exit__ æ–¹æ³•çš„å¯¹è±¡ã€‚ä½†æˆ‘ä»¬çš„ synchronized(None) å®é™…è¿”å›çš„æ˜¯ä¸€ä¸ª <__main__.function_wrapper object at 0x107b7ea10> å¯¹è±¡ï¼Œå†è¯¥ç±»é‡Œæˆ‘ä»¬è¿˜æ²¡æœ‰ç€ä¸¤ä¸ªæ–¹æ³•çš„å®šä¹‰ã€‚å› æ­¤æˆ‘ä»¬å·²ç»ä¸èƒ½ä½¿ç”¨åŸæ¥çš„è£…é¥°å™¨å·¥å‚å‡½æ•° @decorator äº†ï¼Œä½œä¸ºæ›¿ä»£æˆ‘ä»¬é¦–å…ˆè¦ç›´æ¥ä½¿ç”¨ä¹‹å‰å®šä¹‰çš„ function_wrapper ç±»è£…é¥°å™¨æ¥è·å¾—å†…çœåŠŸèƒ½ï¼š ```python def synchronized(wrapped): def _synchronized_lock(owner): lock = vars(owner).get('_synchronized_lock', None) if lock is None : meta_lock = vars ( synchronized ). setdefault ( '_synchronized_meta_lock' , threading . Lock ()) with meta_lock : lock = vars ( owner ). get ( '_synchronized_lock' , None ) if lock is None : lock = threading . RLock () setattr ( owner , '_synchronized_lock' , lock ) return lock # ä½¿ç”¨ _synchronized_lock åŒæ­¥é”çš„è‡ªå®šä¹‰è£…é¥°å™¨ def _synchronized_wrapper ( wrapped , instance , args , kwargs ): with _synchronized_lock ( instance or wrapped ): return wrapped ( * args , ** kwargs ) # ç›´æ¥ä½¿ç”¨ function_wrapper è‡ªå®šä¹‰åŒæ­¥é”è£…é¥°å™¨è£…é¥°åˆ°è¢«è£…é¥°å‡½æ•° warpped ä¸Š return function_wrapper ( wrapped , _synchronized_wrapper ) ``` ç°åœ¨æˆ‘ä»¬å·²ç»å®Œæˆè£…é¥°å·¥ç¨‹å‡½æ•°çš„æ›¿æ¢å·¥ä½œäº†ï¼Œæ¥ä¸‹æ¥çš„åŠŸèƒ½å°±æ˜¯åœ¨ function_wrapper ç±»è£…é¥°å™¨ä¸­åŠ å…¥ __enter__ and __exit__ é­”æœ¯æ–¹æ³•æ¥å®ç°ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œè¿™é‡Œæˆ‘ä»¬ç»§æ‰¿äº† function_wrapper ç±»: def synchronized ( wrapped ): def _synchronized_lock ( owner ): lock = vars ( owner ) . get ( '_synchronized_lock' , None ) if lock is None : meta_lock = vars ( synchronized ) . setdefault ( '_synchronized_meta_lock' , threading . Lock ()) with meta_lock : lock = vars ( owner ) . get ( '_synchronized_lock' , None ) if lock is None : lock = threading . RLock () setattr ( owner , '_synchronized_lock' , lock ) #ä¸ºè¢«è£…é¥°å™¨è£…é¥°çš„æ–¹æ³•åŠ é” return lock def _synchronized_wrapper ( wrapped , instance , args , kwargs ): with _synchronized_lock ( instance or wrapped ): return wrapped ( * args , ** kwargs ) class _synchronized_function_wrapper ( function_wrapper ): def __enter__ ( self ): self . _lock = _synchronized_lock ( self . wrapped ) #ä¸ºä¸Šä¸‹æ–‡ç®¡ç†å™¨æ·é” self . _lock . acquire () return self . _lock def __exit__ ( self , * args ): self . _lock . release () return _synchronized_function_wrapper ( wrapped , _synchronized_wrapper ) è‡³æ­¤ä¸ºæ­¢ï¼Œæˆ‘ä»¬å¯¹javaçš„ synchronized çš„ç§»æ¤å°±å…¨éƒ¨å®Œæˆäº†ã€‚ Additional å‚è€ƒæ–‡çŒ®: 1. Wrapt blog","tags":"Python","title":"Pythonè£…é¥°å™¨çš„æ­£ç¡®æ‰“å¼€æ–¹å¼(2)"},{"url":"leetcode-replace-words.html","text":"Description In English, we have a concept called root , which can be followed by some other words to form another longer word - let's call this word successor . For example, the root an , followed by other , which can form another word another. Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length. You need to output the sentence after the replacement. Example 1: Input : dict = [ \"cat\" , \"bat\" , \"rat\" ] sentence = \"the cattle was rattled by the battery\" Output : \"the cat was rat by the bat\" Note: 1. The input will only have lower-case letters. 2. 1 <= dict words number <= 1000 3. 1 <= sentence words number <= 1000 4. 1 <= root length <= 100 5. 1 <= sentence words length <= 1000 Source link Best practice åœ¨è¿™é‡Œç”¨åˆ°çš„æ•°æ®ç»“æ„æ˜¯Tireæ ‘ã€‚ Trieæ ‘ï¼Œå³å­—å…¸æ ‘ï¼Œåˆç§°å•è¯æŸ¥æ‰¾æ ‘æˆ–é”®æ ‘ï¼Œæ˜¯ä¸€ç§æ ‘å½¢ç»“æ„ï¼Œæ˜¯ä¸€ç§å“ˆå¸Œæ ‘çš„å˜ç§ã€‚å…¸å‹åº”ç”¨æ˜¯ç”¨äºç»Ÿè®¡å’Œæ’åºå¤§é‡çš„å­—ç¬¦ä¸²ï¼ˆä½†ä¸ä»…é™äºå­—ç¬¦ä¸²ï¼‰ï¼Œæ‰€ä»¥ç»å¸¸è¢«æœç´¢å¼•æ“ç³»ç»Ÿç”¨äºæ–‡æœ¬è¯é¢‘ç»Ÿè®¡ã€‚å®ƒçš„ä¼˜ç‚¹æ˜¯ï¼šæœ€å¤§é™åº¦åœ°å‡å°‘æ— è°“çš„å­—ç¬¦ä¸²æ¯”è¾ƒï¼ŒæŸ¥è¯¢æ•ˆç‡æ¯”å“ˆå¸Œè¡¨é«˜ã€‚ Trieçš„æ ¸å¿ƒæ€æƒ³æ˜¯ç©ºé—´æ¢æ—¶é—´ã€‚åˆ©ç”¨å­—ç¬¦ä¸²çš„å…¬å…±å‰ç¼€æ¥é™ä½æŸ¥è¯¢æ—¶é—´çš„å¼€é”€ä»¥è¾¾åˆ°æé«˜æ•ˆç‡çš„ç›®çš„ã€‚ python version from collections import defaultdict import functools class Solution ( object ): def replaceWords ( self , dict , sentence ): \"\"\" :type dict: List[str] :type sentence: str :rtype: str \"\"\" IS_WORD = True #Tireæ ‘ä¸­è¡¨ç¤ºèŠ‚ç‚¹ä¸ºå•è¯æœ«å­—æ¯çš„æ ‡è¯†ç¬¦ï¼Œè¿™é‡Œé¢å¤–å­˜å‚¨å®Œæ•´å•è¯ def generateTire ( dct ): #è¿™æ˜¯ä¸€ä¸ªå¾ˆå¼ºå¤§çš„é€’å½’ç”Ÿæˆdefaultdictæ ‘çš„è¡¨è¾¾å¼ _tire = lambda : defaultdict ( _tire ) tire = _tire () for word in dct : node = tire for char in word : node = node [ char ] node [ IS_WORD ] = word return tire def searchWord ( tire , word ): #åœ¨tireæ ‘ç§æŸ¥æ‰¾åˆ°æœ€çŸ­çš„å•è¯successorï¼Œè¿™é‡Œ #åªè¦é‡åˆ°IS_WORDé”®å°±è¿”å›æŸ¥åˆ°çš„å•è¯ node = tire for char in word : if char not in node : break node = node [ char ] if IS_WORD in node : return node [ IS_WORD ] return word #åˆ©ç”¨partialæ–¹æ³•æ„é€ mapå‡½æ•° replace = functools . partial ( searchWord , generateTire ( dict )) return \" \" . join ( map ( replace , sentence . split ())) Mark: 116 ms Additional","tags":"Python","title":"LeetCode - Replace Words"},{"url":"pythonzhuang-shi-qi-de-zheng-que-da-kai-fang-shi-1.html","text":"Description è£…é¥°å™¨æ˜¯pythonè¯­è¨€çš„ä¸€ä¸ªéå¸¸å¸¸ç”¨åŠpythonicçš„ç‰¹æ€§ï¼Œä½†å¾€å¾€ç”±äºå¿½è§†pythonä¸­çš„å†…çœï¼Œæˆ‘ä»¬ä¼šå†™å‡ºä¸€äº›ä¸æ˜¯ç‰¹åˆ«å®Œç¾çš„è‡ªå®šä¹‰è£…é¥°å™¨ã€‚Graham Dumpletonå†™äº†ä¸€ç³»åˆ— åšå®¢ ï¼Œæ·±å…¥å‰–æäº†å¦‚ä½•å®ç°è¡Œä¸ºè‰¯å¥½çš„è£…é¥°å™¨ã€‚æ­¤å¤–ä»–è¿˜æ˜¯ wraptæ¨¡å— çš„ä½œè€…,ä»–å°†ä»–å¯¹è£…é¥°å™¨çš„æ·±åšçŸ¥è¯†å……åˆ†åº”ç”¨åˆ°è¿™ä¸ªæ¨¡å—ä¹‹ä¸­ã€‚è¿™ä¸ªæ¨¡å—çš„ä½œç”¨æ˜¯ç®€åŒ–è£…é¥°å™¨å’ŒåŠ¨æ€å‡½æ•°åŒ…è£…èµ·çš„å®ç°ï¼Œä½¿å¾—å¤šå±‚è£…é¥°ä¹Ÿæ”¯æŒå†…çœä¸”è¡Œä¸ºæ­£ç¡®ï¼Œæ—¢å¯ä»¥åº”ç”¨åˆ°æ–¹æ³•ä¸Šï¼Œä¹Ÿå¯ä»¥ä½œä¸ºæè¿°ç¬¦ä½¿ç”¨ã€‚ æœ¬æ–‡æ‹¾å–äº†Graham Dumpletonåœ¨wraptæ¨¡å—ä¸­é™„å¸¦çš„ä¸€ç³»åˆ—åšæ–‡çš„ç‰™æ…§ï¼Œæ—¨åœ¨å¸¦æ¥å¯¹pythonè£…é¥°å™¨æ›´æ·±çš„ç†è§£å’Œæ›´å¥½çš„è®¾è®¡ã€‚ ä¸¤ç±»è£…é¥°å™¨åŠå†…çœç¼ºé™· è£…é¥°å™¨ç¬¦ @ æ˜¯ä¸€ç§è¯­æ³•ç³–ï¼Œæ·±ç©¶åŸç†çš„è¯ä½¿ç”¨è£…é¥°å™¨å®é™…ä¸Šæ˜¯ä¸€ç§çŒ´å­è¡¥ä¸çš„å®ç°æ–¹å¼ã€‚ä»¥ä¸‹çš„ä¸¤ç§æ–¹å¼æ˜¯ç­‰ä»·çš„ï¼š @function_wrapper def function (): pass ç­‰ä»·äº #åœ¨python2.4ç‰ˆæœ¬ä½ ä¼šè¿™ä¹ˆåš def function (): pass function = function_wrapper ( function ) è€Œå¯¹äºè£…é¥°å™¨çš„å®ç°ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹å¼ï¼š 1.å®šä¹‰ç±» class function_wrapper : def __init__ ( self , wrapped ): self . wrapped = wrapped def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) @function_wrapper def function (): pass #é€šè¿‡é­”æœ¯æ–¹æ³•__call__æ¥è¿è¡Œè¢«åŒ…è£¹çš„æ–¹æ³• 2.ä½¿ç”¨é—­åŒ…å‡½æ•° def function_wrapper ( wrapped ): def _wrapper ( * args , ** kwargs ): return wrapped ( * args , ** kwargs ) return _wrapper @function_wrapper def function (): pass ç„¶è€Œç”±äºæè¿°ç¬¦çš„åŸå› ï¼Œä½¿ç”¨ç±»ä½œä¸ºè£…é¥°å™¨æ˜¯ä¸€ä¸ªæ›´å¥½åœ°é€‰æ‹©ã€‚ å¯¹äºç›´æ¥å®šä¹‰çš„è£…é¥°å™¨ï¼Œè¢«è£…é¥°çš„æ–¹æ³•çš„ name å’Œ doc å±æ€§å°†ä¼šä¸¢å¤±ï¼Œå› æ­¤æ ‡å‡†åº“functoolsæä¾›äº† warps å’Œ update_wrapper è£…é¥°å™¨æ¥å°†è¢«è£…é¥°æ–¹æ³•çš„è‡ªçœå±æ€§ä¼ é€’ç»™è£…é¥°å™¨ï¼š import functools def function_wrapper ( wrapped ): #å¯¹é—­åŒ…ä½¿ç”¨functools.wrapsè£…é¥° @functools . wraps ( wrapped ) def _wrapper ( * args , ** kwargs ): return wrapped ( * args , ** kwargs ) return _wrapper class function_wrapper : def __init__ ( self , wrapped ): self . wrapped = wrapped #å¯¹äºç±»ä½¿ç”¨functools.update_wrapperè£…é¥° functools . update_wrapper ( self , wrapped ) def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) @function_wrapper def function (): pass äº‹å®ä¸Šwarps()é‡ç”¨äº†update_wrapper()çš„ä»£ç ï¼Œä¸ºäº†æ›´å¥½åœ°ç†è§£è£…é¥°å™¨çš„è¿ä½œï¼Œä¸å¦¨è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å®ƒçš„æºç ã€‚ \"\"\" python 3.3ç‰ˆæœ¬çš„update_wrapper()çš„æºç ,åœ¨è¿™é‡Œå°†è¢«è£…é¥°çš„æ–¹æ³•ä¿å­˜åœ¨__wrapped__å±æ€§ä¸­ã€‚è¿™æ˜¯ä¸€ä¸ªbugï¼Œ3.4ä¸­å°†è¿™ä¸€æ­¥æ”¾åœ¨äº†å‡½æ•°ä½“çš„æœ€åã€‚ è¿™ä¸ªå‡½æ•°åˆå°†WRAPPER_ASSIGNMENTSä¸­çš„å±æ€§ä»è¢«è£…é¥°å‡½æ•°wrappedä¸­å¤åˆ¶åˆ°è£…é¥°å™¨wrapperä¸­ã€‚ æœ€åå°†è¢«è£…é¥°å‡½æ•°__dict__ä¸­çš„å†…å®¹å¤åˆ¶åˆ°è£…é¥°å™¨ä¸­ã€‚ \"\"\" WRAPPER_ASSIGNMENTS = ( '__module__' , '__name__' , '__qualname__' , '__doc__' , '__annotations__' ) WRAPPER_UPDATES = ( '__dict__' ,) def update_wrapper ( wrapper , wrapped , assigned = WRAPPER_ASSIGNMENTS , updated = WRAPPER_UPDATES ): wrapper . __wrapped__ = wrapped for attr in assigned : try : value = getattr ( wrapped , attr ) except AttributeError : pass else : setattr ( wrapper , attr , value ) for attr in updated : getattr ( wrapper , attr ) . update ( getattr ( wrapped , attr , {})) ç„¶è€Œï¼Œå³ä¾¿ä½¿ç”¨äº†functoolsçš„ä¿®æ­£æ–¹æ³•ä¿å­˜äº†åŸå‡½æ•°çš„ name å’Œ doc æ–¹æ³•ï¼Œä½†è¿˜æ˜¯ä¼šåœ¨ä»¥ä¸‹å‡ ä¸ªæ–¹é¢å­˜åœ¨ç¼ºé™·ï¼š ä¿å­˜å‡½æ•°å‚æ•°è§„èŒƒï¼ˆ inspect.getargspec() ï¼‰ ä¿å­˜å‡½æ•°è·å–æºç çš„èƒ½åŠ›ï¼ˆ inspect.getsource() ï¼‰ * å åŠ é™„åŠ åœ¨æè¿°ç¬¦ä¸Šçš„èƒ½åŠ› è§£å†³æ–¹æ¡ˆ æè¿°ç¬¦è£…é¥°å™¨ è§£å†³é—®é¢˜çš„ä¸€ä¸ªåŠæ³•æ˜¯ä¸ºæ™®é€šå‡½æ•°å’Œç±»ä¸­å‡½æ•°åˆ†é…å„è‡ªçš„è£…é¥°æ–¹æ³•ï¼Œè¿™æ ·å½¢æˆçš„è£…é¥°å™¨ä¹Ÿä¼šæ˜¯ä¸€ç§æè¿°ç¬¦ã€‚ class bound_function_wrapper : def __init__ ( self , wrapped ): self . wrapped = wrapped functools . update_wrapper ( self , wrapped ) def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) class function_wrapper : def __init__ ( self , wrapped ): self . wrapped = wrapped functools . update_wrapper ( self , wrapped ) def __get__ ( self , instance , owner ): wrapped = self . wrapped . __get__ ( instance , owner ) return bound_function_wrapper ( wrapped ) def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) å¦‚æœè£…é¥°å™¨é™„åŠ åœ¨ä¸€ä¸ªæ™®é€šå‡½æ•°ä¸Šï¼Œä¼šä½¿ç”¨function_wrapperçš„__call__æ–¹æ³•è¿”å›çš„å‡½æ•°ã€‚è€Œå¦‚æœæ˜¯é™„åŠ åœ¨ç±»æ–¹æ³•ä¸Šçš„è¯ï¼Œåˆ™ä¼šè°ƒç”¨__get__æ–¹æ³•è¿”å›ä¸€ä¸ªç»‘å®šinstanceçš„wrapperï¼Œç„¶åå®ƒçš„__call__æ–¹æ³•åˆ™ä¼šè¢«è§¦å‘ã€‚è¿™ä½¿å¾—è¯¥è£…é¥°å™¨èƒ½ä¼ é€’æè¿°ç¬¦åè®®ã€‚ å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæ¯æ¬¡å½“è¿™ä¸ªwrapperé™„åŠ åœ¨ç±»æ–¹æ³•ä¸Šè¢«è°ƒç”¨çš„æ—¶å€™ï¼Œä¸€ä¸ªæ–°çš„è¾…åŠ©wrapperå°†ä¼šè¢«åˆ›å»ºã€‚è¿™ç‚¹æ— ç–‘å½±å“äº†æ•ˆç‡ã€‚æˆ‘ä»¬å¯èƒ½éœ€è¦ä¸€ä¸ªæ›´åŠ é«˜æ•ˆçš„æ–¹æ³•æ¥å®ç°è¿™ç§è£…é¥°å™¨äº†ã€‚ é€æ˜å¯¹è±¡ä»£ç† å¯¹äºä»¥ä¸Šé—®é¢˜çš„è§£å†³æ–¹æ¡ˆè¢«ç§°ä¸ºå¯¹è±¡ä»£ç†ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªä¸è¢«å®ƒåŒ…è£…çš„å¯¹è±¡çœ‹ä¸Šå»å¾ˆç›¸ä¼¼çš„wrapperï¼š #è¿™ä¸ªå¯¹è±¡ä»£ç†çš„ä¾‹å­åªä»£ç†äº†ä¸€äº›åŸºæœ¬çš„æ–¹æ³•ã€‚ class object_proxy : def __init__ ( self , wrapped ): self . wrapped = wrapped try : self . __name__ = wrapped . __name__ except AttributeError : pass @property def __class__ ( self ): return self . wrapped . __class__ def __getattr__ ( self , name ): return getattr ( self . wrapped , name ) æœ‰äº†è¿™ä¸ªwrapperç±»æˆ‘ä»¬å°±å¯ä»¥è·Ÿ update_wrapper() è¯´æ‹œæ‹œäº†ã€‚å¯ä»¥å¯¹æˆ‘ä»¬çš„è£…é¥°å™¨åšä»¥ä¸‹ä¿®æ”¹ï¼š class bound_function_wrapper ( object_proxy ): def __init__ ( self , wrapped ): super () . __init__ ( wrapped ) def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) class function_wrapper ( object_proxy ): def __init__ ( self , wrapped ): super () . __init__ ( wrapped ) def __get__ ( self , instance , owner ): wrapped = self . wrapped . __get__ ( instance , owner ) return bound_function_wrapper ( wrapped ) def __call__ ( self , * args , ** kwargs ): return self . wrapped ( * args , ** kwargs ) è¿™æ—¶__name__å’Œ__doc__ ä¹‹ç±»çš„å±æ€§å°†ä¼šä»ä»£ç†å¯¹è±¡ä¸­è·å–ï¼Œinspect.getargspec()å’Œinspect.getsource()ä¹Ÿèƒ½å¤Ÿé¡ºåˆ©å·¥ä½œã€‚ è¿™ä¸ªæ–¹æ¡ˆè¿˜å­˜åœ¨çš„ä¸€ä¸ªæ˜æ˜¾ç¼ºé™·å°±æ˜¯ï¼šæ¯æ¬¡æˆ‘ä»¬è¦å®šä¹‰ä¸€ä¸ªæ–°è£…é¥°å™¨ä¾¿è¦ç»§æ‰¿object_proxyä»£ç†å‡½æ•°å¹¶å†™ä¸¤ä¸ªç±»çš„ä»£ç ã€‚ä¸ºäº†è®©æˆ‘ä»¬çš„è£…é¥°å™¨æ›´å¥½ç”¨ä¸å¦¨ç”¨å·¥å‚å‡½æ•°æ¥å¸®æˆ‘ä»¬å®Œæˆè¿™é¡¹é‡å¤å·¥ä½œã€‚ ä½¿ç”¨è£…é¥°å™¨å·¥å‚æ¥åˆ›å»ºè£…é¥°å™¨ åœ¨è¿™èŠ‚æˆ‘ä»¬çš„ç›®çš„æ˜¯åˆ›å»ºä¸€ä¸ªå¸®åŠ©æˆ‘ä»¬æ›´å¥½åœ°åˆ›å»ºè£…é¥°å™¨çš„è£…é¥°å™¨ã€‚è¿™å¯èƒ½å¬èµ·æ¥æœ‰äº›æ‹—å£ï¼Œä½†è¿™ç§è®¾è®¡ç¡®å®èƒ½å‡å°‘æˆ‘ä»¬æ„å»ºä¸€ä¸ªæ–°çš„è£…é¥°å™¨æ—¶å€™çš„ä»£ç ã€‚ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯è®©æˆ‘ä»¬å¯ä»¥åƒè¿™æ ·åˆ›å»ºä¸€ä¸ªè£…é¥°å™¨ï¼š @decorator def my_function_wrapper ( wrapped , args , kwargs ): return wrapped ( * args , ** kwargs ) @my_function_wrapper def function (): pass äº‹å®ä¸Šï¼Œæˆ‘ä»¬çš„è£…é¥°å™¨å·¥å‚çš„å®ç°æ–¹å¼å’Œä½¿ç”¨ partial() å‡½æ•°å¾ˆåƒï¼Œå®ƒåœ¨å®šä¹‰æ—¶å°†æ–°è£…é¥°å™¨ç»‘å…¥ï¼Œåœ¨è¿è¡Œæ—¶æ¥å—è¢«æ–°è£…é¥°å™¨è£…é¥°çš„çš„å¯¹è±¡ã€‚å› æ­¤åœ¨æˆ‘ä»¬ä¹‹å‰çš„å®šä¹‰çš„è£…é¥°å™¨åŸºç¡€ä¸Šè¦ä¼ å…¥wrapperå‚æ•°ã€‚ import functools def decorator ( wrapper ): @functools . wraps ( wrapper ) def _decorator ( wrapped ): return function_wrapper ( wrapped , wrapper ) return _decorator class bound_function_wrapper ( object_proxy ): def __init__ ( self , wrapped , wrapper ): super () . __init__ ( wrapped ) self . instace = instance #ä¸ºä¹‹åçš„å†…çœä¿å­˜instanceå±æ€§ self . wrapper = wrapper def __call__ ( self , * args , ** kwargs ): if self . instance is None : #å½“ç±»æ–¹æ³•ä»¥Class.method(instance,arg1,arg2)çš„å½¢å¼è°ƒç”¨ #çš„æ—¶å€™ï¼Œä¼šäº§ç”Ÿself.instanceä¸ºNoneçš„ç‰¹æ®Šæƒ…å†µï¼Œè¿™æ—¶ç¬¬ä¸€ #ä¸ªå‚æ•°ä¸ºinstanceï¼Œå…¶ä½™å‚æ•°ä¸ºä¼ å…¥å˜é‡ï¼Œä»¥è¿™ä¸ªå½¢å¼è¿”å›è¢« #è£…é¥°å¥½çš„ç±»æ–¹æ³• instance , args = args [ 0 ], args [ 1 :] wrapped = functools . partial ( self . wrapped , instance ) return self . wrapper ( wrapped , instance , args , kwargs ) return self . wrapper ( self . wrapped , self . instance , args , kwargs ) class function_wrapper ( object_proxy ): def __init__ ( self , wrapped , wrapper ): super () . __init__ ( wrapped ) self . wrapper = wrapper def __get__ ( self , instance , owner ): wrapped = self . wrapped . __get__ ( instance , owner ) return bound_function_wrapper ( wrapped , instance , self . wrapper ) #å½“è£…é¥°å™¨é™„åŠ åœ¨ç±»æ–¹æ³•æ—¶ä¼ å…¥è¯¥instance def __call__ ( self , * args , ** kwargs ): return self . wrapper ( self . wrapped , None , args , kwargs ) #å½“è£…é¥°å™¨é™„åŠ åœ¨æ™®é€šå‡½æ•°æ—¶instanceå˜é‡ä¼ å…¥None è¿™ä¸ªè£…é¥°å™¨å·¥å‚çš„ä½¿ç”¨ç¤ºä¾‹å¦‚ä¸‹ï¼š @decorator def my_function_wrapper ( wrapped , instance , args , kwargs ): print ( 'INSTANCE' , instance ) print ( 'ARGS' , args ) return wrapped ( * args , ** kwargs ) @my_function_wrapper def function ( a , b ): pass class Class ( object ): @my_function_wrapper def function_im ( self , a , b ): pass >>> function ( 1 , 2 ) INSTANCE None ARGS ( 1 , 2 ) >>> c . function_im ( 1 , 2 ) INSTANCE < __main__ . Class object at 0x1085ca9d0 > ARGS ( 1 , 2 ) >>> Class . function_im ( c , 1 , 2 ) INSTANCE < __main__ . Class object at 0x1085ca9d0 > ARGS ( 1 , 2 ) å¯ä»¥çœ‹åˆ°è¿™ä¸ªè®¾è®¡å·²ç»æ¯”è¾ƒå¥½åœ°è§£å†³äº†æˆ‘ä»¬ä¹‹å‰é‡åˆ°çš„é‚£äº›é—®é¢˜ï¼Œä½†è¿™ä»æ—§ä¸æ˜¯ä¸€ä¸ªå®Œç¾çš„æ–¹æ¡ˆã€‚ç§‰æŒç€æ±‚çœŸåŠ¡å®çš„ç²¾ç¥ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°è¯¥è£…é¥°å™¨å¦‚æœå åŠ è½½classmethodä¸Šåˆ™ä¼šå‡ºç°é—®é¢˜ï¼š class Class ( object ): @my_function_wrapper @classmethod def function_cm ( cls , a , b ): pass >>> Class . function_cm ( 1 , 2 ) INSTANCE 1 ARGS ( 2 ,) æˆ‘ä»¬ä¹Ÿå¾ˆç»æœ›å•Š,æ‰€ä»¥åªèƒ½æ”¹è¿›å•¦ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬ä¼šè®¾è®¡ä¸€ä¸ªç»Ÿä¸€è£…é¥°å™¨ï¼ˆå®‡å®™è£…é¥°å™¨ï¼‰æ¥å¯¹è£…é¥°å™¨é™„åŠ åœ¨æ™®é€šå‡½æ•°ã€å®ä¾‹æ–¹æ³•ã€ç±»æ–¹æ³•ã€é™æ€å‡½æ•°ç”šè‡³ç±»ä¸Šçš„æƒ…å†µåˆ†å‘å¯¹åº”çš„ç­–ç•¥ã€‚ è®²ç±»æ–¹æ³•å’Œé™æ€æ–¹æ³•çº³å…¥ç–†ç•Œ åœ¨è§£å†³ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ˜ç¡®ä¸€ä¸‹é—®é¢˜ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯è®©æˆ‘ä»¬çš„è£…é¥°å™¨èƒ½å¤ŸåŒºåˆ†ä»¥ä¸‹ä¸‰ç§ä¸åŒçš„æ–¹æ³•ï¼š é€šè¿‡ç±»çš„é€”å¾„è¿è¡Œçš„å®ä¾‹æ–¹æ³• è¢«classmethodè£…é¥°çš„ç±»æ–¹æ³• * è¢«staticmethodè£…é¥°çš„é™æ€æ–¹æ³• é¦–å…ˆèƒ½æƒ³åˆ°çš„æ˜¯ä¸€ä¸ªç®€å•çš„æ–¹æ³•ï¼Œå°±æ˜¯åœ¨ä¼ å…¥ä¸€ä¸ªå‚æ•°æ¥è®°å½•è¢«ç»‘å®šçš„æ–¹æ³•ç±»å‹ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥å¯¹ä»£ç ä½œå¦‚ä¸‹ä¿®æ”¹ã€‚ class bound_function_wrapper ( object_proxy ): def __init__ ( self , wrapped , instance , wrapper , binding ): super ( bound_function_wrapper , self ) . __init__ ( wrapped ) self . instance = instance self . wrapper = wrapper self . binding = binding #ä¼ å…¥ç»‘å®šçš„æ–¹æ³•ç±»å‹ def __call__ ( self , * args , ** kwargs ): if self . binding == 'function' : #æ–¹æ³•è°ƒç”¨ if self . instance is None : #ä»¥Class.method(instan,args,kwargs)å½¢å¼è°ƒç”¨ï¼Œåˆ™å–ç¬¬ä¸€ä¸ªå‚æ•°ä½œä¸ºself instance , args = args [ 0 ], args [ 1 :] wrapped = functools . partial ( self . wrapped , instance ) return self . wrapper ( wrapped , instance , args , kwargs ) else : #ä»¥instance.method()æ–¹å¼è°ƒç”¨ return self . wrapper ( self . wrapped , self . instance , args , kwargs ) else : #å¦‚æœæ˜¯ç±»æ–¹æ³•æˆ–è€…é™æ€æ–¹æ³•è°ƒç”¨ instance = getattr ( self . wrapped , '__self__' , None ) #å½“ä¸ºæ—¶ç±»æ–¹æ³•instanceå˜é‡ç­‰äºæ–¹æ³•__self__å³Classå¯¹è±¡ï¼Œå½“ä¸ºé™æ€æ–¹æ³•æ—¶åˆ™ä¸ºNone return self . wrapper ( self . wrapped , instance , args , kwargs ) class function_wrapper ( object_proxy ): def __init__ ( self , wrapped , wrapper ): super ( function_wrapper , self ) . __init__ ( wrapped ) self . wrapper = wrapper #åˆ¤æ–­è¢«ç»‘å®šæ–¹æ³•çš„ç§ç±» if isinstance ( wrapped , classmethod ): self . binding = 'classmethod' elif isinstance ( wrapped , staticmethod ): self . binding = 'staticmethod' else : self . binding = 'function' def __get__ ( self , instance , owner ): wrapped = self . wrapped . __get__ ( instance , owner ) return bound_function_wrapper ( wrapped , instance , self . wrapper , self . binding ) def __call__ ( self , * args , ** kwargs ): return self . wrapper ( self . wrapped , None , args , kwargs ) æ¥ä¸‹æ¥æˆ‘ä»¬å¯ä»¥åˆ†åˆ«å¯¹æ™®é€šç±»æ–¹æ³•imï¼Œç±»æ–¹æ³•cmï¼Œé™æ€æ–¹æ³•småšæµ‹è¯•æ¥æ£€éªŒäº†ï¼š >>> c . function_im ( 1 , 2 ) INSTANCE < __main__ . Class object at 0x10c2c43d0 > ARGS ( 1 , 2 ) >>> Class . function_im ( c , 1 , 2 ) INSTANCE < __main__ . Class object at 0x10c2c43d0 > ARGS ( 1 , 2 ) >>> c . function_cm ( 1 , 2 ) INSTANCE < class ' __main__ . Class '> ARGS ( 1 , 2 ) >>> Class . function_cm ( 1 , 2 ) INSTANCE < class ' __main__ . Class '> ARGS ( 1 , 2 ) >>> c . function_sm ( 1 , 2 ) INSTANCE None ARGS ( 1 , 2 ) >>> Class . function_sm ( 1 , 2 ) INSTANCE None ARGS ( 1 , 2 ) å†™å®Œè¿™äº›ä»£ç å°±å¯ä»¥äº†å˜›ï¼Œå¾ˆä¸å¹¸çš„å‘Šè¯‰ä½ ï¼Œè¿™è¿˜ä¸å¤Ÿã€‚åœ¨æ¥ä¸‹æ¥çš„åšæ–‡ä¸­ä¼šå±•ç°GrahamDumpletonå¯¹è£…é¥°å™¨ç†è§£çš„æ–¹æ–¹é¢é¢ï¼Œè®©æˆ‘ä»¬æ¥çœ‹çœ‹ä»–å¯¹å®Œç¾è£…é¥°å™¨çš„ä¸æ‡ˆè¿½æ±‚å§ã€‚ Additional å‚è€ƒæ–‡çŒ®: 1. Wrapt blog","tags":"Python","title":"Pythonè£…é¥°å™¨çš„æ­£ç¡®æ‰“å¼€æ–¹å¼(1)"},{"url":"leetcode-linked-list-random-node.html","text":"Description Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? Example: // Init a singly linked list [ 1 , 2 , 3 ]. ListNode head = new ListNode ( 1 ); head . next = new ListNode ( 2 ); head . next . next = new ListNode ( 3 ); Solution solution = new Solution ( head ); // getRandom () should return either 1 , 2 , or 3 randomly . Each element should have equal probability of returning . solution . getRandom (); Source link Analytics å½“æ•°æ®æµé•¿åº¦å·²çŸ¥æˆ–ä¸å¤§çš„æ—¶å€™å¯ä»¥ç®€å•çš„è§£å†³è¿™ä¸ªé—®é¢˜ï¼šéå†é“¾è¡¨ä¹‹åå¾—åˆ°é•¿åº¦nï¼Œä»¥ $$ {\\frac{1}{n}} $$ çš„æ¦‚ç‡é€‰å–å…ƒç´ ã€‚ ä½†å½“ç»™å‡ºæ•°æ®æµçš„é•¿åº¦å¾ˆå¤§æˆ–è€…æœªçŸ¥æ—¶ï¼Œæˆ‘ä»¬å°†æ— æ³•åšéå†é“¾è¡¨å¾—åˆ°é•¿åº¦çš„æ“ä½œã€‚æ­¤æ—¶å› ä¸ºæ•°æ®æµå¾ˆå¤§ï¼Œä¸ºäº†è¿½æ±‚æ•ˆç‡ï¼Œè¯¥æ•°æ®æµä¸­æ•°æ®åªèƒ½è®¿é—®ä¸€æ¬¡ã€‚æœ‰æ²¡æœ‰è¿™ä¹ˆä¸€ä¸ªéšæœºé€‰æ‹©ç®—æ³•ï¼Œä½¿å¾—è¯¥æ•°æ®æµä¸­çš„æ‰€æœ‰æ•°æ®è¢«é€‰ä¸­çš„æ¦‚ç‡ç›¸ç­‰å‘¢ï¼Ÿ è¿™ä¸ªæ— è¾¹ç•Œçš„é—®é¢˜ç¡®å®å¾ˆè®©äººå¤´ç–¼å•Šï¼Œä½†å¹¸è¿çš„æ˜¯ï¼Œè¿™æˆ‘ä»¬å¯ä»¥ç”¨ä¸ºè“„æ°´æ± æŠ½æ ·ï¼ˆReservoir Samplingï¼‰çš„æ–¹æ³•æ¥è§£å†³è¯¥ç±»é—®é¢˜ã€‚ è“„æ°´æ± æŠ½æ ·ä»‹ç» è“„æ°´æ± æŠ½æ ·æ˜¯ä¸€ç§ä»ä¸€ä¸ªåŒ…å« n ä¸ªå…ƒç´ çš„åˆ—è¡¨ S ä¸­éšæœºæŠ½å– k ä¸ªæ ·æœ¬çš„éšæœºç®—æ³•ï¼Œè¿™é‡Œçš„ n æ˜¯ä¸€ä¸ªéå¸¸å¤§æˆ–è€…æœªçŸ¥çš„å€¼ã€‚ è¿™ä¸ªç®—æ³•çš„åŸºæœ¬æ€æƒ³å°±æ˜¯å…ˆé€‰ä¸­ 1 åˆ° k ä¸ªå…ƒç´ ï¼Œä½œä¸ºè¢«é€‰ä¸­çš„å…ƒç´ ã€‚ç„¶åä¾æ¬¡å¯¹ç¬¬ k+1 è‡³ç¬¬ n ä¸ªå…ƒç´ åšä»¥ä¸‹æ“ä½œï¼š æ¯ä¸ªå…ƒç´ éƒ½æœ‰ $$ {\\frac{k}{i}} $$ çš„æ¦‚ç‡è¢«é€‰ä¸­ï¼Œç„¶åä»¥ç­‰æ¦‚ç‡ $$ {\\frac{1}{k}} $$ æ›¿æ¢æ‰è¢«é€‰ä¸­çš„å…ƒç´ ã€‚å…¶ä¸­ i æ˜¯å…ƒç´ çš„åºå·ã€‚ ç®—æ³•è¯æ˜ ç®—æ³•çš„æˆç«‹æ˜¯ç”¨æ•°å­¦å½’çº³æ³•è¯æ˜çš„: è®¾æ¯æ¬¡éƒ½æ˜¯ä»¥ k / i çš„æ¦‚ç‡æ¥é€‰æ‹©ã€‚å‡è®¾å½“å‰æ˜¯ i + 1 , æŒ‰ç…§æˆ‘ä»¬çš„è§„å®šï¼Œ i + 1 è¿™ä¸ªå…ƒç´ è¢«é€‰ä¸­çš„æ¦‚ç‡æ˜¯ k / i + 1 ï¼Œä¹Ÿå³ç¬¬ i + 1 è¿™ä¸ªå…ƒç´ åœ¨è“„æ°´æ± ä¸­å‡ºç°çš„æ¦‚ç‡æ˜¯ k / i + 1 æ­¤æ—¶è€ƒè™‘å‰ i ä¸ªå…ƒç´ ï¼Œå¦‚æœå‰ i ä¸ªå…ƒç´ å‡ºç°åœ¨è“„æ°´æ± ä¸­çš„æ¦‚ç‡éƒ½æ˜¯ k / i + 1 çš„è¯ï¼Œè¯´æ˜æˆ‘ä»¬çš„ç®—æ³•æ˜¯æ²¡æœ‰é—®é¢˜çš„ã€‚ å¯¹è¿™ä¸ªé—®é¢˜å¯ä»¥ç”¨å½’çº³æ³•æ¥è¯æ˜ï¼š k < i <= N ï¼š 1 . å½“ i = k + 1 çš„æ—¶å€™ï¼Œè“„æ°´æ± çš„å®¹é‡ä¸º k ï¼Œç¬¬ k + 1 ä¸ªå…ƒç´ è¢«é€‰æ‹©çš„æ¦‚ç‡æ˜æ˜¾ä¸º k / ( k + 1 ), æ­¤æ—¶å‰ k ä¸ªå…ƒç´ å‡ºç°åœ¨è“„æ°´æ± çš„æ¦‚ç‡ä¸º k / ( k + 1 ), å¾ˆæ˜æ˜¾ç»“è®ºæˆç«‹ã€‚ 2 . å‡è®¾å½“ j = i çš„æ—¶å€™ç»“è®ºæˆç«‹ï¼Œæ­¤æ—¶ä»¥ k / i çš„æ¦‚ç‡æ¥é€‰æ‹©ç¬¬ i ä¸ªå…ƒç´ ï¼Œå‰ i - 1 ä¸ªå…ƒç´ å‡ºç°åœ¨è“„æ°´æ± çš„æ¦‚ç‡éƒ½ä¸º k / i ã€‚ è¯æ˜å½“ j = i + 1 çš„æƒ…å†µï¼š å³éœ€è¦è¯æ˜å½“ä»¥ k / i + 1 çš„æ¦‚ç‡æ¥é€‰æ‹©ç¬¬ i + 1 ä¸ªå…ƒç´ çš„æ—¶å€™ï¼Œæ­¤æ—¶ä»»ä¸€å‰ i ä¸ªå…ƒç´ å‡ºç°åœ¨è“„æ°´æ± çš„æ¦‚ç‡éƒ½ä¸º k / ( i + 1 ). å‰ i ä¸ªå…ƒç´ å‡ºç°åœ¨è“„æ°´æ± çš„æ¦‚ç‡æœ‰ 2 éƒ¨åˆ†ç»„æˆ , â‘ åœ¨ç¬¬ i + 1 æ¬¡é€‰æ‹©å‰å¾—å‡ºç°åœ¨è“„æ°´æ± ä¸­ï¼Œâ‘¡å¾—ä¿è¯ç¬¬ i + 1 æ¬¡é€‰æ‹©çš„æ—¶å€™ä¸è¢«æ›¿æ¢æ‰ â‘  . ç”± 2 çŸ¥é“åœ¨ç¬¬ i + 1 æ¬¡é€‰æ‹©å‰ï¼Œä»»ä¸€å‰ i ä¸ªå…ƒç´ å‡ºç°åœ¨è“„æ°´æ± çš„æ¦‚ç‡éƒ½ä¸º k / i â‘¡ . è€ƒè™‘è¢«æ›¿æ¢çš„æ¦‚ç‡ï¼š é¦–å…ˆè¦è¢«æ›¿æ¢å¾—ç¬¬ i + 1 ä¸ªå…ƒç´ è¢«é€‰ä¸­ ( ä¸ç„¶ä¸ç”¨æ›¿æ¢äº† ) æ¦‚ç‡ä¸º k / i + 1 ï¼Œå…¶æ¬¡æ˜¯å› ä¸ºéšæœºæ›¿æ¢çš„æ± å­ä¸­ k ä¸ªå…ƒç´ ä¸­ä»»æ„ä¸€ä¸ªï¼Œæ‰€ä»¥ä¸å¹¸è¢«æ›¿æ¢çš„æ¦‚ç‡æ˜¯ 1 / k ï¼Œæ•… å‰ i ä¸ªå…ƒç´  ( æ± ä¸­å…ƒç´  ) ä¸­ä»»ä¸€è¢«æ›¿æ¢çš„æ¦‚ç‡ = k / ( i + 1 ) * 1 / k = 1 / i + 1 åˆ™ ( æ± ä¸­å…ƒç´ ä¸­ ) æ²¡æœ‰è¢«æ›¿æ¢çš„æ¦‚ç‡ä¸º : 1 - 1 / ( i + 1 ) = i / i + 1 ç»¼åˆâ‘  â‘¡ , é€šè¿‡ä¹˜æ³•è§„åˆ™ å¾—åˆ°å‰ i ä¸ªå…ƒç´ å‡ºç°åœ¨è“„æ°´æ± çš„æ¦‚ç‡ä¸º k / i * i / ( i + 1 ) = k / i + 1 æ•…è¯æ˜æˆç«‹ ä¼ªä»£ç  Init : a reservoir with the size ï¼š k for i = k + 1 to N M = random ( 1 , i ); if ( M < k ) SWAP the Mth value and ith value end for åŠ æƒåˆ†å¸ƒå¼è“„æ°´æ± æŠ½æ · æœ‰æ—¶å€™æˆ‘ä»¬çš„è“„æ°´æ± ä¸­çš„æ•°æ®æ˜¯æœ‰æƒé‡ï¼Œç®—æ³•å¸Œæœ›æ•°æ®è¢«æŠ½æ ·é€‰ä¸­çš„æ¦‚ç‡å’Œè¯¥æ•°æ®çš„æƒé‡æˆæ­£æ¯”ã€‚2005å¹´Pavlos S. Efraimidiså’ŒPaul G. Spirakisçš„è®ºæ–‡ Weighted random sampling with a reservoir æä¾›äº†å¯¹äºåŠ æƒçŠ¶æ€ä¸‹è¿™ä¸€é—®é¢˜çš„è§£å†³æ–¹æ¡ˆã€‚ä»–çš„è§£æ³•æ—¢ç®€å•åˆä¼˜é›…ï¼ŒåŸºæœ¬æ€æƒ³å’Œä¸Šé¢çš„åˆ†å¸ƒå¼è“„æ°´æ± æŠ½æ ·ä¸€è‡´ï¼šå¯¹äºæ¯ä¸ªæ•°æ®è®¡ç®—ä¸€ä¸ª0-1çš„å€¼Rï¼Œå¹¶æ±‚rçš„næ¬¡æ–¹æ ¹ä½œä¸ºè¯¥æ•°æ®çš„æ–°çš„Rå€¼ã€‚è¿™é‡Œçš„nå°±æ˜¯è¯¥æ•°æ®çš„æƒé‡ã€‚æœ€ç»ˆç®—æ³•è¿”å›å‰kä¸ªRå€¼æœ€é«˜çš„æ•°æ®ç„¶åè¿”å›ã€‚æ ¹æ®è®¡ç®—è§„åˆ™ï¼Œæƒé‡è¶Šå¤§çš„æ•°æ®è®¡ç®—æ‰€å¾—çš„Rå€¼è¶Šæ¥è¿‘1ï¼Œæ‰€ä»¥è¶Šæœ‰å¯èƒ½è¢«è¿”å›ã€‚ Best practice pythonå®ç°çš„æ™®é€šè“„æ°´æ± ç®—æ³•ã€‚ python version ### Definition for singly-linked list. ### class ListNode(object): ### def __init__(self, x): ### self.val = x ### self.next = None import random class Solution ( object ): def __init__ ( self , head ): \"\"\" @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. :type head: ListNode \"\"\" self . head = head self . k = 1 #éšæœºé€‰å‡ºçš„æ•°é‡ def getRandom ( self ): \"\"\" Returns a random node's value. :rtype: int \"\"\" count = 0 node = self . head for _ in range ( k ): result . append ( node . val ) node = node . next while node : count += 1 #ä¸ºlinklistæ•°é‡è®¡æ•°ï¼Œè§†ä¸ºi r = random . randint ( 1 , count ) if r <= self . k : #ä»¥k/içš„æ¦‚ç‡æ¥é€‰æ‹© result [ r ] = node . val #è¿™é‡Œæ²¡æœ‰ç”¨äº¤æ¢æ“ä½œï¼Œä¼šæœ‰æ•°æ®ä¸¢å¤± node = node . next return self . result ### Your Solution object will be instantiated and called as such: ### obj = Solution(head) ### param_1 = obj.getRandom() Mark: 362 ms è¿™æ˜¯ç»´åŸºç™¾ç§‘ä¸Šå…³äºåŠ æƒè“„æ°´æ± ç®—æ³•çš„Rè¯­è¨€å®ç°ã€‚ In many applications sampling is required to be according to the weights that are assigned to each items available in set. For example, it might be required to sample queries in a search engine with weight as number of times they were performed so that the sample can be analyzed for overall impact on user experience. There are two ways to interpret weights assigned to each item in the set: 1. Let the weight of each item be $$ {\\displaystyle w_{i}} w_{i} $$ and sum of all weights be W. We can convert weight to probability of item getting selected in sample as $$ {\\displaystyle P_{i}=w_{i}/W} $$ . 2. Let the weight of two items i and j be $$ {\\displaystyle w_{i}} w_{i} and {\\displaystyle w_{j}} w_{j} $$ . Let the probability of item i getting selected in sample be $$ {\\displaystyle p_{i}} p_{i }$$ , then we give $$ {\\displaystyle p_{j}=\\min(1,p_{i}{\\frac {w_{j}}{w_{i}}})} {\\displaystyle p_{j}=\\min(1,p_{i}{\\frac {w_{j}}{w_{i}}})} $$ . Algorithm A-Res ( * S is a stream of items to sample , R will contain the result S.Current returns current item in stream S.Weight returns weight of current item in stream S.Next advances stream to next position The power operator is represented by &#94; min - priority - queue supports : Count -> number of items in priority queue Minimum () -> returns minimum key value of all items Extract - Min () -> Remove the item with minimum key Insert ( key , Item ) -> Adds item with specified key * ) ReservoirSample ( S[1.. ? ] , R[1..k] ) H = new min - priority - queue while S has data r = Random ( 0 , 1 ) &#94; ( 1 / S.Weight ) // important : inclusive range if H.Count < k H.Insert ( r , S.Current ) else if H.Minimum < r H.Extract - Min () H.Insert ( r , S.Current ) S.Next Additional å‚è€ƒæ–‡çŒ®ï¼š 1. Reservoir sampling 2. è“„æ°´æ± æŠ½æ ·åŠå®ç° 3. æ•°æ®å·¥ç¨‹å¸ˆå¿…çŸ¥ç®—æ³•ï¼šè“„æ°´æ± æŠ½æ ·","tags":"Python,R","title":"LeetCode - Linked List Random Node"},{"url":"pythonicde-fan-han-shu.html","text":"Description å› ä¸ºpythonä¸æ”¯æŒé‡è½½æ–¹æ³•æˆ–å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•åƒjavaé‚£æ ·ç”¨ä¸åŒçš„ç­¾åå®šä¹‰æŸä¸ªæ–¹æ³•çš„å˜ä½“æ¥å®ç°ç”¨ä¸åŒçš„æ–¹å¼å¤„ç†ä¸åŒçš„æ•°æ®ç±»å‹ï¼Œå¯¼è‡´è¿™ä¸ªåŒºåˆ«çš„æ ¹æœ¬åŸå› æ˜¯pythonè¯­è¨€çš„åŠ¨æ€æ€§ã€‚ä½†ä¹Ÿæ­£å› å¾—ç›Šäºæ­¤ï¼Œåˆ©ç”¨åŠ¨æ€å‚æ•°ç±»å‹ä»¥åŠå­—å…¸å‚æ•°åˆ—è¡¨ï¼Œåœ¨pythonä¸­æˆ‘ä»¬å¸¸å¸¸å¯ä»¥æŠŠæ–¹æ³•å˜æˆä¸€ä¸ªåˆ†æ´¾å‡½æ•°ï¼Œä½¿ç”¨ä¸€ä¸²if/elif/elseè°ƒç”¨ä¸“é—¨çš„å‡½æ•°æ¥å®ç°ç±»javaé‡è½½çš„åŠŸèƒ½ã€‚ç„¶è€Œè¿™æ ·å¹¶ä¸ä¾¿äºæ¨¡å—çš„ç”¨æˆ·æ‹“å±•ï¼Œè¿˜æ˜¾å¾—å¾ˆæ„šè ¢ï¼šå®ç°ä¸€é•¿ï¼Œåˆ†æ´¾å‡½æ•°ä¼šå˜å¾—å¾ˆå¤§ï¼Œè€Œä¸”å®ƒä¸å„ä¸ªä¸“é—¨å‡½æ•°ä¹‹é—´çš„è€¦åˆä¹Ÿå¾ˆç´§å¯†ã€‚ æˆ‘ä»¬è¿™é‡Œçš„æ³›å‹å‡½æ•°æ˜¯æŒ‡ç”±ä¸€ç»„ä¸ºä¸åŒç±»å‹å‚æ•°æ‰§è¡Œç›¸ä¼¼æ“ä½œçš„å‡½æ•°ç»„æˆçš„å‡½æ•°ï¼Œå…·ä½“è°ƒç”¨å“ªä¸€ä¸ªå‡½æ•°çš„å®ç°å–å†³äºåˆ†å‘ç®—æ³•å’Œå‚æ•°ç±»å‹ï¼ˆä¹Ÿå³æ˜¯pythonä¸­çš„å‚æ•°åˆ—è¡¨ç±»å‹é‡è½½ï¼‰ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬ä¾‹ä¸¾äº† Fluent Python é‡Œçš„singledispathå’Œ Python Cookbook é‡Œçš„åˆ©ç”¨å‡½æ•°æ³¨è§£å®ç°æ–¹æ³•é‡è½½çš„ä¾‹å­ã€‚æ¥å±•ç°å‡½æ•°é‡è½½è¿™ä¸€é™æ€ç±»å‹ç‰¹æ€§åœ¨pythonè¿™ä¸ªåŠ¨æ€ç±»å‹è¯­è¨€ä¸­çš„å®ç°ä»¥åŠå±€é™ã€‚å¯¹äºè¿™ä¸ªç‰¹æ€§å®ç°ç‰µæ‰¯åˆ°äº†pythonçš„å¤šç§å…ƒç‰¹æ€§è®©å®ƒæˆä¸ºäº†ä¸€ä¸ªå®åœ¨æœ‰è¶£çš„è¯é¢˜ã€‚ Pythonå•åˆ†å‘å™¨ï¼ˆSingledispatchï¼‰æ˜¯å®ç°æ³›å‹å‡½æ•°çš„ä¸€ç§å½¢å¼ï¼Œç”±ä¸€ä¸ªå•ä¸€å‚æ•°æ¥å†³å®šé€‰æ‹©å’Œè°ƒç”¨å“ªä¸ªå‡½æ•°ã€‚åœ¨Python3.4ä¸­ï¼Œsingledispathæ–¹æ³•ç¬¬ä¸€å‡ºç°åœ¨functoolsæ¨¡å—ä¸­ï¼Œä½ å¯ä»¥åœ¨ PEP 443 â€” Single-dispatch generic function æ‰¾åˆ°å…³äºå®ƒæ›´å¤šç‰¹æ€§çš„ä»‹ç»ã€‚ åœ¨ Python Cookbook ä¸­ä»‹ç»äº†ä¸€ä¸ªä¸å®Œç¾ä½†å¯è¡Œçš„åˆ©ç”¨å‡½æ•°æ³¨è§£æ–¹å¼å®ç°æ–¹æ³•é‡è½½çš„æ–¹æ³•ï¼Œåˆ†åˆ«ç”¨å…ƒå‡½æ•°å’Œä¸singledispathç±»ä¼¼çš„è£…é¥°å™¨å®ç°ã€‚è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒæ·±å…¥çš„å…³äºå‡½æ•°æ³¨è§£çš„åº”ç”¨ã€‚ä½ ä¹Ÿå¯ä»¥åœ¨ä¹‹å‰çš„åšæ–‡ä¸­æ‰¾åˆ°ä¸€äº›æ¯”è¾ƒä¸æ·±å…¥çš„å¯¹äºå‡½æ•°æ³¨è§£çš„ åº”ç”¨ ã€‚ ä»£ç ç¤ºä¾‹ Singledispatch Python 3.4 æ–°å¢çš„ functools.singledispatch è£…é¥°å™¨å¯ä»¥æŠŠæ•´ä½“æ–¹æ¡ˆæ‹†åˆ†æˆå¤šä¸ªæ¨¡å—ï¼Œç”šè‡³å¯ä»¥ä¸ºä½ æ— æ³•ä¿®æ”¹çš„ç±»æä¾›ä¸“é—¨çš„å‡½æ•°ã€‚ä½¿ç”¨ @singledispatch è£…é¥°çš„æ™®é€šå‡½æ•°ä¼šå˜æˆæ³›å‡½æ•°ï¼ˆgeneric functionï¼‰ï¼šæ ¹æ®ç¬¬ä¸€ä¸ªå‚æ•°çš„ç±»å‹ï¼Œä»¥ä¸åŒæ–¹å¼æ‰§è¡Œç›¸åŒæ“ä½œçš„ä¸€ç»„å‡½æ•°ã€‚ä»¥ä¸‹æ˜¯fluent pythonä¸­å…³äºsingledispatchçš„ç¤ºä¾‹ã€‚ from functools import singledispatch from collections import abc import numbers import html @singledispatch # @singledispatch æ ‡è®°å¤„ç† object ç±»å‹çš„åŸºå‡½æ•°ã€‚ def htmlize ( obj ): content = html . escape ( repr ( obj )) return '<pre> {} </pre>' . format ( content ) @htmlize . register ( str ) # å„ä¸ªä¸“é—¨å‡½æ•°ä½¿ç”¨ @Â«base_functionÂ».register(Â«typeÂ») è£…é¥°ã€‚ def _ ( text ): # ä¸“é—¨å‡½æ•°çš„åç§°æ— å…³ç´§è¦ï¼›_ æ˜¯ä¸ªä¸é”™çš„é€‰æ‹©ï¼Œç®€å•æ˜äº†ã€‚ content = html . escape ( text ) . replace ( ' \\n ' , '<br> \\n ' ) return '<p> {0} </p>' . format ( content ) @htmlize . register ( numbers . Integral ) # ä¸ºæ¯ä¸ªéœ€è¦ç‰¹æ®Šå¤„ç†çš„ç±»å‹æ³¨å†Œä¸€ä¸ªå‡½æ•°ã€‚numbers.Integral æ˜¯ int çš„è™šæ‹Ÿè¶…ç±»ã€‚ def _ ( n ): return '<pre> {0} (0x {0:x} )</pre>' . format ( n ) @htmlize . register ( tuple ) # å¯ä»¥å æ”¾å¤šä¸ª register è£…é¥°å™¨ï¼Œè®©åŒä¸€ä¸ªå‡½æ•°æ”¯æŒä¸åŒç±»å‹ã€‚ @htmlize . register ( abc . MutableSequence ) def _ ( seq ): inner = '</li> \\n <li>' . join ( htmlize ( item ) for item in seq ) return '<ul> \\n <li>' + inner + '</li> \\n </ul>' singledispatch æœºåˆ¶çš„ä¸€ä¸ªæ˜¾è‘—ç‰¹å¾æ˜¯ï¼Œä½ å¯ä»¥åœ¨ç³»ç»Ÿçš„ä»»ä½•åœ°æ–¹å’Œä»»ä½•æ¨¡å—ä¸­æ³¨å†Œä¸“é—¨å‡½æ•°ã€‚å¦‚æœåæ¥åœ¨æ–°çš„æ¨¡å—ä¸­å®šä¹‰äº†æ–°çš„ç±»å‹ï¼Œå¯ä»¥è½»æ¾åœ°æ·»åŠ ä¸€ä¸ªæ–°çš„ä¸“é—¨å‡½æ•°æ¥å¤„ç†é‚£ä¸ªç±»å‹ã€‚æ­¤å¤–ï¼Œä½ è¿˜å¯ä»¥ä¸ºä¸æ˜¯è‡ªå·±ç¼–å†™çš„æˆ–è€…ä¸èƒ½ä¿®æ”¹çš„ç±»æ·»åŠ è‡ªå®šä¹‰å‡½æ•°ã€‚ Multidispatch è¿™æ˜¯ä¸¤ä¸ªpython cookbookä¸­åˆ©ç”¨annotationå¯¹å¤šå‚æ•°æ–¹æ³•çš„é‡è½½çš„ç¤ºä¾‹ã€‚åœ¨ç¬¬ä¸€ä¸ªç¤ºä¾‹ä¸­æˆ‘ä»¬åˆ©ç”¨å…ƒç±»æ¥ç”Ÿæˆæ”¯æŒå‚æ•°é‡è½½çš„ç±»ã€‚åœ¨__prepare__æ–¹æ³•ä¸­å°†ç±»çš„å­—å…¸å˜æˆè‡ªå®šä¹‰çš„MultiDictå­—å…¸ã€‚ ä½¿ç”¨å…ƒç±»å®ç° import inspect import types class MultiMethod : ''' Represents a single multimethod. ''' def __init__ ( self , name ): self . _methods = {} self . __name__ = name def register ( self , meth ): ''' Register a new method as a multimethod ''' sig = inspect . signature ( meth ) #åˆ©ç”¨inpsectæ¨¡å—æ¥è·å–å‡½æ•°ç­¾å # Build a type signature from the method's annotations types = [] for name , parm in sig . parameters . items (): if name == 'self' : continue if parm . annotation is inspect . Parameter . empty : raise TypeError ( 'Argument {} must be annotated with a type' . format ( name ) ) if not isinstance ( parm . annotation , type ): raise TypeError ( 'Argument {} annotation must be a type' . format ( name ) ) if parm . default is not inspect . Parameter . empty : self . _methods [ tuple ( types )] = meth types . append ( parm . annotation ) self . _methods [ tuple ( types )] = meth def __call__ ( self , * args ): ''' Call a method based on type signature of the arguments ''' types = tuple ( type ( arg ) for arg in args [ 1 :]) meth = self . _methods . get ( types , None ) if meth : return meth ( * args ) else : raise TypeError ( 'No matching method for types {} ' . format ( types )) def __get__ ( self , instance , cls ): ''' Descriptor method needed to make calls work in a class ''' if instance is not None : return types . MethodType ( self , instance ) else : return self class MultiDict ( dict ): ''' Special dictionary to build multimethods in a metaclass ''' def __setitem__ ( self , key , value ): if key in self : # If key already exists, it must be a multimethod or callable current_value = self [ key ] if isinstance ( current_value , MultiMethod ): current_value . register ( value ) else : mvalue = MultiMethod ( key ) #è£…é¥°ç¬¦æ¥æ§åˆ¶mvalueè¡Œä¸º mvalue . register ( current_value ) mvalue . register ( value ) super () . __setitem__ ( key , mvalue ) else : super () . __setitem__ ( key , value ) class MultipleMeta ( type ): ''' Metaclass that allows multiple dispatch of methods ''' def __new__ ( cls , clsname , bases , clsdict ): return type . __new__ ( cls , clsname , bases , dict ( clsdict )) @classmethod def __prepare__ ( cls , clsname , bases ): return MultiDict () ä¸ºäº†ä½¿ç”¨è¿™ä¸ªç±»ï¼Œä½ å¯ä»¥åƒä¸‹é¢è¿™æ ·å†™ï¼š class Spam ( metaclass = MultipleMeta ): def bar ( self , x : int , y : int ): print ( 'Bar 1:' , x , y ) def bar ( self , s : str , n : int = 0 ): print ( 'Bar 2:' , s , n ) ### Example: overloaded __init__ import time class Date ( metaclass = MultipleMeta ): def __init__ ( self , year : int , month : int , day : int ): self . year = year self . month = month self . day = day def __init__ ( self ): t = time . localtime () self . __init__ ( t . tm_year , t . tm_mon , t . tm_mday ) æµ‹è¯•ç»“æœ >>> s = Spam () >>> s . bar ( 2 , 3 ) Bar 1 : 2 3 >>> s . bar ( 'hello' ) Bar 2 : hello 0 >>> s . bar ( 'hello' , 5 ) Bar 2 : hello 5 >>> s . bar ( 2 , 'hello' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"multiple.py\" , line 42 , in __call__ raise TypeError ( 'No matching method for types {} ' . format ( types )) TypeError : No matching method for types ( < class ' int '>, <class ' str '>) >>> # Overloaded __init__ >>> d = Date ( 2012 , 12 , 21 ) >>> # Get today's date >>> e = Date () >>> e . year 2012 >>> e . month 12 >>> e . day 3 è£…é¥°å™¨å®ç° ä½œä¸ºä½¿ç”¨å…ƒç±»å’Œæ³¨è§£çš„ä¸€ç§æ›¿ä»£æ–¹æ¡ˆï¼Œå¯ä»¥é€šè¿‡æè¿°å™¨æ¥å®ç°ç±»ä¼¼çš„æ•ˆæœã€‚ import types class multimethod : def __init__ ( self , func ): self . _methods = {} self . __name__ = func . __name__ self . _default = func def match ( self , * types ): def register ( func ): ndefaults = len ( func . __defaults__ ) if func . __defaults__ else 0 for n in range ( ndefaults + 1 ): self . _methods [ types [: len ( types ) - n ]] = func return self return register def __call__ ( self , * args ): types = tuple ( type ( arg ) for arg in args [ 1 :]) meth = self . _methods . get ( types , None ) if meth : return meth ( * args ) else : return self . _default ( * args ) def __get__ ( self , instance , cls ): if instance is not None : return types . MethodType ( self , instance ) else : return self ä¸ºäº†ä½¿ç”¨æè¿°å™¨ç‰ˆæœ¬ï¼Œä½ éœ€è¦åƒä¸‹é¢è¿™æ ·å†™ï¼š class Spam : @multimethod def bar ( self , * args ): # Default method called if no match raise TypeError ( 'No matching method for bar' ) @bar . match ( int , int ) def bar ( self , x , y ): print ( 'Bar 1:' , x , y ) @bar . match ( str , int ) def bar ( self , s , n = 0 ): print ( 'Bar 2:' , s , n ) ç¼ºé™· æœ¬èŠ‚çš„å®ç°ä¸­çš„ä¸»è¦æ€è·¯å…¶å®æ˜¯å¾ˆç®€å•çš„ã€‚ MutipleMeta å…ƒç±»ä½¿ç”¨å®ƒçš„ __prepare__() æ–¹æ³• æ¥æä¾›ä¸€ä¸ªä½œä¸º MultiDict å®ä¾‹çš„è‡ªå®šä¹‰å­—å…¸ã€‚è¿™ä¸ªè·Ÿæ™®é€šå­—å…¸ä¸ä¸€æ ·çš„æ˜¯ï¼Œ MultiDict ä¼šåœ¨å…ƒç´ è¢«è®¾ç½®çš„æ—¶å€™æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨çš„è¯ï¼Œé‡å¤çš„å…ƒç´ ä¼šåœ¨ MultiMethod å®ä¾‹ä¸­åˆå¹¶ã€‚ MultiMethod å®ä¾‹é€šè¿‡æ„å»ºä»ç±»å‹ç­¾ååˆ°å‡½æ•°çš„æ˜ å°„æ¥æ”¶é›†æ–¹æ³•ã€‚ åœ¨è¿™ä¸ªæ„å»ºè¿‡ç¨‹ä¸­ï¼Œå‡½æ•°æ³¨è§£è¢«ç”¨æ¥æ”¶é›†è¿™äº›ç­¾åç„¶åæ„å»ºè¿™ä¸ªæ˜ å°„ã€‚ è¿™ä¸ªè¿‡ç¨‹åœ¨ MultiMethod.register() æ–¹æ³•ä¸­å®ç°ã€‚ è¿™ç§æ˜ å°„çš„ä¸€ä¸ªå…³é”®ç‰¹ç‚¹æ˜¯å¯¹äºå¤šä¸ªæ–¹æ³•ï¼Œæ‰€æœ‰å‚æ•°ç±»å‹éƒ½å¿…é¡»è¦æŒ‡å®šï¼Œå¦åˆ™å°±ä¼šæŠ¥é”™ã€‚ ä¸ºäº†è®© MultiMethod å®ä¾‹æ¨¡æ‹Ÿä¸€ä¸ªè°ƒç”¨ï¼Œå®ƒçš„ call () æ–¹æ³•è¢«å®ç°äº†ã€‚ è¿™ä¸ªæ–¹æ³•ä»æ‰€æœ‰æ’é™¤ self çš„å‚æ•°ä¸­æ„å»ºä¸€ä¸ªç±»å‹å…ƒç»„ï¼Œåœ¨å†…éƒ¨mapä¸­æŸ¥æ‰¾è¿™ä¸ªæ–¹æ³•ï¼Œ ç„¶åè°ƒç”¨ç›¸åº”çš„æ–¹æ³•ã€‚ä¸ºäº†èƒ½è®© MultiMethod å®ä¾‹åœ¨ç±»å®šä¹‰æ—¶æ­£ç¡®æ“ä½œï¼Œ get ()` æ˜¯å¿…é¡»å¾—å®ç°çš„ã€‚ å®ƒè¢«ç”¨æ¥æ„å»ºæ­£ç¡®çš„ç»‘å®šæ–¹æ³•ã€‚ ä¸è¿‡æœ¬èŠ‚çš„å®ç°è¿˜æœ‰ä¸€äº›é™åˆ¶ï¼Œå…¶ä¸­ä¸€ä¸ªæ˜¯å®ƒä¸èƒ½ä½¿ç”¨å…³é”®å­—å‚æ•°ã€‚ åŒæ ·å¯¹äºç»§æ‰¿ä¹Ÿæ˜¯æœ‰é™åˆ¶çš„ï¼Œä¾‹å¦‚ï¼Œç±»ä¼¼ä¸‹é¢è¿™ç§ä»£ç å°±ä¸èƒ½æ­£å¸¸å·¥ä½œï¼š class A : pass class B ( A ): pass class C : pass class Spam ( metaclass = MultipleMeta ): def foo ( self , x : A ): print ( 'Foo 1:' , x ) def foo ( self , x : C ): print ( 'Foo 2:' , x ) åŸå› æ˜¯å› ä¸º x:A æ³¨è§£ä¸èƒ½æˆåŠŸåŒ¹é…å­ç±»å®ä¾‹ï¼ˆæ¯”å¦‚Bçš„å®ä¾‹ï¼‰ï¼Œå¦‚ä¸‹ï¼š >>> s = Spam () >>> a = A () >>> s . foo ( a ) Foo 1 : < __main__ . A object at 0x1006a5310 > >>> c = C () >>> s . foo ( c ) Foo 2 : < __main__ . C object at 0x1007a1910 > >>> b = B () >>> s . foo ( b ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"multiple.py\" , line 44 , in __call__ raise TypeError ( 'No matching method for types {} ' . format ( types )) TypeError : No matching method for types ( < class ' __main__ . B '>,) Additional","tags":"Python","title":"Pythonicçš„æ³›å‡½æ•°"},{"url":"python-memoryview-and-annotation-ideas.html","text":"Description Memoryview (å†…å­˜è§†å›¾)æ˜¯ä¸€ä¸ªå†…ç½®ç±»ï¼Œå®ƒèƒ½è®©ç”¨æˆ·åœ¨ä¸å¤åˆ¶å†…å®¹çš„æƒ…å†µä¸‹æ“ä½œåŒä¸€ä¸ªæ•°ç»„çš„ä¸åŒåˆ‡ç‰‡ã€‚memoryview çš„æ¦‚å¿µå—åˆ°äº† NumPy çš„å¯å‘ï¼ˆå‚è§ 2.9.3 èŠ‚ï¼‰ã€‚Travis Oliphant æ˜¯ NumPy çš„ä¸»è¦ä½œè€…ï¼Œä»–åœ¨å›ç­”\" When should a memoryview be used?\" [link](http://stackoverflow.com/questions/4845418/when-should-a-memoryview-be-used/ï¼‰è¿™ä¸ªé—®é¢˜æ—¶æ˜¯è¿™æ ·è¯´çš„ï¼š å†…å­˜è§†å›¾å…¶å®æ˜¯æ³›åŒ–å’Œå»æ•°å­¦åŒ–çš„ NumPy æ•°ç»„ã€‚å®ƒè®©ä½ åœ¨ä¸éœ€è¦å¤åˆ¶å†…å®¹çš„å‰æä¸‹ï¼Œåœ¨æ•°æ®ç»“æ„ä¹‹é—´å…±äº«å†…å­˜ã€‚å…¶ä¸­æ•°æ®ç»“æ„å¯ä»¥æ˜¯ä»»ä½•å½¢å¼ï¼Œæ¯”å¦‚ PIL å›¾ç‰‡ã€SQLite æ•°æ®åº“å’Œ NumPy çš„æ•°ç»„ï¼Œç­‰ç­‰ã€‚è¿™ä¸ªåŠŸèƒ½åœ¨å¤„ç†å¤§å‹æ•°æ®é›†åˆçš„æ—¶å€™éå¸¸é‡è¦ã€‚ memoryview.cast çš„æ¦‚å¿µè·Ÿæ•°ç»„æ¨¡å—ç±»ä¼¼ï¼Œèƒ½ç”¨ä¸åŒçš„æ–¹å¼è¯»å†™åŒä¸€å—å†…å­˜æ•°æ®ï¼Œè€Œä¸”å†…å®¹å­—èŠ‚ä¸ä¼šéšæ„ç§»åŠ¨ã€‚è¿™å¬ä¸Šå»åˆè·Ÿ C è¯­è¨€ä¸­ç±»å‹è½¬æ¢çš„æ¦‚å¿µå·®ä¸å¤šã€‚memoryview.cast ä¼šæŠŠåŒä¸€å—å†…å­˜é‡Œçš„å†…å®¹æ‰“åŒ…æˆä¸€ä¸ªå…¨æ–°çš„ memoryview å¯¹è±¡ç»™ä½ ã€‚ Python 3 æä¾›äº†ä¸€ç§å¥æ³•ï¼Œç”¨äºä¸ºå‡½æ•°å£°æ˜ä¸­çš„å‚æ•°å’Œè¿”å›å€¼é™„åŠ å…ƒæ•°æ®ã€‚ å‚è€ƒæ–‡çŒ®2 ä¸­æè¿°äº†pythonå¼•å…¥annotationsçš„ä¸€ç§è§£é‡Šã€‚ Python å¯¹æ³¨è§£æ‰€åšçš„å”¯ä¸€çš„äº‹æƒ…æ˜¯ï¼ŒæŠŠå®ƒä»¬å­˜å‚¨åœ¨å‡½æ•°çš„ annotations å±æ€§é‡Œã€‚ä»…æ­¤è€Œå·²ï¼ŒPython ä¸åšæ£€æŸ¥ã€ä¸åšå¼ºåˆ¶ã€ä¸åšéªŒè¯ï¼Œä»€ä¹ˆæ“ä½œéƒ½ä¸åšã€‚æ¢å¥è¯è¯´ï¼Œæ³¨è§£å¯¹ Python è§£é‡Šå™¨æ²¡æœ‰ä»»ä½•æ„ä¹‰ã€‚æ³¨è§£åªæ˜¯å…ƒæ•°æ®ï¼Œå¯ä»¥ä¾› IDEã€æ¡†æ¶å’Œè£…é¥°å™¨ç­‰å·¥å…·ä½¿ç”¨ã€‚å³ä¾¿æ²¡æœ‰å¼ºåˆ¶è¯­ä¹‰ï¼Œæˆ‘ä»¬ä¾ç„¶å¯ä»¥åˆ©ç”¨æ³¨è§£æ¥è§„èŒƒå‡½æ•°è¾“å…¥ã€‚ ä½¿ç”¨Memoryviewå¯¼å…¥æ–‡ä»¶å­—ç¬¦æµ åœ¨è¿™é‡Œæˆ‘ä»¬æ¯”è¾ƒäº†ä¸‰ç§è¯»å–å­—èŠ‚æµçš„æ–¹å¼ã€‚åä¸¤ç§æ–¹æ³•èƒ½å‡å°‘ä¸€æ¬¡æ•°æ®çš„æ‹·è´ï¼Œä½†ä»¤äººæƒŠè®¶çš„æ˜¯ï¼Œä½¿ç”¨memoryviewå¹¶æ²¡æœ‰æé«˜è¯»å–ç¨‹åºçš„æ•ˆç‡å’Œé€Ÿåº¦ã€‚ å¦‚æœè¦è¿›è¡Œæœ¬åœ°æµ‹è¯•çš„è¯ï¼Œè¯·å°†FILENAMEæ”¹ä¸ºä½ æœ¬åœ°ç¯å¢ƒä¸­çš„å¤§æ–‡ä»¶çš„è·¯å¾„ã€‚ ä»£ç ï¼š import os from time import time ### å¤§æ–‡ä»¶è·¯å¾„ FILENAME = r 'C:\\Users\\chu060\\Downloads\\ubuntu-16.04.2-desktop-i386.iso' def test_load_file_copy (): \"\"\"ä½¿ç”¨æ™®é€šçš„è¯»å–å­—èŠ‚æµçš„æ–¹å¼ï¼Œè¯¥æ–¹å¼ä¼šè¿›è¡Œä¸€æ¬¡æ‹·è´\"\"\" f = open ( FILENAME , 'rb' ) buf = bytearray ( f . read ()) f . close () return buf [: 100 ] def test_load_file_mv (): \"\"\"memoryviewæµ‹è¯•\"\"\" f = open ( FILENAME , 'rb' ) buf = bytearray ( os . path . getsize ( FILENAME )) mv = memoryview ( buf ) f . readinto ( mv ) f . close () return buf [: 100 ] def test_load_file_ba (): \"\"\"æ— memoryviewï¼Œä½¿ç”¨bytearray\"\"\" f = open ( FILENAME , 'rb' ) buf = bytearray ( os . path . getsize ( FILENAME )) f . readinto ( buf ) f . close () return buf [: 100 ] def load_tester ( func , n = 3 ): \"\"\"è¿›è¡Œæµ‹è¯•å¹¶è¾“å‡ºç»“æœ\"\"\" print ( '=' * 50 ) start = time () for i in range ( n ): result = func () if i == 0 : print ( result ) print ( 'try {test_times} times, {name} avg running time: {avg_time} ' . format ( test_times = n , name = func . __name__ , avg_time = str (( time () - start ) / n ))) ### è·å–æ‰€æœ‰å¾…æµ‹å‡½æ•° test_funcs = [ globals ()[ name ] for name in globals () if name . startswith ( 'test' )] ### è¿›è¡Œæµ‹è¯•,æ­¤å¤„å–åæ¬¡æµ‹è¯•çš„å¹³å‡å€¼ for func in test_funcs : load_tester ( func , 10 ) source file è¿è¡Œç»“æœä¸ºï¼š ================================================== bytearray(b'3\\xed\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x9 0\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x903\\xed\\xfa\\x8e\\xd5\\xbc\\x 00|\\xfb\\xfcf1\\xdbf1\\xc9fSfQ\\x06W\\x8e\\xdd\\x8e\\xc5R\\xbe\\x00|\\xbf\\x00\\x06\\xb9\\x00\\x 01\\xf3\\xa5\\xeaK\\x06\\x00\\x00R\\xb4A\\xbb\\xaaU1\\xc90\\xf6\\xf9\\xcd\\x13r\\x16\\x81\\xfbU\\x aau\\x10\\x83\\xe1\\x01t') try 10 times, test_load_file_ba avg running time: 0.9056999921798706 ================================================== bytearray(b'3\\xed\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x9 0\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x903\\xed\\xfa\\x8e\\xd5\\xbc\\x 00|\\xfb\\xfcf1\\xdbf1\\xc9fSfQ\\x06W\\x8e\\xdd\\x8e\\xc5R\\xbe\\x00|\\xbf\\x00\\x06\\xb9\\x00\\x 01\\xf3\\xa5\\xeaK\\x06\\x00\\x00R\\xb4A\\xbb\\xaaU1\\xc90\\xf6\\xf9\\xcd\\x13r\\x16\\x81\\xfbU\\x aau\\x10\\x83\\xe1\\x01t') try 10 times, test_load_file_copy avg running time: 1.3784000158309937 ================================================== bytearray(b'3\\xed\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x9 0\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x903\\xed\\xfa\\x8e\\xd5\\xbc\\x 00|\\xfb\\xfcf1\\xdbf1\\xc9fSfQ\\x06W\\x8e\\xdd\\x8e\\xc5R\\xbe\\x00|\\xbf\\x00\\x06\\xb9\\x00\\x 01\\xf3\\xa5\\xeaK\\x06\\x00\\x00R\\xb4A\\xbb\\xaaU1\\xc90\\xf6\\xf9\\xcd\\x13r\\x16\\x81\\xfbU\\x aau\\x10\\x83\\xe1\\x01t') try 10 times, test_load_file_mv avg running time: 0.9180000066757202 ä½¿ç”¨annotationsè¿›è¡Œå‚æ•°æ£€æŸ¥ æˆ‘ä»¬å¯ä»¥ç®€å•å°†annotations(æ³¨è§£)å½“æˆå‡½æ•°å‚æ•°è¯´æ˜æ–‡æ¡£ã€‚æ³¨è§£ä¼šè¢«å‚¨å­˜åœ¨å‡½æ•°çš„__annotations__å±æ€§ä¸­ï¼Œå› æ­¤æˆ‘ä»¬ä¹Ÿå¯ä»¥åˆ©ç”¨è¿™ä¸ªå­—å…¸æ¥åšæ›´å¤šçš„äº‹æƒ…ï¼šæ¯”å¦‚å‚æ•°ç±»å‹ã€æœ‰æ•ˆæ€§çš„æ£€éªŒã€‚ ä»£ç ï¼š def validate ( func , locals ): for var , test in func . __annotations__ . items (): value = locals [ var ] msg = 'Var: {0} \\t Value: {1} \\t Test: {2.__name__} ' . format ( var , value , test ) assert test ( value ), msg def is_int ( x ): return isinstance ( x , int ) def between ( lo , hi ): def _between ( x ): return lo <= x <= hi return _between def f ( x : between ( 3 , 10 ), y : is_int ): validate ( f , locals ()) print ( x , y ) ç»“æœï¼š >>> f(0, 31.1) Traceback (most recent call last): ... AssertionError: Var: y Value: 31.1 Test: is_int Additional å‚è€ƒæ–‡çŒ®: 1. Less Copies in Python with the Buffer Protocol and memoryviews 2. Memoryview Q&A","tags":"Python","title":"Python Memoryview and Annotation Ideas"},{"url":"python-descriptor-behavior.html","text":"Description æè¿°ç¬¦æ˜¯å¯¹å¤šä¸ªå±æ€§è¿ç”¨ç›¸åŒå­˜å–é€»è¾‘çš„ä¸€ç§æ–¹å¼ã€‚ä¾‹å¦‚ï¼ŒDjango ORM å’Œ SQL Alchemy ç­‰ ORM ä¸­çš„å­—æ®µç±»å‹æ˜¯æè¿°ç¬¦ï¼ŒæŠŠæ•°æ®åº“è®°å½•ä¸­å­—æ®µé‡Œçš„æ•°æ®ä¸ Python å¯¹è±¡çš„å±æ€§å¯¹åº”èµ·æ¥ã€‚ æè¿°ç¬¦æ˜¯å®ç°äº†ç‰¹å®šåè®®çš„ç±»ï¼Œè¿™ä¸ªåè®®åŒ…æ‹¬ get ã€ set å’Œ delete æ–¹æ³•ã€‚property ç±»å®ç°äº†å®Œæ•´çš„æè¿°ç¬¦åè®®ã€‚é€šå¸¸ï¼Œå¯ä»¥åªå®ç°éƒ¨åˆ†åè®®ã€‚å…¶å®ï¼Œæˆ‘ä»¬åœ¨çœŸå®çš„ä»£ç ä¸­è§åˆ°çš„å¤§å¤šæ•°æè¿°ç¬¦åªå®ç°äº† get å’Œ set æ–¹æ³•ï¼Œè¿˜æœ‰å¾ˆå¤šåªå®ç°äº†å…¶ä¸­çš„ä¸€ä¸ªã€‚ æè¿°ç¬¦æ˜¯ Python çš„ç‹¬æœ‰ç‰¹å¾ï¼Œä¸ä»…åœ¨åº”ç”¨å±‚ä¸­ä½¿ç”¨ï¼Œåœ¨è¯­è¨€çš„åŸºç¡€è®¾æ–½ä¸­ä¹Ÿæœ‰ç”¨åˆ°ã€‚é™¤äº†ç‰¹æ€§ä¹‹å¤–ï¼Œä½¿ç”¨æè¿°ç¬¦çš„ Python åŠŸèƒ½è¿˜æœ‰æ–¹æ³•åŠ classmethod å’Œ staticmethod è£…é¥°å™¨ã€‚ç†è§£æè¿°ç¬¦æ˜¯ç²¾é€š Python çš„å…³é”®ã€‚ æœ¬æ–‡åœ¨ç®€è¦ä»‹ç»æè¿°ç¬¦çš„åŸºç¡€ä¸Šæ¢è®¨æè¿°ç¬¦åœ¨pythonä¸­çš„æ˜¾éšæ€§ã€‚ æè¿°ç¬¦ç§ç±» åœ¨æ­£å¼æ¢è®¨æè¿°ç¬¦åœ¨pythonä¸­çš„æ˜¾éšæ€§å‰ï¼Œå…ˆäº†è§£ä¸‹ä¸‰ç§æè¿°ç¬¦ã€‚ è¦†ç›–å‹æè¿°ç¬¦ å®ç° set æ–¹æ³•çš„æè¿°ç¬¦å±äºè¦†ç›–å‹æè¿°ç¬¦ï¼Œå› ä¸ºè™½ç„¶æè¿°ç¬¦æ˜¯ç±»å±æ€§ï¼Œä½†æ˜¯å®ç° set æ–¹æ³•çš„è¯ï¼Œä¼šè¦†ç›–å¯¹å®ä¾‹å±æ€§çš„èµ‹å€¼æ“ä½œã€‚ æ²¡æœ‰ get æ–¹æ³•çš„è¦†ç›–å‹æè¿°ç¬¦ é€šå¸¸ï¼Œè¦†ç›–å‹æè¿°ç¬¦æ—¢ä¼šå®ç° set æ–¹æ³•ï¼Œä¹Ÿä¼šå®ç° get æ–¹æ³•ï¼Œä¸è¿‡ä¹Ÿå¯ä»¥åªå®ç° set æ–¹æ³•ï¼Œæ­¤æ—¶ï¼Œåªæœ‰å†™æ“ä½œç”±æè¿°ç¬¦å¤„ç†ã€‚é€šè¿‡å®ä¾‹è¯»å–æè¿°ç¬¦ä¼šè¿”å›æè¿°ç¬¦å¯¹è±¡æœ¬èº«ï¼Œå› ä¸ºæ²¡æœ‰å¤„ç†è¯»æ“ä½œçš„ get æ–¹æ³•ã€‚å¦‚æœç›´æ¥é€šè¿‡å®ä¾‹çš„ dict å±æ€§åˆ›å»ºåŒåå®ä¾‹å±æ€§ï¼Œä»¥åå†è®¾ç½®é‚£ä¸ªå±æ€§æ—¶ï¼Œä»ä¼šç”± set æ–¹æ³•æ’æ‰‹æ¥ç®¡ï¼Œä½†æ˜¯è¯»å–é‚£ä¸ªå±æ€§çš„è¯ï¼Œå°±ä¼šç›´æ¥ä»å®ä¾‹ä¸­è¿”å›æ–°èµ‹äºˆçš„å€¼ï¼Œè€Œä¸ä¼šè¿”å›æè¿°ç¬¦å¯¹è±¡ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ä¾‹å±æ€§ä¼šé®ç›–æè¿°ç¬¦ï¼Œä¸è¿‡åªæœ‰è¯»æ“ä½œæ˜¯å¦‚æ­¤ã€‚ éè¦†ç›–å‹æè¿°ç¬¦ æ²¡æœ‰å®ç° set æ–¹æ³•çš„æè¿°ç¬¦æ˜¯éè¦†ç›–å‹æè¿°ç¬¦ã€‚å¦‚æœè®¾ç½®äº†åŒåçš„å®ä¾‹å±æ€§ï¼Œæè¿°ç¬¦ä¼šè¢«é®ç›–ï¼Œè‡´ä½¿æè¿°ç¬¦æ— æ³•å¤„ç†é‚£ä¸ªå®ä¾‹çš„é‚£ä¸ªå±æ€§ã€‚æ–¹æ³•æ˜¯ä»¥éè¦†ç›–å‹æè¿°ç¬¦å®ç°çš„ã€‚ Pythonå±æ€§æŸ¥æ‰¾ç­–ç•¥ ä¼˜å…ˆæ‰¾åˆ°Pythonè‡ªåŠ¨äº§ç”Ÿçš„å±æ€§ã€‚ æŸ¥æ‰¾obj. class . dict ï¼Œå¦‚æœattrå­˜åœ¨å¹¶ä¸”æ˜¯è¦†ç›–å‹æè¿°ç¬¦ï¼Œè¿”å›è¦†ç›–å‹æè¿°ç¬¦çš„__get__æ–¹æ³•çš„ç»“æœï¼Œå¦‚æœæ²¡æœ‰ç»§ç»­åœ¨obj. class çš„çˆ¶ç±»ä»¥åŠç¥–å…ˆç±»ä¸­å¯»æ‰¾è¦†ç›–å‹æè¿°ç¬¦ã€‚ åœ¨obj. dict ä¸­æŸ¥æ‰¾ï¼Œè¿™ä¸€æ­¥åˆ†ä¸¤ç§æƒ…å†µï¼Œç¬¬ä¸€ç§æƒ…å†µæ˜¯objæ˜¯ä¸€ä¸ªæ™®é€šå®ä¾‹ï¼Œæ‰¾åˆ°å°±ç›´æ¥è¿”å›ï¼Œæ‰¾ä¸åˆ°è¿›è¡Œä¸‹ä¸€æ­¥ã€‚ç¬¬äºŒç§æƒ…å†µæ˜¯objæ˜¯ä¸€ä¸ªç±»ï¼Œä¾æ¬¡åœ¨objå’Œå®ƒçš„çˆ¶ç±»ã€ç¥–å…ˆç±»çš„__dict__ä¸­æŸ¥æ‰¾ï¼Œå¦‚æœæ‰¾åˆ°ä¸€ä¸ªæè¿°ç¬¦å°±è¿”å›æè¿°ç¬¦çš„__get__æ–¹æ³•çš„ç»“æœï¼Œå¦åˆ™ç›´æ¥è¿”å›attrã€‚å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œè¿›è¡Œä¸‹ä¸€æ­¥ã€‚ åœ¨obj. class . dict ä¸­æŸ¥æ‰¾ï¼Œå¦‚æœæ‰¾åˆ°äº†ä¸€ä¸ªæè¿°ç¬¦(è¿™é‡Œçš„æè¿°ç¬¦ä¸€å®šæ˜¯éè¦†ç›–å‹æè¿°ç¬¦)ï¼Œè¿”å›æè¿°ç¬¦çš„__get__æ–¹æ³•çš„ç»“æœã€‚å¦‚æœæ‰¾åˆ°ä¸€ä¸ªæ™®é€šå±æ€§ï¼Œç›´æ¥è¿”å›å±æ€§å€¼ã€‚å¦‚æœæ²¡æœ‰ç»§ç»­åœ¨obj. class çš„çˆ¶ç±»ä»¥åŠç¥–å…ˆç±»ä¸­å¯»æ‰¾éè¦†ç›–å‹æè¿°ç¬¦ã€‚ å¾ˆä¸å¹¸ï¼ŒPythonç»ˆäºå—ä¸äº†ã€‚åœ¨è¿™ä¸€æ­¥ï¼Œå®ƒraise AttributeError ã€‚ ä»£ç éªŒè¯ æ¥ä¸‹æ¥æˆ‘ä»¬ç¼–å†™ç¤ºä¾‹ä»£ç æ¥å¯¹ä»¥ä¸Šç­–ç•¥è¿›è¡ŒéªŒè¯ã€‚ \"\"\" è¦†ç›–å‹æè¿°ç¬¦: >>> obj = Model() >>> obj.__dict__['over'] = 'obj instance property over' >>> obj.over # doctest: +ELLIPSIS Overriding.__get__() invoked with args: self = <descriptorkinds.Overriding object at 0x...> instance = <descriptorkinds.Model object at 0x...> owner = <class 'descriptorkinds.Model'> >>> Model.over # doctest: +ELLIPSIS Overriding.__get__() invoked with args: self = <descriptorkinds.Overriding object at 0x...> instance = None owner = <class 'descriptorkinds.Model'> >>> sub_obj = SubClass() >>> sub_obj.__dict__['over'] = 'sub_obj instance property over' >>> sub_obj.over # doctest: +ELLIPSIS Overriding.__get__() invoked with args: self = <descriptorkinds.Overriding object at 0x...> instance = <descriptorkinds.SubClass object at 0x...> owner = <class 'descriptorkinds.SubClass'> >>> SubClass.over # doctest: +ELLIPSIS Overriding.__get__() invoked with args: self = <descriptorkinds.Overriding object at 0x...> instance = None owner = <class 'descriptorkinds.SubClass'> #è¡Œä¸ºå®Œå…¨ç¬¦åˆç­–ç•¥2ã€‚é¢å¤–çš„ï¼Œè¿™é‡Œæµ‹è¯•äº†è·å–ç±»å±æ€§æ—¶ä¼ å…¥å‚æ•°çš„å€¼ã€‚ æ²¡æœ‰ __get__ æ–¹æ³•çš„è¦†ç›–å‹æè¿°ç¬¦: >>> obj.__dict__['over_no_get'] = 'obj instance property over_no_get' >>> obj.over_no_get # doctest: +ELLIPSIS 'obj instance property over_no_get' >>> sub_obj.over_no_get # doctest: +ELLIPSIS <descriptorkinds.OverridingNoGet object at 0x...> >>> sub_obj.__dict__['over_no_get'] = 'sub_obj instance property over_no_get' >>> sub_obj.over_no_get # doctest: +ELLIPSIS 'sub_obj instance property over_no_get' #è¡Œä¸ºç¬¦åˆç­–ç•¥4ã€‚å…¶è¡Œä¸ºæ›´åƒéè¦†ç›–å‹æè¿°ç¬¦ã€‚ä½†æ— æ³•ç›´æ¥ä½¿ç”¨obj.over_no_getçš„æ–¹å¼ç»™å®ä¾‹å±æ€§èµ‹å€¼ã€‚ éè¦†ç›–å‹æè¿°ç¬¦ï¼š >>> obj.non_over # doctest: +ELLIPSIS NonOverriding.__get__() invoked with args: self = <descriptorkinds.NonOverriding object at 0x...> instance = <descriptorkinds.Model object at 0x...> owner = <class 'descriptorkinds.Model'> >>> obj.non_over = 'obj instance property non_over' >>> obj.non_over # doctest: +ELLIPSIS 'obj instance property non_over' >>> sub_obj.non_over # doctest: +ELLIPSIS NonOverriding.__get__() invoked with args: self = <descriptorkinds.NonOverriding object at 0x...> instance = <descriptorkinds.SubClass object at 0x...> owner = <class 'descriptorkinds.SubClass'> >>> sub_obj.__dict__['non_over'] = 'sub_obj instance property non_over' >>> sub_obj.non_over # doctest: +ELLIPSIS 'sub_obj instance property non_over' #è¡Œä¸ºç¬¦åˆç­–ç•¥4ã€‚ \"\"\" ### BEGIN DESCRIPTORKINDS def print_args ( name , * args ): # <1> cls_name = args [ 0 ] . __class__ . __name__ arg_names = [ 'self' , 'instance' , 'owner' ] if name == 'set' : arg_names [ - 1 ] = 'value' print ( ' {} .__ {} __() invoked with args:' . format ( cls_name , name )) for arg_name , value in zip ( arg_names , args ): print ( ' {:8} = {} ' . format ( arg_name , value )) class Overriding : # <2> \"\"\"a.k.a. data descriptor or enforced descriptor\"\"\" def __get__ ( self , instance , owner ): print_args ( 'get' , self , instance , owner ) # <3> def __set__ ( self , instance , value ): print_args ( 'set' , self , instance , value ) class OverridingNoGet : # <4> \"\"\"an overriding descriptor without ``__get__``\"\"\" def __set__ ( self , instance , value ): print_args ( 'set' , self , instance , value ) class NonOverriding : # <5> \"\"\"a.k.a. non-data or shadowable descriptor\"\"\" def __get__ ( self , instance , owner ): print_args ( 'get' , self , instance , owner ) class Model : # <6> over = Overriding () over_no_get = OverridingNoGet () non_over = NonOverriding () def spam ( self ): # <7> print ( 'Model.spam() invoked with arg:' ) print ( ' self =' , self ) class SubClass ( Model ): def spam ( self ): print ( 'SubClass.spam() invoked with arg:' ) print ( ' self =' , self ) å¦å¤–ï¼Œåœ¨ç±»ä¸­å®šä¹‰çš„å‡½æ•°å±äºç»‘å®šæ–¹æ³•ï¼ˆbound methodï¼‰ï¼Œå› ä¸ºç”¨æˆ·å®šä¹‰çš„å‡½æ•°éƒ½æœ‰ get æ–¹æ³•ï¼Œæ‰€ä»¥ä¾é™„åˆ°ç±»ä¸Šæ—¶ï¼Œå°±ç›¸å½“äºæè¿°ç¬¦ã€‚ \"\"\" ### BEGIN FUNC_DESCRIPTOR_DEMO >>> word = Text('forward') >>> word # <1> Text('forward') >>> word.reverse() # <2> Text('drawrof') >>> Text.reverse(Text('backward')) # <3> Text('drawkcab') >>> type(Text.reverse), type(word.reverse) # <4> (<class 'function'>, <class 'method'>) >>> list(map(Text.reverse, ['repaid', (10, 20, 30), Text('stressed')])) # <5> ['diaper', (30, 20, 10), Text('desserts')] >>> Text.reverse.__get__(word) # <6> <bound method Text.reverse of Text('forward')> >>> Text.reverse.__get__(None, Text) # <7> <function Text.reverse at 0x101244e18> >>> word.reverse # <8> <bound method Text.reverse of Text('forward')> >>> word.reverse.__self__ # <9> Text('forward') >>> word.reverse.__func__ is Text.reverse # <10> True ### END FUNC_DESCRIPTOR_DEMO \"\"\" ### BEGIN FUNC_DESCRIPTOR_EX import collections class Text ( collections . UserString ): def __repr__ ( self ): return 'Text( {!r} )' . format ( self . data ) def reverse ( self ): return self [:: - 1 ] ### END FUNC_DESCRIPTOR_EX æ€»ç»“ æè¿°ç¬¦çš„ä½œç”¨æ–¹å¼å¯ç”¨ä»¥ä¸‹å‡½æ•°è¡¨ç¤ºï¼š x = C () x . foo ==> if hasattr ( C , 'foo' ): d = C . foo ; D = d . __class__ if hasattr ( D , '__get__' ) and ( hasattr ( D , '__set__' ) or 'foo' not in x . __dict__ ): return D . __get__ ( d , x , C ) return x . __dict__ [ 'foo' ] # or from C, &c Additional æè¿°ç¬¦ç”¨æ³•å»ºè®®ï¼š 1.ä½¿ç”¨ç‰¹æ€§ä»¥ä¿æŒç®€å• å†…ç½®çš„ property ç±»åˆ›å»ºçš„å…¶å®æ˜¯è¦†ç›–å‹æè¿°ç¬¦ï¼Œ set æ–¹æ³•å’Œ get æ–¹æ³•éƒ½å®ç°äº†ï¼Œå³ä¾¿ä¸å®šä¹‰è®¾å€¼æ–¹æ³•ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ç‰¹æ€§çš„ set æ–¹æ³•é»˜è®¤æŠ›å‡º AttributeError: can't set attributeï¼Œå› æ­¤åˆ›å»ºåªè¯»å±æ€§æœ€ç®€å•çš„æ–¹å¼æ˜¯ä½¿ç”¨ç‰¹æ€§ï¼Œè¿™èƒ½é¿å…ä¸‹ä¸€æ¡æ‰€è¿°çš„é—®é¢˜ã€‚ 2.åªè¯»æè¿°ç¬¦å¿…é¡»æœ‰ set æ–¹æ³• å¦‚æœä½¿ç”¨æè¿°ç¬¦ç±»å®ç°åªè¯»å±æ€§ï¼Œè¦è®°ä½ï¼Œ get å’Œ set ä¸¤ä¸ªæ–¹æ³•å¿…é¡»éƒ½å®šä¹‰ï¼Œå¦åˆ™ï¼Œå®ä¾‹çš„åŒåå±æ€§ä¼šé®ç›–æè¿°ç¬¦ã€‚åªè¯»å±æ€§çš„ set æ–¹æ³•åªéœ€æŠ›å‡º AttributeError å¼‚å¸¸ï¼Œå¹¶æä¾›åˆé€‚çš„é”™è¯¯æ¶ˆæ¯ã€‚ 3.ç”¨äºéªŒè¯çš„æè¿°ç¬¦å¯ä»¥åªæœ‰ set æ–¹æ³• å¯¹ä»…ç”¨äºéªŒè¯çš„æè¿°ç¬¦æ¥è¯´ï¼Œ set æ–¹æ³•åº”è¯¥æ£€æŸ¥ value å‚æ•°è·å¾—çš„å€¼ï¼Œå¦‚æœæœ‰æ•ˆï¼Œä½¿ç”¨æè¿°ç¬¦å®ä¾‹çš„åç§°ä¸ºé”®ï¼Œç›´æ¥åœ¨å®ä¾‹çš„ dict å±æ€§ä¸­è®¾ç½®ã€‚è¿™æ ·ï¼Œä»å®ä¾‹ä¸­è¯»å–åŒåå±æ€§çš„é€Ÿåº¦å¾ˆå¿«ï¼Œå› ä¸ºä¸ç”¨ç»è¿‡ get æ–¹æ³•å¤„ç†ã€‚ 4 ä»…æœ‰ get æ–¹æ³•çš„æè¿°ç¬¦å¯ä»¥å®ç°é«˜æ•ˆç¼“å­˜ å¦‚æœåªç¼–å†™äº† get æ–¹æ³•ï¼Œé‚£ä¹ˆåˆ›å»ºçš„æ˜¯éè¦†ç›–å‹æè¿°ç¬¦ã€‚è¿™ç§æè¿°ç¬¦å¯ç”¨äºæ‰§è¡ŒæŸäº›è€—è´¹èµ„æºçš„è®¡ç®—ï¼Œç„¶åä¸ºå®ä¾‹è®¾ç½®åŒåå±æ€§ï¼Œç¼“å­˜ç»“æœã€‚åŒåå®ä¾‹å±æ€§ä¼šé®ç›–æè¿°ç¬¦ï¼Œå› æ­¤åç»­è®¿é—®ä¼šç›´æ¥ä»å®ä¾‹çš„ dict å±æ€§ä¸­è·å–å€¼ï¼Œè€Œä¸ä¼šå†è§¦å‘æè¿°ç¬¦çš„ get æ–¹æ³•ã€‚ 5.éç‰¹æ®Šçš„æ–¹æ³•å¯ä»¥è¢«å®ä¾‹å±æ€§é®ç›– ç”±äºå‡½æ•°å’Œæ–¹æ³•åªå®ç°äº† get æ–¹æ³•ï¼Œå®ƒä»¬ä¸ä¼šå¤„ç†åŒåå®ä¾‹å±æ€§çš„èµ‹å€¼æ“ä½œã€‚å› æ­¤ï¼Œåƒ my_obj.the_method = 7 è¿™æ ·ç®€å•èµ‹å€¼ä¹‹åï¼Œåç»­é€šè¿‡è¯¥å®ä¾‹è®¿é—® the_method å¾—åˆ°çš„æ˜¯æ•°å­— 7â€”â€”ä½†æ˜¯ä¸å½±å“ç±»æˆ–å…¶ä»–å®ä¾‹ã€‚ç„¶è€Œï¼Œç‰¹æ®Šæ–¹æ³•ä¸å—è¿™ä¸ªé—®é¢˜çš„å½±å“ã€‚è§£é‡Šå™¨åªä¼šåœ¨ç±»ä¸­å¯»æ‰¾ç‰¹æ®Šçš„æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œrepr(x) æ‰§è¡Œçš„å…¶å®æ˜¯ x. class . repr (x)ï¼Œå› æ­¤ x çš„ repr å±æ€§å¯¹ repr(x) æ–¹æ³•è°ƒç”¨æ²¡æœ‰å½±å“ã€‚å‡ºäºåŒæ ·çš„åŸå› ï¼Œå®ä¾‹çš„ getattr å±æ€§ä¸ä¼šç ´åå¸¸è§„çš„å±æ€§è®¿é—®è§„åˆ™ã€‚","tags":"Python","title":"Python Descriptor Behavior"},{"url":"python-coroutine-example-rock-paper-scissors.html","text":"Description æœ¬ä»£ç æ¥è‡ªIan Wardçš„Jupyter Notebook -- \"Iterables, Iterators, and Generators\" æ•™ç¨‹ï¼Œå®ç°äº†å‰ªåˆ€çŸ³å¤´å¸ƒçš„æ¸¸æˆã€‚ é¢„æ¿€åç¨‹ The flow is always the same when working with generators. a generator object is created by the caller the caller starts the generator the generator passes data to the caller (or signals the end of the sequence) the caller passes data to the generator repeat from (3) For generators that are driven by input to .send() no data is transferred in the first 3 steps above. This is a decorator that arranges for .next() to be called once immediately after a generator is created. This will turn a generator function into a function that returns a generator immediately ready to receive data (step 4). def advance_generator_once ( original_fn ): \"decorator to advance a generator once immediately after it is created\" def actual_call ( * args , ** kwargs ): gen = original_fn ( * args , ** kwargs ) assert gen . next () is None return gen return actual_call å®ä¾‹åç¨‹ As shown, one of the ways to pass a message to a generator is with .send(). This interface allows you to pass a single object to a generator. For this object we can pass tuples, dicts or anything else we choose. You decide the protocol for your generator by documenting the types and values of objects you will send from caller to generator and yield from generator to caller. Tuples are perfect for a generator that needs two objects each time, e.g. a player number and a key press. This is a Rock-Paper-Scissors game where each player's play is passed in separately, and once both players have played the result of the game is yielded. Players can change their mind choose a different play if the other player hasn't chosen yet. Games will continue indefinitately. This generator uses a common pattern of storing the result that will be yielded in a local variable so that there are fewer yield statements in the generator function. Having fewer yield statements makes it easier to understand where it is possible for execution to be paused within the generator function. The outer while loop runs once for each full game. The inner while loop collects input from the users until the game result can be decided. @advance_generator_once def rock_paper_scissors (): \"\"\" coroutine for playing rock-paper-scissors yields: 'invalid key': invalid input was sent ('win', player, choice0, choice1): when a player wins ('tie', None, choice0, choice1): when there is a tie None: when waiting for more input accepts to .send(): (player, key): player is 0 or 1, key is a character in 'rps' \"\"\" valid = 'rps' wins = 'rs' , 'sp' , 'pr' result = None while True : chosen = [ None , None ] while None in chosen : player , play = yield result result = None if play in valid : chosen [ player ] = play else : result = 'invalid key' if chosen [ 0 ] + chosen [ 1 ] in wins : result = ( 'win' , 0 ) + tuple ( chosen ) elif chosen [ 1 ] + chosen [ 0 ] in wins : result = ( 'win' , 1 ) + tuple ( chosen ) else : result = ( 'tie' , None ) + tuple ( chosen ) Additional å‚è€ƒæ–‡çŒ®: 1. æºæ•™ç¨‹","tags":"Python","title":"Python Coroutine Example -- Rock Paper Scissors"},{"url":"python-coroutine-example-game-of-life.html","text":"Description æœ¬æ–‡æ‰€åˆ—ä»£ç å®ç°äº† John Conway å‘æ˜çš„\"ç”Ÿå‘½æ¸¸æˆ\"ï¼ˆhttps://en.wikipedia.org/wiki/Conway%27s_Game_of_Lifeï¼‰ï¼Œä½¿ç”¨åç¨‹ç®¡ç†æ¸¸æˆè¿è¡Œè¿‡ç¨‹ä¸­å„ä¸ªç»†èƒçš„çŠ¶æ€ã€‚ æºè‡ªBrett Slatkin å†™çš„ã€ŠEffective Pythonï¼šç¼–å†™é«˜è´¨é‡ Python ä»£ç çš„ 59 ä¸ªæœ‰æ•ˆæ–¹æ³•ã€‹ä¸€ä¹¦ã€‚ ä»£ç åŠæ³¨é‡Š from collections import namedtuple ALIVE = '*' EMPTY = '-' TICK = object () Query = namedtuple ( 'Query' , 'y x' ) Transition = namedtuple ( 'Transition' , 'y x state' ) def count_neighbors ( y , x ): \"\"\" è·å–é‚»å±…çŠ¶æ€çš„å­åç¨‹ã€‚ è¿”å›å­˜æ´»é‚»å±…çš„æ•°é‡ç»™step_cellçš„neighborå˜é‡ã€‚ \"\"\" n_ = yield Query ( y + 1 , x + 0 ) # North ne = yield Query ( y + 1 , x + 1 ) # Northeast e_ = yield Query ( y + 0 , x + 1 ) # East se = yield Query ( y - 1 , x + 1 ) # Southeast s_ = yield Query ( y - 1 , x + 0 ) # South sw = yield Query ( y - 1 , x - 1 ) # Southwest w_ = yield Query ( y + 0 , x - 1 ) # West nw = yield Query ( y + 1 , x - 1 ) # Northwest neighbor_states = [ n_ , ne , e_ , se , s_ , sw , w_ , nw ] count = 0 for state in neighbor_states : if state == ALIVE : count += 1 return count def game_logic ( state , neighbors ): \"\"\" ç»†èƒè½¬æ¢çš„æ¡ä»¶ã€‚ \"\"\" if state == ALIVE : if neighbors < 2 : return EMPTY # Die: Too few elif neighbors > 3 : return EMPTY # Die: Too many else : if neighbors == 3 : return ALIVE # Regenerate return state def step_cell ( y , x ): \"\"\" å…ˆæŠ›å‡ºç›®æ ‡ç»†èƒè‡ªèº«ï¼Œå†é€ä¸ªæŠ›å‡ºé‚»å±…ã€‚ è·å¾—ä»¥ä¸Šæ‰€æœ‰ç»†èƒçš„çŠ¶æ€ä¹‹åå†æ ¹æ®ç»†èƒè½¬æ¢æ¡ä»¶æŠ›å‡ºç›®æ ‡ç»†èƒ åœ¨ä¸‹ä¸€ä¸–ä»£çš„çŠ¶æ€ã€‚ \"\"\" state = yield Query ( y , x ) neighbors = yield from count_neighbors ( y , x ) next_state = game_logic ( state , neighbors ) yield Transition ( y , x , next_state ) def simulate ( height , width ): \"\"\" ä¸ºgirdçš„æ¯ä¸ªå…ƒç´ æŠ›å‡ºå…¶è‡ªèº«åŠå…¶é‚»å±…ç»™å®¢æˆ·ç¨‹åºã€‚ TICKä¸ºç»ˆæ­¢æ¡ä»¶ã€‚ \"\"\" while True : for y in range ( height ): for x in range ( width ): yield from step_cell ( y , x ) yield TICK class Grid ( object ): \"\"\" ç»†èƒç”Ÿæ´»çš„åœ°æ–¹ã€‚å®ç°äº†getitemå’Œsetitemæ–¹æ³•æ–¹ä¾¿live_a_generationæ–¹æ³•æ“ä½œã€‚ \"\"\" def __init__ ( self , height , width ): self . height = height self . width = width self . rows = [] for _ in range ( self . height ): self . rows . append ([ EMPTY ] * self . width ) def __str__ ( self ): output = '' for row in self . rows : for cell in row : output += cell output += ' \\n ' return output def __getitem__ ( self , position ): y , x = position return self . rows [ y % self . height ][ x % self . width ] def __setitem__ ( self , position , state ): y , x = position self . rows [ y % self . height ][ x % self . width ] = state def live_a_generation ( grid , sim ): \"\"\" ä¸€ä¸–ä»£çš„ç”Ÿå‘½æ¨¡æ‹Ÿã€‚ \"\"\" progeny = Grid ( grid . height , grid . width ) item = next ( sim ) #TICKä¸ºä¸€ä¸–ä»£çš„æ¨¡æ‹Ÿçš„ç»“æŸä¿¡å·ã€‚ while item is not TICK : #å¦‚æœåç¨‹æŠ›å‡ºçš„æ˜¯queryï¼Œåˆ™ä¼ å…¥è¿™ä¸€ä¸–ä»£è¯¥queryå¯¹åº”ç»†èƒçš„å­˜æ´»æƒ…å†µ #å¦‚æœæ˜¯transitionåˆ™è¡¨ç¤ºå¯¹æŸä¸€ç»†èƒçš„è½¬æ¢çŠ¶æ€åˆ¤æ–­å·²å®Œæˆï¼Œæ”¹å˜å…¶å­˜æ´»æƒ…å†µ if isinstance ( item , Query ): state = grid [ item . y , item . x ] item = sim . send ( state ) else : # Must be a Transition progeny [ item . y , item . x ] = item . state item = next ( sim ) return progeny class ColumnPrinter ( object ): \"\"\" å°†æµ‹è¯•ç»“æœæ‰“å°å‡ºæ¥ã€‚ columnsçš„æ¯ä¸ªå…ƒç´ æ˜¯æ¯æ¬¡æ¨¡æ‹Ÿåçš„ç»“æœgridã€‚ \"\"\" def __init__ ( self ): self . columns = [] def append ( self , data ): self . columns . append ( data ) def __str__ ( self ): row_count = 1 for data in self . columns : row_count = max ( row_count , len ( data . splitlines ()) + 1 ) rows = [ '' ] * row_count print ( rows ) for j in range ( row_count ): for i , data in enumerate ( self . columns ): line = data . splitlines ()[ max ( 0 , j - 1 )] if j == 0 : rows [ j ] += str ( i ) . center ( len ( line )) else : rows [ j ] += line if ( i + 1 ) < len ( self . columns ): rows [ j ] += ' | ' return ' \\n ' . join ( rows ) def main (): \"\"\" æµ‹è¯•ä»£ç ã€‚ åˆå§‹ç”Ÿæˆçš„gridä¸ºï¼š ---*----- ----*---- --***---- --------- --------- \"\"\" grid = Grid ( 5 , 9 ) grid [ 0 , 3 ] = ALIVE grid [ 1 , 4 ] = ALIVE grid [ 2 , 2 ] = ALIVE grid [ 2 , 3 ] = ALIVE grid [ 2 , 4 ] = ALIVE columns = ColumnPrinter () sim = simulate ( grid . height , grid . width ) for i in range ( 10 ): columns . append ( str ( grid )) grid = live_a_generation ( grid , sim ) print ( columns ) if __name__ == \"__main__\" : main () Additional å‚è€ƒæ–‡çŒ®: 1. åŸä¹¦ç¤ºä¾‹ 2. åŸä¹¦ä»£ç ","tags":"Python","title":"Python Coroutine Example -- Game of life"},{"url":"flunet-python-167-coroutine-understading.html","text":"Description æ´å¼•è‡ªã€ŠFluent Pythonã€‹16.7èŠ‚ä¸­å…³äºè°ƒç”¨æ–¹é€šè¿‡yield fromå§”æ´¾ç”Ÿæˆå™¨è°ƒç”¨å­ç”Ÿæˆå™¨çš„ä¾‹å­ã€‚å› ä¸ºä¸€ä¸ªä»£ç ç»†èŠ‚é€ æˆäº†å¯¹äºå§”æ´¾ç”Ÿæˆå™¨ç†è§£ä¸Šçš„å›°éš¾ï¼Œå› æ­¤åŸºäºä¸ªäººçš„ç†è§£åšå‡ºç›¸åº”åœ°ä¿®æ”¹æ¥ä¼˜åŒ–è¯¥æ®µä»£ç ã€‚ åŸä¾‹ from collections import namedtuple Result = namedtuple ( 'Result' , 'count average' ) ### the subgenerator def averager (): # <1> total = 0.0 count = 0 average = None while True : term = yield # <2> if term is None : # <3> break total += term count += 1 average = total / count return Result ( count , average ) # <4> ### the delegating generator def grouper ( results , key ): # <5># <6> while True : results [ key ] = yield from averager () # <7> ### the client code, a.k.a. the caller def main ( data ): # <8> results = {} for key , values in data . items (): group = grouper ( results , key ) # <9> next ( group ) # <10> for value in values : group . send ( value ) # <11> group . send ( None ) # important! <12> #print(results) # uncomment to debug report ( results ) ### output report def report ( results ): for key , result in sorted ( results . items ()): group , unit = key . split ( ';' ) print ( ' {:2} {:5} averaging {:.2f}{} ' . format ( result . count , group , result . average , unit )) data = { 'girls;kg' : [ 40.9 , 38.5 , 44.3 , 42.2 , 45.2 , 41.7 , 44.5 , 38.0 , 40.6 , 44.5 ], 'girls;m' : [ 1.6 , 1.51 , 1.4 , 1.3 , 1.41 , 1.39 , 1.33 , 1.46 , 1.45 , 1.43 ], 'boys;kg' : [ 39.0 , 40.8 , 43.2 , 40.8 , 43.1 , 38.6 , 41.4 , 40.6 , 36.3 ], 'boys;m' : [ 1.38 , 1.5 , 1.32 , 1.25 , 1.37 , 1.48 , 1.25 , 1.49 , 1.46 ], } ä¸ç¤ºä¾‹ 16-13 ä¸­çš„ averager åç¨‹ä¸€æ ·ã€‚è¿™é‡Œä½œä¸ºå­ç”Ÿæˆå™¨ä½¿ç”¨ã€‚ main å‡½æ•°ä¸­çš„å®¢æˆ·ä»£ç å‘é€çš„å„ä¸ªå€¼ç»‘å®šåˆ°è¿™é‡Œçš„ term å˜é‡ä¸Šã€‚ è‡³å…³é‡è¦çš„ç»ˆæ­¢æ¡ä»¶ã€‚å¦‚æœä¸è¿™ä¹ˆåšï¼Œä½¿ç”¨ yield from è°ƒç”¨è¿™ä¸ªåç¨‹çš„ç”Ÿæˆå™¨ä¼šæ°¸è¿œé˜»å¡ã€‚ è¿”å›çš„ Result ä¼šæˆä¸º grouper å‡½æ•°ä¸­ yield from è¡¨è¾¾å¼çš„å€¼ã€‚ grouper æ˜¯å§”æ´¾ç”Ÿæˆå™¨ã€‚ è¿™ä¸ªå¾ªç¯æ¯æ¬¡è¿­ä»£æ—¶ä¼šæ–°å»ºä¸€ä¸ª averager å®ä¾‹ï¼›æ¯ä¸ªå®ä¾‹éƒ½æ˜¯ä½œä¸ºåç¨‹ä½¿ç”¨çš„ç”Ÿæˆå™¨å¯¹è±¡ã€‚ grouper å‘é€çš„æ¯ä¸ªå€¼éƒ½ä¼šç»ç”± yield from å¤„ç†ï¼Œé€šè¿‡ç®¡é“ä¼ ç»™ averager å®ä¾‹ã€‚grouper ä¼šåœ¨ yield from è¡¨è¾¾å¼å¤„æš‚åœï¼Œç­‰å¾… averager å®ä¾‹å¤„ç†å®¢æˆ·ç«¯å‘æ¥çš„å€¼ã€‚averager å®ä¾‹è¿è¡Œå®Œæ¯•åï¼Œè¿”å›çš„å€¼ç»‘å®šåˆ° results[key] ä¸Šã€‚while å¾ªç¯ä¼šä¸æ–­åˆ›å»º averager å®ä¾‹ï¼Œå¤„ç†æ›´å¤šçš„å€¼ã€‚ main å‡½æ•°æ˜¯å®¢æˆ·ç«¯ä»£ç ï¼Œç”¨ PEP 380 å®šä¹‰çš„æœ¯è¯­æ¥è¯´ï¼Œæ˜¯\"è°ƒç”¨æ–¹\"ã€‚è¿™æ˜¯é©±åŠ¨ä¸€åˆ‡çš„å‡½æ•°ã€‚ group æ˜¯è°ƒç”¨ grouper å‡½æ•°å¾—åˆ°çš„ç”Ÿæˆå™¨å¯¹è±¡ï¼Œä¼ ç»™ grouper å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ resultsï¼Œç”¨äºæ”¶é›†ç»“æœï¼›ç¬¬äºŒä¸ªå‚æ•°æ˜¯æŸä¸ªé”®ã€‚group ä½œä¸ºåç¨‹ä½¿ç”¨ã€‚ é¢„æ¿€ group åç¨‹ã€‚ æŠŠå„ä¸ª value ä¼ ç»™ grouperã€‚ä¼ å…¥çš„å€¼æœ€ç»ˆåˆ°è¾¾ averager å‡½æ•°ä¸­ term = yield é‚£ä¸€è¡Œï¼›grouper æ°¸è¿œä¸çŸ¥é“ä¼ å…¥çš„å€¼æ˜¯ä»€ä¹ˆã€‚ æŠŠ None ä¼ å…¥ grouperï¼Œå¯¼è‡´å½“å‰çš„ averager å®ä¾‹ç»ˆæ­¢ï¼Œä¹Ÿè®© grouper ç»§ç»­è¿è¡Œï¼Œå†åˆ›å»ºä¸€ä¸ª averager å®ä¾‹ï¼Œå¤„ç†ä¸‹ä¸€ç»„å€¼ã€‚ ç¤ºä¾‹ 16-17 ä¸­æœ€åä¸€ä¸ªæ ‡å·å‰é¢æœ‰ä¸ªæ³¨é‡Šâ€”â€”\"é‡è¦ï¼\"ï¼Œå¼ºè°ƒè¿™è¡Œä»£ç ï¼ˆgroup.send(None)ï¼‰è‡³å…³é‡è¦ï¼šç»ˆæ­¢å½“å‰çš„ averager å®ä¾‹ï¼Œå¼€å§‹æ‰§è¡Œä¸‹ä¸€ä¸ªã€‚å¦‚æœæ³¨é‡Šæ‰é‚£ä¸€è¡Œï¼Œè¿™ä¸ªè„šæœ¬ä¸ä¼šè¾“å‡ºä»»ä½•æŠ¥å‘Šã€‚æ­¤æ—¶ï¼ŒæŠŠ main å‡½æ•°é è¿‘æœ«å°¾çš„ print(results) é‚£è¡Œçš„æ³¨é‡Šå»æ‰ï¼Œä½ ä¼šå‘ç°ï¼Œresults å­—å…¸æ˜¯ç©ºçš„ã€‚ æºç  ç†è§£ä¸å‹˜è¯¯ æ³¨è§£ 6 è¡¨ç¤ºåœ¨å§”æ´¾ç”Ÿæˆå™¨ä¸­å°†ä¼šå¾ªç¯åˆ›å»ºaveragerè¿­ä»£å™¨ã€‚è¿™ä¸€ç‚¹è®©æˆ‘åœ¨ç†è§£èµ·æ¥äº§ç”Ÿäº†æå¤§çš„å›°æƒ‘ã€‚å› ä¸ºä»¥æˆ‘ä¹‹è§å¯¹åº”æ¯ä¸ªkeyï¼Œå§”æ‰˜è¿­ä»£å™¨åªä¼šåœ¨ä¸€ä¸ªå­è¿­ä»£å™¨ä¸­éå†å¹¶è®¡ç®—å¹³å‡å€¼ã€‚ é‚æˆ‘ä»¬å°†while Trueè¯­å¥å»æ‰ï¼Œå½“mainå‡½æ•°çš„forå¾ªç¯å†…ç»™å§”æ‰˜è¿­ä»£å™¨send Noneçš„æ—¶å€™ä¾¿ä¼šæŠ›å‡ºStopIterationå¼‚å¸¸ã€‚ ä¹‹åå°†grouperç”Ÿæˆå™¨æ”¹å†™æˆå¦‚ä¸‹ä¾¿å¯æˆåŠŸè¿è¡Œã€‚ def grouper ( results , key ): results [ key ] = yield from averager () yield åœ¨è¿™é‡Œæ¥å—åˆ°Noneä¹‹åå­è¿­ä»£å™¨averagerè¿­ä»£å™¨ä¹Ÿèƒ½æˆåŠŸè¿”å€¼Resultï¼Œå§”æ‰˜è¿­ä»£å™¨åœ¨ç¬¬äºŒä¸ªyieldå¤„é˜»å¡æ‰€ä»¥ä¸ä¼šæŠ›å‡ºStopIterationå¼‚å¸¸ã€‚ å½“ç„¶ä¹Ÿå¯ä»¥å°†whileè¯­å¥å»æ‰ååœ¨mainå‡½æ•°åŠ å…¥å¼‚å¸¸å¤„ç†æ¥æ•è·StopIterationå¼‚å¸¸ï¼Œè¿™æ ·è¿˜èƒ½çŸ¥é“æ¯ä¸ªå­è¿­ä»£å™¨åœæ­¢çš„æ—¶é—´ã€‚ def main ( data ): results = {} for key , values in data . items (): group = grouper ( results , key ) next ( group ) for value in values : group . send ( value ) try : group . send ( None ) except StopIteration as ex : print ( 'end of child iterater' ) å‡å¦‚ä½¿ç”¨æºç¨‹åºçš„while trueè¿™æ®µä»£ç çš„è¯ï¼Œå¯¹äºæ¯ä¸ªkeyå­è¿­ä»£å™¨ä¼šç”Ÿæˆä¸¤éï¼Œå½“ç„¶ç¬¬äºŒéçš„å­è¿­ä»£å™¨æ˜¯ä¸ä¼šä½¿ç”¨çš„ã€‚ ä¸‹é¢ç®€è¦è¯´æ˜ç¤ºä¾‹çš„è¿ä½œæ–¹å¼ï¼Œè¿˜ä¼šè¯´æ˜æŠŠ main å‡½æ•°ä¸­è°ƒç”¨ group.send(None) é‚£ä¸€è¡Œä»£ç ï¼ˆå¸¦æœ‰\"é‡è¦ï¼\"æ³¨é‡Šçš„é‚£ä¸€è¡Œï¼‰å»æ‰ä¼šå‘ç”Ÿä»€ä¹ˆäº‹ã€‚ å¤–å±‚ for å¾ªç¯æ¯æ¬¡è¿­ä»£ä¼šæ–°å»ºä¸€ä¸ª grouper å®ä¾‹ï¼Œèµ‹å€¼ç»™ group å˜é‡ï¼›group æ˜¯å§”æ´¾ç”Ÿæˆå™¨ã€‚ è°ƒç”¨ next(group)ï¼Œé¢„æ¿€å§”æ´¾ç”Ÿæˆå™¨ grouperï¼Œæ­¤æ—¶è¿›å…¥ while True å¾ªç¯ï¼Œè°ƒç”¨å­ç”Ÿæˆå™¨ averager åï¼Œåœ¨ yield from è¡¨è¾¾å¼å¤„æš‚åœã€‚ å†…å±‚ for å¾ªç¯è°ƒç”¨ group.send(value)ï¼Œç›´æ¥æŠŠå€¼ä¼ ç»™å­ç”Ÿæˆå™¨ averagerã€‚åŒæ—¶ï¼Œå½“å‰çš„ grouper å®ä¾‹ï¼ˆgroupï¼‰åœ¨ yield from è¡¨è¾¾å¼å¤„æš‚åœã€‚ å†…å±‚å¾ªç¯ç»“æŸåï¼Œgroup å®ä¾‹ä¾æ—§åœ¨ yield from è¡¨è¾¾å¼å¤„æš‚åœï¼Œå› æ­¤ï¼Œgrouper å‡½æ•°å®šä¹‰ä½“ä¸­ä¸º results[key] èµ‹å€¼çš„è¯­å¥è¿˜æ²¡æœ‰æ‰§è¡Œã€‚ å¦‚æœå¤–å±‚ for å¾ªç¯çš„æœ«å°¾æ²¡æœ‰ group.send(None)ï¼Œé‚£ä¹ˆ averager å­ç”Ÿæˆå™¨æ°¸è¿œä¸ä¼šç»ˆæ­¢ï¼Œå§”æ´¾ç”Ÿæˆå™¨ group æ°¸è¿œä¸ä¼šå†æ¬¡æ¿€æ´»ï¼Œå› æ­¤æ°¸è¿œä¸ä¼šä¸º results[key] èµ‹å€¼ã€‚ å¤–å±‚ for å¾ªç¯é‡æ–°è¿­ä»£æ—¶ä¼šæ–°å»ºä¸€ä¸ª grouper å®ä¾‹ï¼Œç„¶åç»‘å®šåˆ° group å˜é‡ä¸Šã€‚å‰ä¸€ä¸ª grouper å®ä¾‹ï¼ˆä»¥åŠå®ƒåˆ›å»ºçš„å°šæœªç»ˆæ­¢çš„ averager å­ç”Ÿæˆå™¨å®ä¾‹ï¼‰è¢«åƒåœ¾å›æ”¶ç¨‹åºå›æ”¶ã€‚ Additional å‚è€ƒæ–‡çŒ®: 1. æµç•…çš„python","tags":"Python","title":"Flunet Python 16.7 coroutine understading"},{"url":"linklist-problems-summary.html","text":"Description é“¾è¡¨é—®é¢˜æ˜¯ç»å¸¸ä¼šé‡åˆ°çš„æ•°æ®ç»“æ„é—®é¢˜ã€‚è¯¥ç±»é—®é¢˜çš„éš¾ç‚¹ä¸»è¦é›†ä¸­å†å•å‘éå†ä»¥åŠé“¾è¡¨æœ‰ç¯çš„æƒ…å†µä¸‹ã€‚å¾ˆå¤šé“¾è¡¨é—®é¢˜åªè¦åˆ©ç”¨ä¸¤ä¸ªé€Ÿåº¦ä¸ä¸€çš„æŒ‡é’ˆæ¥å®Œæˆå•å‘éå†å°±å¯ä»¥ç®€åŒ–é—®é¢˜ã€å‡å°‘å¤æ‚åº¦ã€‚æœ¬æ–‡åŸºäºä¸€äº›å¸¸è§çš„é“¾è¡¨é—®é¢˜æ¥åˆ†ææ¯”è¾ƒè‰¯å¥½çš„æ–¹æ¡ˆä»¥åŠpythonå®ç°ã€‚ å‡†å¤‡å·¥ä½œ åœ¨è§£å†³é—®é¢˜ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆè¦å®šä¹‰è¿™æ¬¡ä½¿ç”¨çš„é“¾è¡¨çš„æ•°æ®ç»“æ„ã€‚ åœ¨æ­¤æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªæ™®é€šçš„valueå’ŒnextæŒ‡é’ˆçš„é“¾è¡¨ç»“æ„ï¼Œå¹¶é‡å†™äº†__len__é­”æœ¯æ–¹æ³•æ¥è®¡ç®—æ— ç¯é“¾è¡¨è‡ªèº«çš„é•¿åº¦ï¼Œæ·»åŠ äº†traversalæ–¹æ³•æ¥å¸®åŠ©æˆ‘ä»¬éå†é“¾è¡¨éªŒè¯ç»“è®ºã€‚ åœ¨SampleLinklistç±»ä¸­æˆ‘ä»¬å®šä¹‰äº†ä¸€äº›é“¾è¡¨ç¤ºä¾‹æ¥è¾…åŠ©æˆ‘ä»¬éªŒè¯ç»“è®ºã€‚ ### -*- coding: utf-8 -*- class Linklist ( object ): def __init__ ( self , value , next ): self . value = value self . next = next def traversal ( self ): \"\"\" éå†è¯¥èŠ‚ç‚¹å¼€å§‹çš„é“¾è¡¨ :return: \"\"\" print ( self . value ) if self . next : self . next . traversal () def __bool__ ( self ): \"\"\" ç”¨äºä¹‹åçš„if Linkliståˆ¤æ–­ :return: \"\"\" return True def __len__ ( self ): \"\"\" :return: æ— ç¯é“¾è¡¨çš„é•¿åº¦ \"\"\" count = 0 node = self while node is not None : node = node . next count += 1 return count class SampleLinklist ( object ): def __init__ ( self ): # åˆ›å»ºä¸€ä¸ªå€¼ä¸º0-19çš„é“¾è¡¨æ•°ç»„ nodelist = [ Linklist ( i , None ) for i in range ( 20 )] # 0-6ä¸ºæ— ç¯å•é“¾è¡¨ï¼›7-11ä¸ºæœ‰ç¯å•é“¾è¡¨ï¼ˆå…¥å£ä¸º8ï¼‰ï¼› # 12-14äº¤äºæ— ç¯å•é“¾è¡¨(å…¥å£ä¸º5)ï¼›15-19äº¤äºæœ‰ç¯é“¾è¡¨ï¼ˆå…¥å£ä¸º9ï¼‰ï¼› for key , value in enumerate ( nodelist ): if key != 6 and key != 11 and key != 14 and key != 19 : value . next = nodelist [ key + 1 ] elif key == 11 : value . next = nodelist [ 8 ] elif key == 14 : value . next = nodelist [ 5 ] elif key == 19 : value . next = nodelist [ 9 ] #æ— ç¯å•é“¾è¡¨ self . normal_linklist = nodelist [ 0 ] #æœ‰ç¯å•é“¾è¡¨ï¼ˆå…¥å£ä¸º8ï¼‰ self . loop_linklist = nodelist [ 7 ] #ä¸normal_linklistäº¤äº5 self . intersect_normal_linklist = ( nodelist [ 0 ], nodelist [ 12 ]) # ä¸nloop_linklistäº¤äº9 self . intersect_loop_linklist = ( nodelist [ 7 ], nodelist [ 15 ]) è§£å†³é—®é¢˜ åœ¨O(1)æ—¶é—´åˆ é™¤é“¾è¡¨èŠ‚ç‚¹ é¢˜ç›®æè¿°ï¼š ç»™å®šé“¾è¡¨çš„å¤´æŒ‡é’ˆå’Œä¸€ä¸ªèŠ‚ç‚¹æŒ‡é’ˆï¼Œåœ¨O(1)æ—¶é—´åˆ é™¤è¯¥èŠ‚ç‚¹ã€‚ åˆ†æï¼š æœ¬é¢˜ä¸ã€Šç¼–ç¨‹ä¹‹ç¾ã€‹ä¸Šçš„ã€Œä»æ— å¤´å•é“¾è¡¨ä¸­åˆ é™¤èŠ‚ç‚¹ã€ç±»ä¼¼ã€‚ä¸»è¦æ€æƒ³éƒ½æ˜¯ã€Œç‹¸çŒ«æ¢å¤ªå­ã€ï¼Œå³ç”¨ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ•°æ®è¦†ç›–è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼Œç„¶ååˆ é™¤ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚ä½†æ˜¯å¦‚æœèŠ‚ç‚¹æ˜¯å°¾èŠ‚ç‚¹æ—¶ï¼Œpythonæ— æ³•ç›´æ¥åœ¨å†…å­˜ä¸­åˆ é™¤ä¼ å…¥å‡½æ•°çš„å¯¹è±¡ï¼Œæš‚æ—¶è¿˜æ²¡æ‰¾åˆ°åŠæ³•è§£å†³ã€‚ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def delete_specified_node ( node ): assert ( node != None ) if node . next != None : storeNode = node . next node . value = node . next . value node . next = node . next . next åè½¬å•é“¾è¡¨ é¢˜ç›®æè¿°ï¼š è¾“å…¥ä¸€ä¸ªå•å‘é“¾è¡¨ï¼Œè¾“å‡ºé€†åºåè½¬åçš„é“¾è¡¨ã€‚ åˆ†æï¼š é“¾è¡¨çš„è½¬ç½®æ˜¯ä¸€ä¸ªå¾ˆå¸¸è§ã€å¾ˆåŸºç¡€çš„æ•°æ®ç»“æ„é¢˜äº†ã€‚æˆ‘ä»¬åœ¨è¿™é‡Œè¿ç”¨äº†é€’å½’ç®—æ³•ï¼Œå°†å°¾èŠ‚ç‚¹å†’æ³¡è¿”å›ï¼Œç„¶åå¯¹æ¯ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆåç½®ã€‚ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def revert_linklist ( node ): if not node or not node . next : # è¿”å›é“¾è¡¨å°¾èŠ‚ç‚¹ä¸ºï¼Œæ—¢åè½¬åé“¾è¡¨å¤´ç»“ç‚¹ return node # æš‚å­˜å¤´ç»“ç‚¹ header = revert_linklist ( node . next ) node . next . next = node node . next = None return header æ‰¾åˆ°å•é“¾è¡¨å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹ é¢˜ç›®æè¿°ï¼š è¾“å…¥ä¸€ä¸ªå•å‘é“¾è¡¨ï¼Œè¾“å‡ºè¯¥é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹ï¼Œé“¾è¡¨çš„å€’æ•°ç¬¬0ä¸ªèŠ‚ç‚¹ä¸ºé“¾è¡¨çš„å°¾æŒ‡é’ˆã€‚ åˆ†æï¼š è®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆ p1ã€p2ï¼Œé¦–å…ˆ p1 å’Œ p2 éƒ½æŒ‡å‘ headï¼Œç„¶å p2 å‘å‰èµ° k æ­¥ï¼Œè¿™æ · p1 å’Œ p2 ä¹‹é—´å°±é—´éš” k ä¸ªèŠ‚ç‚¹ï¼Œæœ€å p1 å’Œ p2 åŒæ—¶å‘å‰ç§»åŠ¨ï¼Œç›´è‡³ p2 èµ°åˆ°é“¾è¡¨æœ«å°¾ã€‚ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def find_last_nth ( header , n ): if not header or n < 0 : return None # å°†fastå’ŒslowæŒ‡é’ˆè®¾è‡³é“¾è¡¨èµ·ç‚¹ fast = slow = header # å°†fastèµ°nä¸ªèŠ‚ç‚¹ while fast . next and n > 0 : fast = fast . next n -= 1 # nå¤§äºé“¾è¡¨é•¿åº¦çš„æƒ…å†µ if n > 0 : return None while fast . next : fast = fast . next slow = slow . next return slow æ‰¾åˆ°å•é“¾è¡¨ä¸­é—´èŠ‚ç‚¹ é¢˜ç›®æè¿°ï¼š æ±‚é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹ï¼Œå¦‚æœé“¾è¡¨çš„é•¿åº¦ä¸ºå¶æ•°ï¼Œè¿”å›ä¸­é—´ä¸¤ä¸ªèŠ‚ç‚¹çš„ä»»æ„ä¸€ä¸ªï¼Œè‹¥ä¸ºå¥‡æ•°ï¼Œåˆ™è¿”å›ä¸­é—´èŠ‚ç‚¹ã€‚ åˆ†æï¼š æ­¤é¢˜çš„è§£å†³æ€è·¯å’Œç¬¬3é¢˜ã€Œæ±‚é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ã€å¾ˆç›¸ä¼¼ã€‚å¯ä»¥å…ˆæ±‚é“¾è¡¨çš„é•¿åº¦ï¼Œ ç„¶åè®¡ç®—å‡ºä¸­é—´èŠ‚ç‚¹æ‰€åœ¨é“¾è¡¨é¡ºåºçš„ä½ç½®ã€‚ä½†æ˜¯å¦‚æœè¦æ±‚åªèƒ½æ‰«æä¸€éé“¾è¡¨ï¼Œå¦‚ä½•è§£å†³å‘¢ï¼Ÿ æœ€é«˜æ•ˆçš„è§£æ³•å’Œç¬¬3é¢˜ä¸€æ ·ï¼Œé€šè¿‡ä¸¤ä¸ªæŒ‡é’ˆæ¥å®Œæˆã€‚ç”¨ä¸¤ä¸ªæŒ‡é’ˆä»é“¾è¡¨å¤´èŠ‚ç‚¹å¼€å§‹ï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡å‘åç§»åŠ¨ä¸¤æ­¥ï¼Œä¸€ä¸ªæ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ï¼Œç›´åˆ°å¿«æŒ‡é’ˆç§»åˆ°åˆ°å°¾èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæ…¢æŒ‡é’ˆå³æ˜¯æ‰€æ±‚ã€‚ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def find_mid ( header ): if not header : return None # å°†fastå’ŒslowæŒ‡é’ˆè®¾è‡³é“¾è¡¨èµ·ç‚¹ fast = slow = header while fast and fast . next : #fasté€Ÿåº¦ä¸ºslowä¸¤å€ fast = fast . next . next slow = slow . next return slow åˆ¤æ–­å•é“¾è¡¨æ˜¯å¦æœ‰ç¯ é¢˜ç›®æè¿°ï¼š è¾“å…¥ä¸€ä¸ªå•å‘é“¾è¡¨ï¼Œåˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯ã€‚å¦‚æœé“¾è¡¨å­˜åœ¨ç¯ï¼Œå¦‚ä½•æ‰¾åˆ°ç¯çš„å…¥å£ç‚¹ï¼Ÿ åˆ†æï¼š é€šè¿‡ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«ä»é“¾è¡¨çš„å¤´èŠ‚ç‚¹å‡ºå‘ï¼Œä¸€ä¸ªæ¯æ¬¡å‘åç§»åŠ¨ä¸€æ­¥ï¼Œå¦ä¸€ä¸ªç§»åŠ¨ä¸¤æ­¥ï¼Œä¸¤ä¸ªæŒ‡é’ˆç§»åŠ¨é€Ÿåº¦ä¸ä¸€æ ·ï¼Œå¦‚æœå­˜åœ¨ç¯ï¼Œé‚£ä¹ˆä¸¤ä¸ªæŒ‡é’ˆä¸€å®šä¼šåœ¨ç¯é‡Œç›¸é‡ã€‚æŒ‰ç…§ p2 æ¯æ¬¡ä¸¤æ­¥ï¼Œp1 æ¯æ¬¡ä¸€æ­¥çš„æ–¹å¼èµ°ï¼Œå‘ç° p2 å’Œ p1 é‡åˆï¼Œç¡®å®šäº†å•å‘é“¾è¡¨æœ‰ç¯è·¯äº†ã€‚æ¥ä¸‹æ¥ï¼Œè®©p2å›åˆ°é“¾è¡¨çš„å¤´éƒ¨ï¼Œé‡æ–°èµ°ï¼Œæ¯æ¬¡æ­¥é•¿ä¸æ˜¯èµ°2äº†ï¼Œè€Œæ˜¯èµ°1ï¼Œé‚£ä¹ˆå½“ p1 å’Œ p2 å†æ¬¡ç›¸é‡çš„æ—¶å€™ï¼Œå°±æ˜¯ç¯è·¯çš„å…¥å£äº†ã€‚ä¸ºä»€ä¹ˆï¼Ÿï¼šå‡å®šèµ·ç‚¹åˆ°ç¯å…¥å£ç‚¹çš„è·ç¦»ä¸º aï¼Œp1 å’Œ p2 çš„ç›¸äº¤ç‚¹Mä¸ç¯å…¥å£ç‚¹çš„è·ç¦»ä¸ºbï¼Œç¯è·¯çš„å‘¨é•¿ä¸ºLï¼Œå½“ p1 å’Œ p2 ç¬¬ä¸€æ¬¡ç›¸é‡çš„æ—¶å€™ï¼Œå‡å®š p1 èµ°äº† n æ­¥ã€‚é‚£ä¹ˆæœ‰ï¼šp1èµ°çš„è·¯å¾„ï¼š a+b ï¼ nï¼›p2èµ°çš„è·¯å¾„ï¼š a+b+k L = 2 nï¼› p2 æ¯” p1 å¤šèµ°äº†kåœˆç¯è·¯ï¼Œæ€»è·¯ç¨‹æ˜¯p1çš„2å€æ ¹æ®ä¸Šè¿°å…¬å¼å¯ä»¥å¾—åˆ° k*L=a+b=næ˜¾ç„¶ï¼Œå¦‚æœä»ç›¸é‡ç‚¹Må¼€å§‹ï¼Œp1 å†èµ° n æ­¥çš„è¯ï¼Œè¿˜å¯ä»¥å†å›åˆ°ç›¸é‡ç‚¹ï¼ŒåŒæ—¶p2ä»å¤´å¼€å§‹èµ°çš„è¯ï¼Œç»è¿‡næ­¥ï¼Œä¹Ÿä¼šè¾¾åˆ°ç›¸é‡ç‚¹Mã€‚æ˜¾ç„¶åœ¨è¿™ä¸ªæ­¥éª¤å½“ä¸­ p1 å’Œ p2åªæœ‰å‰ a æ­¥èµ°çš„è·¯å¾„ä¸åŒï¼Œæ‰€ä»¥å½“ p1 å’Œ p2 å†æ¬¡é‡åˆçš„æ—¶å€™ï¼Œå¿…ç„¶æ˜¯åœ¨é“¾è¡¨çš„ç¯è·¯å…¥å£ç‚¹ä¸Šã€‚ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def is_loop ( header ): if not header : return False fast = slow = header while fast and fast . next : fast = fast . next . next slow = slow . next # æ‰¾åˆ°ä¸¤æ­¥é•¿äº¤æ±‡ç‚¹ if fast == slow : break if fast != slow : return None # å°†fastå‘é…å›èµ·ç‚¹ fast = header #å½“ä¸¤èŠ‚ç‚¹å†æ¬¡ç›¸é‡çš„æ—¶å€™åˆ™ä¸ºç¯å…¥å£ while not fast == slow : fast = fast . next slow = slow . next return fast åˆ¤æ–­ä¸¤ä¸ªå•é“¾è¡¨æ˜¯å¦ç›¸äº¤ é¢˜ç›®æè¿°ï¼š ç»™å‡ºä¸¤ä¸ªé“¾è¡¨çš„å¤´æŒ‡é’ˆï¼Œåˆ¤æ–­å…¶æ˜¯å¦ç›¸äº¤ã€‚ åˆ†æï¼š å¦‚æœä¸¤ä¸ªæ— ç¯é“¾è¡¨ç›¸äº¤ï¼Œåˆ™å…¶å°¾æŒ‡é’ˆä¸€å®šç›¸åŒï¼›å¦‚æœä¸¤ä¸ªæœ‰ç¯é“¾è¡¨ç›¸äº¤ï¼Œåˆ™ä¸¤ä¸ªé“¾è¡¨éƒ½æœ‰å…±åŒä¸€ä¸ªç¯ï¼Œå³ç¯ä¸Šçš„ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹éƒ½å­˜åœ¨äºä¸¤ä¸ªé“¾è¡¨ä¸Šã€‚å› æ­¤ï¼Œå°±å¯ä»¥åˆ¤æ–­ä¸€é“¾è¡¨ä¸Šä¿©æŒ‡é’ˆç›¸é‡çš„é‚£ä¸ªèŠ‚ç‚¹ï¼Œåœ¨ä¸åœ¨å¦ä¸€æ¡é“¾è¡¨ä¸Šã€‚ ### -*- coding: utf-8 -*- from linklist import SampleLinklist from whether_linklist_has_loop import is_loop def is_intersect ( header1 , header2 ): if not header1 or not header2 : return False if not is_loop ( header1 ) and not is_loop ( header2 ): # ä¸¤ä¸ªæ— ç¯é“¾è¡¨çš„å°¾èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰å†³å®šäº†å®ƒä»¬æ˜¯å¦ç›¸äº¤ while header1 : header1 = header1 . next while header2 : header2 = header2 . next return True if header1 == header2 else False elif not is_loop ( header1 ) or not is_loop ( header2 ): return False else : # ä¸¤ä¸ªå¸¦ç¯é“¾è¡¨çš„å…¥å£å¿…ç„¶åœ¨å®ƒä»¬çš„ç¯å†… intersect1 = is_loop ( header1 ) intersect2 = is_loop ( header2 ) node = intersect2 . next # å¦‚æœä»»æ„é“¾è¡¨ç¯ä¸­æœ‰å¦ä¸€åˆ—è¡¨çš„èŠ‚ç‚¹åˆ™ç›¸äº¤ while node != intersect2 : if node == intersect1 : return True node = node . next return False æ‰¾åˆ°é“¾è¡¨ç›¸äº¤ç‚¹ é¢˜ç›®æè¿°ï¼š å¦‚æœä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤ï¼Œæ€ä¹ˆæ±‚å‡ºä»–ä»¬ç›¸äº¤çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å‘¢ï¼Ÿ åˆ†æï¼š å½“ä¸¤é“¾è¡¨æ— ç¯æ—¶ï¼Œåˆ™å¯é‡‡ç”¨å¯¹é½çš„æ€æƒ³ã€‚è®¡ç®—ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ L1 , L2ï¼Œåˆ†åˆ«ç”¨ä¸¤ä¸ªæŒ‡é’ˆ p1 , p2 æŒ‡å‘ä¸¤ä¸ªé“¾è¡¨çš„å¤´ï¼Œç„¶åå°†è¾ƒé•¿é“¾è¡¨çš„ p1ï¼ˆå‡è®¾ä¸º p1ï¼‰å‘åç§»åŠ¨L2 - L1ä¸ªèŠ‚ç‚¹ï¼Œç„¶åå†åŒæ—¶å‘åç§»åŠ¨p1 , p2ï¼Œç›´åˆ° p1 = p2ã€‚ç›¸é‡çš„ç‚¹å°±æ˜¯ç›¸äº¤çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚å½“ä¸¤é“¾è¡¨æœ‰ç¯æ—¶ï¼Œå¦‚æœä¸ªç¯å…¥å£ç›¸ç­‰ï¼Œåˆ™å¯çœ‹æˆä»¥ç¯å…¥å£ä¸ºå°¾èŠ‚ç‚¹çš„æ— ç¯æƒ…å†µã€‚å¦‚æœä¸ç­‰ï¼Œåˆ™é¦–å…¬å…±èŠ‚ç‚¹ä¸ºä¸¤ä¸ªå…¥å£è¾ƒè¿‘çš„é‚£ä¸ªã€‚ ### -*- coding: utf-8 -*- from linklist import SampleLinklist def find_intersect_first_common ( header1 , header2 ): len1 = len ( header1 ) len2 = len ( header2 ) if len1 > len2 : for i in range ( len1 - len2 ): header1 = header1 . next else : for i in range ( len2 - len1 ): header2 = header2 . next while header1 : if header1 == header2 : return header1 header1 = header1 . next header2 = header2 . next return None æºç ä¸‹è½½ Additional å‚è€ƒæ–‡çŒ®: 1. é¢è¯•ç²¾é€‰ï¼šé“¾è¡¨é—®é¢˜é›†é”¦ 2. æµç•…çš„python","tags":"Python","title":"Linklist Problems Summary"},{"url":"leetcode-next-greater-element-ii.html","text":"Description Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number. Example 1: Input: [1,2,1] Output: [2,-1,2] Explanation: The first 1's next greater number is 2; The number 2 can't find next greater number; The second 1's next greater number needs to search circularly, which is also 2. Note: The length of given array won't exceed 10000. Source link Best practice TBD C++ version -- TBD Mark: 0ms ä½¿ç”¨æ ˆæ¥åˆ¤æ–­å„ä¸ªå…ƒç´ next greaterçš„å…ƒç´ ã€‚ç”¨1è‡³2nåºå·ä»¥åŠå–ä½™çš„æ–¹æ³•æ¥éå†ä¸¤éåˆ—è¡¨ï¼Œæ¨¡æ‹Ÿå¾ªç¯æ•°ç»„çš„æƒ…å†µ python version class Solution ( object ): def nextGreaterElements ( self , nums ): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" length = len ( nums ) stack , res = [], [ - 1 ] * length for i in range ( length * 2 ): #å¦‚æœå‡ºç°å¤§äºæ ˆé¡¶åºå·å¾—å…ƒç´ å€¼çš„å…ƒç´ æ—¶ï¼Œ #å°±å¯ä»¥ç–¯ç‹‚å‡ºæ‰æ‰€æœ‰å°äºè¯¥å…ƒç´ çš„æ‰€æœ‰å…ƒç´ åºå· while stack and ( nums [ stack [ - 1 ]] < nums [ i % length ]): res [ stack . pop ()] = nums [ i % length ] #ä»…ä»…å°†æ¯ä¸ªå…ƒç´ çš„åºå·å…¥æ ˆä¸€æ¬¡ if i < length : stack . append ( i ) return res Mark: 275ms Additional","tags":"Python","title":"LeetCode - Next Greater Element II"},{"url":"leetcode-database-problems-summary.html","text":"Description Here is a summary of LeetCode Database section. Source link åˆ é™¤é‡å¤æ•°æ® Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id. +----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+------------------+ Id is the primary key column for this table. For example, after running your query, the above Person table should have the following rows: +----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | +----+------------------+ åˆ é™¤é‡å¤æ•°æ®æ˜¯éå¸¸æ™®éå’ŒåŸºç¡€çš„æ“ä½œã€‚é¦–å…ˆæˆ‘ä»¬å¯ä»¥ç”¨è¿æ¥è‡ªèº«ä»¥åŠwhereæ¡ä»¶è¿‡æ»¤æ¥å®Œæˆã€‚ delete p1 from Person p1,Person p2 where p1.Email=p2.Email and p1.id>p2.id ç”¨å­æŸ¥è¯¢å’Œminé€‰å‡ºæ¯ä¸ªåŒåç»„ä¸­æœ€å°çš„idå·ï¼Œåˆ é™¤é™¤äº†è¿™äº›idä»¥å¤–çš„è¡Œã€‚ delete from Person where id not in (select b.id from (select min(id) as id from Person group by Email) b) æ’åºé—®é¢˜ Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no \"holes\" between ranks. +----+-------+ | Id | Score | +----+-------+ | 1 | 3.50 | | 2 | 3.65 | | 3 | 4.00 | | 4 | 3.85 | | 5 | 4.00 | | 6 | 3.65 | +----+-------+ For example, given the above Scores table, your query should generate the following report (order by highest score): +-------+------+ | Score | Rank | +-------+------+ | 4.00 | 1 | | 4.00 | 1 | | 3.85 | 2 | | 3.65 | 3 | | 3.65 | 3 | | 3.50 | 4 | +-------+------+ è¿™é‡Œç”¨ç»“æœé›†ä¸­å¤§äºç­‰äºå½“å‰scoreçš„distinctè¡Œæ•°æ¥è¡¨ç¤ºæŸåˆ†æ•°åœ¨æ•´ä¸ªç»“æœé›†ä¸­çš„åºåˆ—ã€‚ select s.Score, (select count(*) from (select distinct Score from Scores) s2 where s2.Score>=s.Score) Rank from Scores s order by Rank asc åˆ†ç»„æ¯”è¾ƒé—®é¢˜ The Trips table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the Users table. Status is an ENUM type of (â€˜completed', â€˜cancelled_by_driver', â€˜cancelled_by_client'). +----+-----------+-----------+---------+--------------------+----------+ | Id | Client_Id | Driver_Id | City_Id | Status |Request_at| +----+-----------+-----------+---------+--------------------+----------+ | 1 | 1 | 10 | 1 | completed |2013-10-01| | 2 | 2 | 11 | 1 | cancelled_by_driver|2013-10-01| | 3 | 3 | 12 | 6 | completed |2013-10-01| | 4 | 4 | 13 | 6 | cancelled_by_client|2013-10-01| | 5 | 1 | 10 | 1 | completed |2013-10-02| | 6 | 2 | 11 | 6 | completed |2013-10-02| | 7 | 3 | 12 | 6 | completed |2013-10-02| | 8 | 2 | 12 | 12 | completed |2013-10-03| | 9 | 3 | 10 | 12 | completed |2013-10-03| | 10 | 4 | 13 | 12 | cancelled_by_driver|2013-10-03| +----+-----------+-----------+---------+--------------------+----------+ The Users table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (â€˜client', â€˜driver', â€˜partner'). +----------+--------+--------+ | Users_Id | Banned | Role | +----------+--------+--------+ | 1 | No | client | | 2 | Yes | client | | 3 | No | client | | 4 | No | client | | 10 | No | driver | | 11 | No | driver | | 12 | No | driver | | 13 | No | driver | +----------+--------+--------+ Write a SQL query to find the cancellation rate of requests made by unbanned clients between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places. +------------+-------------------+ | Day | Cancellation Rate | +------------+-------------------+ | 2013-10-01 | 0.33 | | 2013-10-02 | 0.00 | | 2013-10-03 | 0.50 | +------------+-------------------+ å°†æ•°æ®é›†ä»¥æ—¶é—´åˆ†ç»„ï¼Œåˆ©ç”¨case when æ¥åˆ¤æ–­æ˜¯å¦è®¡å…¥å–æ¶ˆè®¢å•æ•°ã€‚ä¹Ÿå¯ä»¥ç”¨ifè¯­å¥ã€‚ select t.Request_at as Day, round((sum(case when t.Status in (\"cancelled_by_driver\",\"cancelled_by_client\") then 1 else 0 end)/count(*)),2) as \"Cancellation Rate\" from Trips t inner join Users u on t.Client_Id =u.Users_Id where u.Banned <> \"Yes\" and t.Request_at between \"2013-10-01\" and \"2013-10-03\" group by t.Request_at The Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id. +----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Henry | 80000 | 2 | | 3 | Sam | 60000 | 2 | | 4 | Max | 90000 | 1 | | 5 | Janet | 69000 | 1 | | 6 | Randy | 85000 | 1 | +----+-------+--------+--------------+ The Department table holds all departments of the company. +----+----------+ | Id | Name | +----+----------+ | 1 | IT | | 2 | Sales | +----+----------+ Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows. +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | IT | Randy | 85000 | | IT | Joe | 70000 | | Sales | Henry | 80000 | | Sales | Sam | 60000 | +------------+----------+--------+ å–top3çš„åˆ†ç»„æ•°æ®å’Œå–æœ€å¤§åˆ†ç»„salaryæœ‰æ‰€ä¸åŒã€‚åè€…å¯ä»¥ç”¨where salary in ï¼ˆselect max(salary) ..group by ï¼‰å­æŸ¥è¯¢è¯­å¥æ¥å®ç°ã€‚ è¿™é‡Œè¿ç”¨äº†æ’åºé—®é¢˜ä¸­çš„æ€æƒ³ã€‚å°†å½“å‰salaryä¸åŒä¸€groupä¸­ï¼ˆè¡¨ç°ä¸ºdepartmentidç›¸ç­‰ï¼‰ï¼Œå¤§äºç­‰äºå½“å‰distinctçš„salaryçš„æ•°é‡ä½œä¸ºè¯¥salaryçš„rankã€‚å…¶ä»–é™åˆ¶æ¡ä»¶å°±è¿åˆƒè€Œè§£äº†ã€‚ select d.Name Department, e1.Name Employee, e1.Salary from Employee e1 join Department d on e1.DepartmentId = d.Id where 3 > (select count(distinct(e2.Salary)) from Employee e2 where e2.Salary > e1.Salary and e1.DepartmentId = e2.DepartmentId );","tags":"SQL","title":"LeetCode - Database Problems Summary"},{"url":"leetcode-construct-the-rectangle.html","text":"Description For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page's area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: The area of the rectangular web page you designed must equal to the given target area. The width W should not be larger than the length L, which means L >= W. The difference between length L and width W should be as small as possible. You need to output the length L and the width W of the web page you designed in sequence. Example: Input : 4 Output : [ 2 , 2 ] Explanation : The target area is 4 , and all the possible ways to construct it are [ 1 , 4 ], [ 2 , 2 ], [ 4 , 1 ]. But according to requirement 2 , [ 1 , 4 ] is illegal ; according to requirement 3 , [ 4 , 1 ] is not optimal compared to [ 2 , 2 ]. So the length L is 2 , and the width W is 2 . Note: 1. The given area won't exceed 10,000,000 and is a positive integer 2. The web page's width and length you designed must be positive integers. Source link Best practice å…¶å®å¾ˆç®€å•ï¼Œæ”¾ä¸Šæ¥æ˜¯å› ä¸ºè®°å½•ä¸€ä¸‹pythonå’Œcå„è‡ªä¸åŒçš„è§£å†³æ–¹å¼ã€‚ç„¶åcçš„0mså®åœ¨æ˜¯å¤ªå¤¸å¼ äº†ã€‚ C++ version class Solution { public : vector < int > constructRectangle ( int area ) { int ceil = floor ( sqrt ( area )); while ( area % ceil != 0 ) { -- ceil ; } return vector < int > ({ area / ceil , ceil }); } }; Mark: 0ms python version import math class Solution ( object ): def constructRectangle ( self , area ): \"\"\" :type area: int :rtype: List[int] \"\"\" for i in range ( math . floor ( math . sqrt ( area )), 0 , - 1 ): if area % i == 0 : return [ int ( area / i ), i ] Mark: 46ms Additional","tags":"C,Python","title":"LeetCode - Construct the Rectangle"},{"url":"leetcode-move-zeroes.html","text":"Description Given an array nums , write a function to move all 0 's to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12] , after calling your function, nums should be [1, 3, 12, 0, 0] . Note: 1. You must do this in-place without making a copy of the array. 2. Minimize the total number of operations. Source link Best practice æ¯å½“é‡åˆ°ä¸€ä¸ª0ä½å°±å°†ä¹‹åçš„æ•°å­—å‘å‰ç§»åŠ¨xä½ï¼ˆxä¸ºé‡åˆ°çš„0çš„ä¸ªæ•°ï¼‰ï¼Œæœ€åå°†åxä½ç½®ä¸º0ã€‚ C++ version class Solution { public : void moveZeroes ( vector < int >& nums ) { int count = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ){ if ( nums [ i ] == 0 ){ ++ count ; } else { nums [ i - count ] = nums [ i ]; } } for ( int i = 0 ; i < count ; ++ i ){ nums [ nums . size () - 1 - i ] = 0 ; } } }; Mark: 16ms ç”¨ä¸€ä¸ªå˜é‡jæ¥è®°å½•é0ä½åº”åœ¨çš„ä½ç½®ï¼Œæœ€åå¤„ç†æœ«ç½®0ä½ã€‚ python version class Solution ( object ): def moveZeroes ( self , nums ): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" j = 0 for item in nums : if item != 0 : nums [ j ] = item j += 1 for index in range ( j , len ( nums )): nums [ index ] = 0 Mark: 59ms Additional","tags":"C,Python","title":"LeetCode - Move Zeroes"},{"url":"leetcode-add-one-row-to-tree.html","text":"Description Given the root of a binary tree, then value v and depth d , you need to add a row of nodes with value v at the given depth d . The root node is at depth 1. The adding rule is: given a positive integer depth d , for each NOT null tree nodes N in depth d-1 , create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree. Example 1: Input : A binary tree as following : 4 / \\ 2 6 / \\ / 3 1 5 v = 1 d = 2 Output : 4 / \\ 1 1 / \\ 2 6 / \\ / 3 1 5 Example 2: Input : A binary tree as following : 4 / 2 / \\ 3 1 v = 1 d = 3 Output : 4 / 2 / \\ 1 1 / \\ 3 1 Note: 1. The given d is in range [1, maximum depth of the given tree + 1]. 2. The given binary tree has at least one tree node. Source link Best practice é¢˜ç›®ä¸­d=1æ—¶å®ä¸ºä¸€ç§ç‰¹æ®Šæƒ…å†µâ€”â€”â€”â€”æ•´é¢—æ ‘å˜ä¸ºå·¦å­æ ‘ã€‚ç›¸ä¼¼çš„å½“d=0æ—¶æ•´æ£µæ ‘ç›¸åº”ä¼šå˜æˆå³å­æ ‘å˜›ã€‚ä»¥æ­¤æ¨ç†å¯ä»¥å¾—ä»¥ä¸‹ç»ˆæè§£å†³æ–¹æ³•ã€‚å°†d=0å’Œd=1ä½œä¸ºé€’å½’ç»ˆæ­¢æ¡ä»¶ä»è€Œå°†d=1çš„ç‰¹æ®Šæƒ…å†µæ¦‚åŒ–ï¼Œåˆçœå»äº†helperå‡½æ•°ã€‚ C++ version class Solution { public : TreeNode * addOneRow ( TreeNode * root , int v , int d ) { if ( d == 0 || d == 1 ) { TreeNode * newroot = new TreeNode ( v ); ( d ? newroot -> left : newroot -> right ) = root ; return newroot ; } if ( root && d >= 2 ) { root -> left = addOneRow ( root -> left , v , d > 2 ? d - 1 : 1 ); root -> right = addOneRow ( root -> right , v , d > 2 ? d - 1 : 0 ); } return root ; } }; Mark: 16ms è¿™ä¸ªpythonç‰ˆæœ¬æ˜¾å¾—éå¸¸ä¸pythonicã€‚helperå‡½æ•°å¢åŠ äº†ä¸€ä¸ªé•¿åº¦å‚æ•°è®°å½•äº†é€’å½’æ ‘æ·±åº¦ï¼Œå…¶å®å¯ä»¥ç”¨ä½¿å‚æ•°dé€’å‡çš„æ–¹å¼æ¥ä¼ é€’æ·±åº¦ã€‚ python version ### Definition for a binary tree node. ### class TreeNode(object): ### def __init__(self, x): ### self.val = x ### self.left = None ### self.right = None class Solution : def addOneRow ( self , root , v , d ): \"\"\" :type root: TreeNode :type v: int :type d: int :rtype: TreeNode \"\"\" if d == 1 : a = TreeNode ( v ) a . left = root return a return self . helper ( root , v , d , 1 ) def helper ( self , node , v , d , dep ): if not node : return if dep == d - 1 : a = TreeNode ( v ) b = TreeNode ( v ) a . left = node . left b . right = node . right node . left = a node . right = b self . helper ( node . left , v , d , dep + 1 ) self . helper ( node . right , v , d , dep + 1 ) return node Mark: 82ms Additional","tags":"C,Python","title":"LeetCode - Add One Row to Tree"},{"url":"leetcode-array-nesting.html","text":"Description A zero-indexed array A consisting of N different integers is given. The array contains all integers in the range [0, N - 1]. Sets S[K] for 0 <= K < N are defined as follows: S[K] = { A[K], A[A[K]], A[A[A[K]]], ... }. Sets S[K] are finite for each K and should NOT contain duplicates. Write a function that given an array A consisting of N integers, return the size of the largest set S[K] for this array. Example 1: Input : A = [ 5,4,0,3,1,6,2 ] Output : 4 Explanation : A [ 0 ] = 5 , A [ 1 ] = 4 , A [ 2 ] = 0 , A [ 3 ] = 3 , A [ 4 ] = 1 , A [ 5 ] = 6 , A [ 6 ] = 2. One of the longest S [ K ] : S [ 0 ] = { A [ 0 ] , A [ 5 ] , A [ 6 ] , A [ 2 ] } = { 5 , 6 , 2 , 0 } Note: 1. N is an integer within the range [1, 20,000]. 2. The elements of A are all distinct. 3. Each element of array A is an integer within the range [0, N-1]. Source link Best practice è¿™é‡Œç”¨åˆ°äº†ä¸€ä¸ªä¹‹å‰ç”¨è¿‡çš„å…¥æ ˆéå†æ–¹å¼ï¼Œå–maxæ—¶å€™çš„è¿ç®—è¿˜å¯ä»¥è¿›è¡Œä¼˜åŒ–ã€‚ Python version 1 class Solution ( object ): def arrayNesting ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" length = len ( nums ) def helper ( stack ): for item in stack : #å¿½ç•¥è¢«æ ‡è®°çš„å…ƒç´  if nums [ item ] < length : stack . append ( nums [ item ]) #å°†æ‰€æœ‰éå†è¿‡çš„å…ƒç´ çš„åºå·+lengthåšå”¯ä¸€æ ‡è®° nums [ item ] += length return len ( stack ) - 1 #éå†æ‰€æœ‰æœªè¢«æ ‡è®°çš„å…ƒç´  return max ([ helper ([ item ]) for item in nums if item < length ]) Mark: 85ms è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒæ™®é€‚æ€§çš„æ–¹æ³•ï¼Œåˆ›å»ºä¸€ä¸ªè®°å½•åˆ—è¡¨ã€‚ python version 2 class Solution ( object ): def arrayNesting ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" ans , step , n = 0 , 0 , len ( nums ) seen = [ False ] * n for i in range ( n ): while not seen [ i ]: seen [ i ] = True i , step = nums [ i ], step + 1 ans = max ( ans , step ) step = 0 return ans Mark: 85ms Additional","tags":"Python","title":"LeetCode - Array Nesting"},{"url":"leetcode-construct-string-from-binary-tree.html","text":"Description You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair \"()\". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input : Binary tree : [ 1 , 2 , 3 , 4 ] 1 / \\ 2 3 / 4 Output : \"1(2(4))(3)\" Explanation : Originallay it needs to be \"1(2(4)())(3()())\" , but you need to omit all the unnecessary empty parenthesis pairs . And it will be \"1(2(4))(3)\" . Example 2: Input : Binary tree : [ 1 , 2 , 3 , null , 4 ] 1 / \\ 2 3 \\ 4 Output : \"1(2()(4))(3)\" Explanation : Almost the same as the first example , except we can ' t omit the first parenthesis pair to break the one - to - one mapping relationship between the input and the output . Source link Best practice é€’å½’æ–¹æ³•ã€‚ C++ version class Solution { public : string tree2str ( TreeNode * t ) { if ( ! t ) return \"\" ; if ( ! t -> left &&! t -> right ) return to_string ( t -> val ); if ( ! t -> left ) return to_string ( t -> val ) + \"()(\" + tree2str ( t -> right ) + \")\" ; if ( ! t -> right ) return to_string ( t -> val ) + \"(\" + tree2str ( t -> left ) + \")\" ; return to_string ( t -> val ) + \"(\" + tree2str ( t -> left ) + \")(\" + tree2str ( t -> right ) + \")\" ; } }; Mark: 12ms python version class Solution ( object ): def tree2str ( self , t ): \"\"\" :type t: TreeNode :rtype: str \"\"\" if not t : return \"\" leftstring = \"( {} )\" . format ( self . tree2str ( t . left )) if t . left or ( not t . left and t . right ) else \"\" rightstring = \"( {} )\" . format ( self . tree2str ( t . right )) if t . right else \"\" return \" {}{}{} \" . format ( t . val , leftstring , rightstring ) Mark: 88ms Additional","tags":"C,Python","title":"LeetCode - Construct String from Binary Tree"},{"url":"leetcode-sort-characters-by-frequency.html","text":"Description Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input : \"tree\" Output : \"eert\" Explanation : 'e' appears twice while 'r' and 't' both appear once . So 'e' must appear before both 'r' and 't' . Therefore \"eetr\" is also a valid answer . Example 2: Input : \"cccaaa\" Output : \"cccaaa\" Explanation : Both 'c' and 'a' appear three times , so \"aaaccc\" is also a valid answer . Note that \"cacaca\" is incorrect , as the same characters must be together . Example 3: Input : \"Aabb\" Output : \"bbAa\" Explanation : \"bbaA\" is also a valid answer , but \"Aabb\" is incorrect . Note that 'A' and 'a' are treated as two different characters . Source link Best practice ä½¿ç”¨é˜Ÿåˆ—ã€‚ C++ version class Solution { public : string frequencySort ( string s ) { vector < int > m ( 256 , 0 ); priority_queue < pair < int , char > > pq ; for ( int i = 0 ; i < s . length (); i ++ ) m [ s [ i ]] ++ ; for ( int i = 0 ; i < 256 ; i ++ ) pq . push ( make_pair ( m [ i ], i )); string ans ; while ( pq . size ()){ ans . append ( pq . top (). first , pq . top (). second ); pq . pop (); } return ans ; } }; Mark: 12ms pythonç‰ˆæœ¬ä½¿ç”¨äº†sortedå‡½æ•°å¹¶é€šè¿‡opteratoråº“çš„itemgetterå‡½æ•°æ¥æé«˜æ£€ç´¢å­—å…¸æ•ˆç‡ã€‚stringä¹˜æ³•åˆ™æ˜¯pythonçš„å¦ä¸€ä¸ªç‰¹æ€§ã€‚ python version from operator import itemgetter class Solution ( object ): def frequencySort ( self , s ): \"\"\" :type s: str :rtype: str \"\"\" dct = {} result = \"\" for item in s : dct [ item ] = dct . get ( item , 0 ) + 1 for item in sorted ( dct . items (), key = itemgetter ( 1 ), reverse = True ): result += item [ 0 ] * item [ 1 ] return result Mark: 76ms Additional","tags":"C,Python","title":"LeetCode - Sort Characters by Frequency"},{"url":"complex-number-multiplication.html","text":"Description Given two strings representing two complex numbers. You need to return a string representing their multiplication. Note $$i&#94;2 = -1$$ according to the definition. Example 1: Input: \"1+1i\", \"1+1i\" Output: \"0+2i\" Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i. Example 2: Input: \"1+-1i\", \"1+-1i\" Output: \"0+-2i\" Explanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i. Note: 1. The input strings will not have extra blank. 2. The input strings will be given in the form of a+bi , where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form. Source link Best practice åœ¨c++ä¸­ä½¿ç”¨Stringstreamæ¥æå–å­—ç¬¦ä¸²ä¸­çš„ä¿¡æ¯ã€‚ C++ version class Solution { public : string complexNumberMultiply ( string a , string b ) { int ra , ia , rb , ib ; char buff ; stringstream aa ( a ), bb ( b ), ans ; aa >> ra >> buff >> ia >> buff ; bb >> rb >> buff >> ib >> buff ; ans << ra * rb - ia * ib << \"+\" << ra * ib + rb * ia << \"i\" ; return ans . str (); } }; Mark: Python version -- use re class Solution ( object ): def complexNumberMultiply ( self , a , b ): \"\"\" :type a: str :type b: str :rtype: str \"\"\" pattern = re . compile ( r '([\\-0-9]*)\\+([\\-0-9]*)i' ) la = [ int ( item ) for item in pattern . search ( a ) . groups ()] lb = [ int ( item ) for item in pattern . search ( b ) . groups ()] lc = [ la [ 0 ] * lb [ 0 ] - la [ 1 ] * lb [ 1 ], la [ 0 ] * lb [ 1 ] + la [ 1 ] * lb [ 0 ]] return ' {} + {} i' . format ( * lc ) Mark: 36ms Additional","tags":"C,Python","title":"Complex Number Multiplication"},{"url":"leetcode-merge-two-binary-trees.html","text":"Description Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: Input : Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 Output : Merged tree : 3 / \\ 4 5 / \\ \\ 5 4 7 Note: The merging process must start from the root nodes of both trees. Source link Best practice ç”¨é€’å½’çš„æ–¹æ³•æ¥åˆå¹¶ä¸¤æ ‘ï¼šå¦‚æœä¸€æ ‘ä»»æ„èŠ‚ç‚¹ä¸å­˜åœ¨åˆ™è¿”å›å¦ä¸€ä¸ªæ ‘çš„èŠ‚ç‚¹ï¼ˆå¦‚æœéƒ½ä¸ºç©ºåˆ™è¿”å›ä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œå¾ˆåˆç†ï¼‰ã€‚å¦‚æœéƒ½å­˜åœ¨åˆ™ç”Ÿæˆæ–°èŠ‚ç‚¹å…¶å€¼ä¸ºä¸¤æ ‘èŠ‚ç‚¹å€¼å¾—å’Œã€‚ TreeNode *node =new TreeNode(t1->val + t2->val); è¿”å›ä¸€ä¸ªTreeNodeæŒ‡é’ˆã€‚ C++ version class Solution { public : TreeNode * mergeTrees ( TreeNode * t1 , TreeNode * t2 ) { if ( ! t1 ) return t2 ; if ( ! t2 ) return t1 ; TreeNode * node = new TreeNode ( t1 -> val + t2 -> val ); node -> left = mergeTrees ( t1 -> left , t2 -> left ); node -> right = mergeTrees ( t1 -> right , t2 -> right ); return node ; } }; Mark: 10ms Additional","tags":"C","title":"LeetCode - Merge Two Binary Trees"},{"url":"leetcode-single-number-iii.html","text":"Description Given an array of numbers nums , in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: Given nums = [1, 2, 1, 3, 2, 5]``, return ``[3, 5] . Note: The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? Source link Best practice Once again, we need to use XOR to solve this problem. But this time, we need to do it in two passes: In the first pass, we XOR all elements in the array, and get the XOR of the two numbers we need to find. Note that since the two numbers are distinct, so there must be a set bit (that is, the bit with value '1') in the XOR result. Find out an arbitrary set bit (for example, the rightmost set bit). In the second pass, we divide all numbers into two groups, one with the aforementioned bit set, another with the aforementinoed bit unset. Two different numbers we need to find must fall into thte two distrinct groups. XOR numbers in each group, we can find a number in either group. C++ version class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { // Pass 1 : //Get the XOR of the two numbers we need to find int diff = accumulate ( nums . begin (), nums . end (), 0 , bit_xor < int > ()); // Get its last set bit diff &= - diff ; // Pass 2 : vector < int > rets = { 0 , 0 }; // this vector stores the two numbers we will return for ( int num : nums ) { if (( num & diff ) == 0 ) // the bit is not set { rets [ 0 ] &#94;= num ; } else // the bit is set { rets [ 1 ] &#94;= num ; } } return rets ; } }; Python version class Solution ( object ): def singleNumber ( self , nums ): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" diff = reduce ( lambda x , y : x &#94; y , nums ) diff &= - diff a = b = 0 for item in nums : if item & diff : a &#94;= item else : b &#94;= item return [ a , b ] Mark: 49ms Additional","tags":"C","title":"LeetCode - Single Number III"},{"url":"python-dan-li-shi-xian-de-ji-chong-fang-shi.html","text":"Python Singleton Metaclass Decorator category: Python make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. Description å•ä¾‹æ¨¡å¼ ï¼Œä¹Ÿå« å•å­æ¨¡å¼ ï¼Œæ˜¯ä¸€ç§å¸¸ç”¨çš„è½¯ä»¶è®¾è®¡æ¨¡å¼ã€‚åœ¨åº”ç”¨è¿™ä¸ªæ¨¡å¼æ—¶ï¼Œå•ä¾‹å¯¹è±¡çš„ç±»å¿…é¡»ä¿è¯åªæœ‰ä¸€ä¸ªå®ä¾‹å­˜åœ¨ã€‚è®¸å¤šæ—¶å€™æ•´ä¸ªç³»ç»Ÿåªéœ€è¦æ‹¥æœ‰ä¸€ä¸ªçš„å…¨å±€å¯¹è±¡ï¼Œè¿™æ ·æœ‰åˆ©äºæˆ‘ä»¬åè°ƒç³»ç»Ÿæ•´ä½“çš„è¡Œä¸ºã€‚æ¯”å¦‚åœ¨æŸä¸ªæœåŠ¡å™¨ç¨‹åºä¸­ï¼Œè¯¥æœåŠ¡å™¨çš„é…ç½®ä¿¡æ¯å­˜æ”¾åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œè¿™äº›é…ç½®æ•°æ®ç”±ä¸€ä¸ªå•ä¾‹å¯¹è±¡ç»Ÿä¸€è¯»å–ï¼Œç„¶åæœåŠ¡è¿›ç¨‹ä¸­çš„å…¶ä»–å¯¹è±¡å†é€šè¿‡è¿™ä¸ªå•ä¾‹å¯¹è±¡è·å–è¿™äº›é…ç½®ä¿¡æ¯ã€‚è¿™ç§æ–¹å¼ç®€åŒ–äº†åœ¨å¤æ‚ç¯å¢ƒä¸‹çš„é…ç½®ç®¡ç†ã€‚ å®ç°å•ä¾‹æ¨¡å¼çš„æ€è·¯æ˜¯ï¼šä¸€ä¸ªç±»èƒ½è¿”å›å¯¹è±¡ä¸€ä¸ªå¼•ç”¨(æ°¸è¿œæ˜¯åŒä¸€ä¸ª)å’Œä¸€ä¸ªè·å¾—è¯¥å®ä¾‹çš„æ–¹æ³•ï¼ˆå¿…é¡»æ˜¯é™æ€æ–¹æ³•ï¼Œé€šå¸¸ä½¿ç”¨getInstanceè¿™ä¸ªåç§°ï¼‰ï¼›å½“æˆ‘ä»¬è°ƒç”¨è¿™ä¸ªæ–¹æ³•æ—¶ï¼Œå¦‚æœç±»æŒæœ‰çš„å¼•ç”¨ä¸ä¸ºç©ºå°±è¿”å›è¿™ä¸ªå¼•ç”¨ï¼Œå¦‚æœç±»ä¿æŒçš„å¼•ç”¨ä¸ºç©ºå°±åˆ›å»ºè¯¥ç±»çš„å®ä¾‹å¹¶å°†å®ä¾‹çš„å¼•ç”¨èµ‹äºˆè¯¥ç±»ä¿æŒçš„å¼•ç”¨ï¼›åŒæ—¶æˆ‘ä»¬è¿˜å°†è¯¥ç±»çš„æ„é€ å‡½æ•°å®šä¹‰ä¸ºç§æœ‰æ–¹æ³•ï¼Œè¿™æ ·å…¶ä»–å¤„çš„ä»£ç å°±æ— æ³•é€šè¿‡è°ƒç”¨è¯¥ç±»çš„æ„é€ å‡½æ•°æ¥å®ä¾‹åŒ–è¯¥ç±»çš„å¯¹è±¡ï¼Œåªæœ‰é€šè¿‡è¯¥ç±»æä¾›çš„é™æ€æ–¹æ³•æ¥å¾—åˆ°è¯¥ç±»çš„å”¯ä¸€å®ä¾‹ã€‚ å•ä¾‹æ¨¡å¼åœ¨å¤šçº¿ç¨‹çš„åº”ç”¨åœºåˆä¸‹å¿…é¡»å°å¿ƒä½¿ç”¨ã€‚å¦‚æœå½“å”¯ä¸€å®ä¾‹å°šæœªåˆ›å»ºæ—¶ï¼Œæœ‰ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨åˆ›å»ºæ–¹æ³•ï¼Œé‚£ä¹ˆå®ƒä»¬åŒæ—¶æ²¡æœ‰æ£€æµ‹åˆ°å”¯ä¸€å®ä¾‹çš„å­˜åœ¨ï¼Œä»è€ŒåŒæ—¶å„è‡ªåˆ›å»ºäº†ä¸€ä¸ªå®ä¾‹ï¼Œè¿™æ ·å°±æœ‰ä¸¤ä¸ªå®ä¾‹è¢«æ„é€ å‡ºæ¥ï¼Œä»è€Œè¿åäº†å•ä¾‹æ¨¡å¼ä¸­å®ä¾‹å”¯ä¸€çš„åŸåˆ™ã€‚ è§£å†³è¿™ä¸ªé—®é¢˜çš„åŠæ³•æ˜¯ä¸ºæŒ‡ç¤ºç±»æ˜¯å¦å·²ç»å®ä¾‹åŒ–çš„å˜é‡æä¾›ä¸€ä¸ªäº’æ–¥é”(è™½ç„¶è¿™æ ·ä¼šé™ä½æ•ˆç‡)ã€‚ Implementation newæ–¹æ³• newæ–¹æ³• class Singleton ( object ): def __new__ ( cls , * args , ** kw ): if not hasattr ( cls , '_instance' ): orig = super ( Singleton , cls ) cls . _instance = orig . __new__ ( cls , * args , ** kw ) return cls . _instance class MyClass ( Singleton ): a = 1 metaclassæ–¹æ³• è¦†ç›– init ç±» class Singleton ( type ): def __init__ ( cls , * args , ** kwargs ): cls . __instance = None super () . __init__ ( * args , ** kwargs ) def __call__ ( cls , * args , ** kwargs ): if cls . __instance is None : cls . __instance = super () . __call__ ( * args , ** kwargs ) return cls . __instance class Spam ( metaclass = Singleton ): def __init__ ( self ): print ( 'Creating Spam' ) a = Spam () b = Spam () print ( a is b ) è¦†ç›– new ç±» class Singleton ( type ): def __new__ ( cls , name , base , dct ): dct [ '_instance' ] = None return super () . __new__ ( cls , name , base , dct ) def __call__ ( cls , * args , ** kwargs ): if cls . _instance is None : cls . _instance = super () . __call__ ( * args , ** kwargs ) return cls . _instance class Spam ( metaclass = Singleton ): def __init__ ( self ): print ( 'Creating Spam' ) a = Spam () b = Spam () print ( a is b ) decoratoræ–¹æ³• def singleton ( cls , * args , ** kw ): instances = {} def getinstance (): if cls not in instances : instances [ cls ] = cls ( * args , ** kw ) return instances [ cls ] return getinstance @singleton class MyClass : ... importæ–¹æ³• ### mysingleton.py class My_Singleton ( object ): def foo ( self ): pass my_singleton = My_Singleton () ### to use from mysingleton import my_singleton my_singleton . foo () Additional","tags":"posts","title":"Python å•ä¾‹å®ç°çš„å‡ ç§æ–¹å¼"},{"url":"leetcode-minimum-moves-to-equal-array-elements-ii.html","text":"Description Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1. You may assume the array's length is at most 10,000 . Example: ** Input : ** [ 1 , 2 , 3 ] ** Output : ** 2 ** Explanation : ** Only two moves are needed ( remember each move increments or decrements one element ): [ 1 , 2 , 3 ] => [ 2 , 2 , 3 ] => [ 2 , 2 , 2 ] Source link Best practice æˆ‘å’‹è§‰å¾—æ˜¨å¤©çš„æ¯”è¾ƒå¤æ‚ã€‚ éœ€è¦ç”¨åˆ°algorithmsåº“çš„sortå‡½æ•°ã€‚ä¸­é—´åºå·çš„æ•°çš„å€¼ä¸ºæ•°åˆ—çš„ç›®æ ‡å˜åŒ–å€¼ã€‚Minimum movesç­‰äºæ‰€æœ‰å…ƒç´ ä¸è¯¥ç›®æ ‡å˜åŒ–å€¼çš„å·®å€¼ä¹‹å’Œã€‚ C++ class Solution { public : int minMoves2 ( vector < int >& nums ) { sort ( nums . begin (), nums . end ()); int mid = nums [ floor ( nums . size () / 2 )]; int result = 0 ; for ( auto i : nums ) { result += abs ( i - mid ); } return result ; } }; Mark: 19ms Additional","tags":"C","title":"LeetCode - Minimum Moves to Equal Array Elements II"},{"url":"leetcode-minimum-index-sum-of-two-lists.html","text":"Description Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum . If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer. Example 1: Input: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"] Output: [\"Shogun\"] Explanation: The only restaurant they both like is \"Shogun\". Example 2: Input: [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"] [\"KFC\", \"Shogun\", \"Burger King\"] Output: [\"Shogun\"] Explanation: The restaurant they both like and have the least index sum is \"Shogun\" with index sum 1 (0+1). Note: 1. The length of both lists will be in the range of [1, 1000]. 2. The length of strings in both lists will be in the range of [1, 30]. 3. The index is starting from 0 to the list length minus 1. 4. No duplicates in both lists. Source link Best practice é¦–å…ˆä»¥ç¬¬ä¸€ä¸ªåˆ—è¡¨å»ºä¸€ä¸ªä»¥indexä¸ºkeyï¼Œstringä¸ºitemçš„å“ˆå¸Œè¡¨ã€‚ ç„¶åéå†ç¬¬äºŒä¸ªåˆ—è¡¨ï¼Œå½“ä¸¤ä¸ªåˆ—è¡¨çš„indexå’Œæ¯”ä¹‹å‰å°æ—¶åˆ·æ–°è¾“å‡ºåˆ—è¡¨ï¼Œç›¸ç­‰æ—¶åœ¨è¾“å‡ºåˆ—è¡¨åæ·»åŠ ç¬¬äºŒä¸ªåˆ—è¡¨çœŸçš„stringã€‚ C++ : hash table class Solution { public : int max_int = 2147483647 ; vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > result ; unordered_map < string , int > hashtable ; int count1 = list1 . size (); int count2 = list2 . size (); for ( int i = 0 ; i < count1 ; i ++ ) { hashtable [ list1 [ i ]] = i ; } for ( int i = 0 ; i < count2 ; i ++ ) { int j = hashtable . count ( list2 [ i ]) > 0 ? hashtable [ list2 [ i ]] : - 1 ; if ( j != - 1 && i + j <= max_int ) { if ( i + j < max_int ) { result . clear (); max_int = i + j ; } result . push_back ( list2 [ i ]); } } return result ; } }; Mark: 92ms Additional","tags":"C","title":"LeetCode - Minimum Index Sum of Two Lists"},{"url":"leetcode-invert-binary-tree.html","text":"Description Invert a binary tree. 4 / \\ 2 7 / \\ / \\ 1 3 6 9 to 4 / \\ 7 2 / \\ / \\ 9 6 3 1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can't invert a binary tree on a whiteboard so fuck off. Source link Best practice å¾ˆå®¹æ˜“å°±èƒ½æƒ³åˆ°ç”¨é€’å½’çš„æ–¹å¼ï¼Œå®é™…ä¸€åšéå¸¸ç®€å•ã€‚è¢«è¿™ä¸ªè€å“¥æ€¼çš„è°·æ­Œå†…å¿ƒä¸€å®šæ„Ÿåˆ°å¾ˆå§”å±ˆå§ã€‚ C++ -- recursion class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( root != NULL ) { invertTree ( root -> left ); invertTree ( root -> right ); swap ( root -> left , root -> right ); } return root ; } }; Mark: 3ms è¿™æ˜¯ä¸€ä¸ªç”¨é˜Ÿåˆ—å‚¨å­˜äºŒå‰æ ‘èŠ‚ç‚¹çš„éé€’å½’ç®—æ³•ï¼Œå¯èƒ½ä¼šæ¯”è¾ƒå¿«ä¸€ç‚¹å§ã€‚ C++ -- queue class Solution { public : TreeNode * invertTree ( TreeNode * root ) { queue < TreeNode *> record ; record . push ( root ); while ( ! record . empty ()){ TreeNode * node = record . front (); record . pop (); if ( node != NULL ){ record . push ( node -> left ); record . push ( node -> right ); swap ( node -> left , node -> right ); } } return root ; } }; Mark: 0ms Additional","tags":"C","title":"LeetCode - Invert binary tree"},{"url":"zong-jie-ru-he-yong-wei-yun-suan-lai-jian-dan-gao-xiao-di-jie-jue-wen-ti.html","text":"Question Calculate the sum of two integers a and b, but you are not allowed to use the operator + and - . Example: Given a = 1 and b = 2, return 3. Source link ç®€ä»‹ ä½è¿ç®—æ˜¯æŒ‡ç”¨ç®—æ³•æ¥æ“ä½œæ¯”ç‰¹æˆ–è€…å…¶ä»–å°äºä¸€ä¸ªå­—æ¯çš„æ•°æ®. å¸¸è§çš„éœ€è¦åˆ©ç”¨ä½è¿ç®—å®ç°çš„ç¼–ç¨‹ä»»åŠ¡æœ‰ï¼šåº•å±‚è®¾å¤‡æ§åˆ¶ã€é”™è¯¯æ£€æµ‹å’ŒçŸ«æ­£ç®—æ³•ã€æ•°æ®å‹ç¼©ã€åŠ å¯†ç®—æ³•åŠä¼˜åŒ–ç®—æ³•. å¯¹äºå…¶ä»–å¤§éƒ¨åˆ†ä»»åŠ¡è€Œè¨€ï¼Œ ç°ä»£ç¼–ç¨‹è¯­è¨€é€šå¸¸å…è®¸ç¨‹åºå‘˜è·ŸæŠ½è±¡åŒ–çš„ä½è¿ç®—äº¤äº’è€Œéç›´æ¥ä½¿ç”¨ä½è¿ç®—. ä½è¿ç®—é€šå¸¸åŒ…å«ä»¥ä¸‹æ“ä½œç¬¦: AND, OR, XOR, NOTå’Œbit shifts. åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç”±äºä½æ“ä½œæ˜¯å¹¶è¡Œè¿›è¡Œçš„ï¼Œ å› æ­¤é€šå¸¸èƒ½å¤Ÿå»é™¤æˆ–è€…å‡å°‘å¯¹ä¸€ä¸ªæ•°æ®æ ¼å¼çš„å¾ªç¯éå†ï¼Œ å¸¦æ¥è¿ç®—é€Ÿåº¦çš„æˆå€æå‡. ä½†ä¸æ­¤åŒæ—¶ï¼Œ ä½æ“ä½œçš„ä»£ç ä¹Ÿä¼šæ›´éš¾ç¼–å†™å’Œç»´æŠ¤ã€‚ è¯¦ç»†å†…å®¹ åŸºç¡€ ä½æ“ä½œçš„æ ¸å¿ƒæ˜¯ä½è¿ç®—ç¬¦ & (ä¸), | (æˆ–), ~ (é) and &#94; (å¼‚æˆ–) å’Œ ç§»ä½æ“ä½œ a << b and a >> b. å¼‚æˆ–è¿ç®—ç¬¦æ²¡æœ‰å¯¹åº”çš„å¸ƒå°”è¿ç®—ç¬¦ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬å¯¹å®ƒä½œä¸€ä¸ªç®€å•çš„è§£é‡Š. å¼‚æˆ–æ“ä½œç¬¦æ¥å—ä¸¤ä¸ªè¾“å…¥ï¼Œå½“ä¸”ä»…å½“æœ‰ä¸”åªæœ‰ä¸€ä¸ªè¾“å…¥ä¸º1çš„æ—¶å€™å®ƒæ‰ä¼šè¿”å›1. ä¹Ÿå°±æ˜¯å½“ä¸¤ä¸ªè¾“å…¥ä¸åŒçš„æ—¶å€™è¿”å›1ï¼Œç›¸åŒçš„æ—¶å€™å°±ä¼šè¿”å›0. å¼‚æˆ–æ“ä½œç¬¦é€šå¸¸ç”¨&#94;ç¬¦å·è¡¨ç¤ºï¼Œç¼©å†™ä¸ºXOR. Set å¹¶é›† A | B Set äº¤é›† A & B Set å·®é›† A & ~B Set éé›† ALL_BITS&#94; A or ~A å°†Açš„ç¬¬bitä½è®¾ä¸º1 A |= 1 << bit å°†Açš„ç¬¬bitä½è®¾ä¸º0 `A &= ~(1 << bit)`` æµ‹è¯•ç¬¬bitä½æ˜¯å¦ä¸º0 (A & 1 << bit) != 0 å–å‡ºæœ€å1çš„å€¼ A&-A or A&~(A-1) or x&#94;(x&(x-1)) åˆ é™¤æœ€å1çš„å€¼ A&(A-1) æ„å»ºå…¨ä¸º1çš„äºŒè¿›åˆ¶æ•° ~0 (((unsigned)~0) >> 1 == 01111111111111111111111111111111) è´Ÿæ•°çš„è¿ç®—æ˜¯ä»¥è¡¥ç å½¢å¼è¿›è¡Œçš„ï¼Œå¦‚æœè¿ç®—ç»“æœé¦–ä½ä¸º1ï¼Œç»“æœä¹Ÿéœ€è¦æ±‚ä¸€æ¬¡è¡¥ç . å®ä¾‹ æ±‚æ‰€ç»™æ•°å­—äºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„1çš„æ•°é‡ï¼š int count_one ( int n ) { while ( n ) { n = n & ( n - 1 ); count ++ ; } return count ; } æ˜¯4çš„å¹‚æ•°å˜›ï¼Ÿ (äº‹å®ä¸Šå›¾æ£€æŸ¥æ–¹æ³•ã€ è¿­ä»£å’Œé€’å½’å¯ä»¥åšåˆ°ä¸€æ ·çš„æ•ˆæœ) bool isPowerOfFour ( int n ) { return ! ( n & ( n - 1 )) && ( n & 0x55555555 ); //åªæœ‰ä¸€ä¸ª1ä½(0x55555555 =1010101010101010101010101010101); } &#94; çš„æŠ€å·§ &#94; å¯ä»¥ç”¨æ¥æ¶ˆé™¤å¶æ•°ä¸ªä¸ªä¸€æ¨¡ä¸€æ ·çš„æ•°å­—å¹¶ä¸”ä¿ç•™å¥‡æ•°çš„æ•°å­—å¯¹, æˆ–è€…ä¿å­˜ä¸ä¸€æ ·çš„å¯¹åº”ä½å¹¶ä¸”ç§»é™¤ä¸€æ ·çš„å¯¹åº”ä½. ä¸¤æ•°æ±‚å’Œ ä½¿ç”¨ &#94; å’Œ & æ¥è¿›è¡Œä¸¤æ•°æ±‚å’Œ int getSum ( int a , int b ) { return b == 0 ? a : getSum ( a &#94; b , ( a & b ) << 1 ); //æ³¨æ„ç»ˆæ­¢æ¡ä»¶ï¼Œ(0,1)å¯¹åº”ä½ä¸º1ï¼Œ(1,1)å¯¹åº”ä½è¿›ä½; } ä¸¢å¤±çš„æ•°å­— å·²çŸ¥ä¸€ä¸ªæ•°ç»„åŒ…å«nä¸ªä¸åŒçš„æ•°å­—ï¼š 0, 1, 2, ..., n, æ‰¾åˆ°é‚£ä¸ªä¸åœ¨æ•°ç»„ä¸­çš„æ•°å­—ã€‚ ä¾‹å¦‚, æ‰€ç»™æ•°ç»„ = [0, 1, 3] åˆ™è¿”å› 2. int missingNumber ( vector < int >& nums ) { int ret = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { ret &#94;= i ; ret &#94;= nums [ i ]; } return ret &#94;= nums . size (); } | çš„æŠ€å·§ ä¿å­˜å°½å¯èƒ½å¤šçš„1ä½ æ‰¾åˆ°å°äºæˆ–ç­‰äºNçš„2çš„æœ€å¤§çš„å¹‚æ•° (æœ€å¤§äºŒè¿›åˆ¶æ•°). long largest_power ( long N ) { //å°†æ‰€æœ‰å³ä¾§çš„ä½ ç½®ä¸º 1. N = N | ( N >> 1 ); N = N | ( N >> 2 ); N = N | ( N >> 4 ); N = N | ( N >> 8 ); N = N | ( N >> 16 ); return ( N + 1 ) >> 1 ; } åè½¬æ¯”ç‰¹ åè½¬ä¸€ä¸ªæ‰€ç»™çš„ 32 bits unsigned integer. uint32_t reverseBits ( uint32_t n ) { unsigned int mask = 1 << 31 , res = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { if ( n & 1 ) res |= mask ; mask >>= 1 ; n >>= 1 ; } return res ; } uint32_t reverseBits ( uint32_t n ) { uint32_t mask = 1 , ret = 0 ; for ( int i = 0 ; i < 32 ; ++ i ){ ret <<= 1 ; if ( mask & n ) ret |= 1 ; mask <<= 1 ; } return ret ; } & çš„æŠ€å·§ & å…·æœ‰é€‰æ‹©æŒ‡å®šçš„ä½çš„åŠŸèƒ½ã€‚ åè½¬æ•´æ•°ä¸­çš„ä½ x = (( x & 0xaaaaaaaa ) >> 1 ) | (( x & 0x55555555 ) << 1 ); x = (( x & 0xcccccccc ) >> 2 ) | (( x & 0x33333333 ) << 2 ); x = (( x & 0xf0f0f0f0 ) >> 4 ) | (( x & 0x0f0f0f0f ) << 4 ); x = (( x & 0xff00ff00 ) >> 8 ) | (( x & 0x00ff00ff ) << 8 ); x = (( x & 0xffff0000 ) >> 16 ) | (( x & 0x0000ffff ) << 16 ); ä½è¿ç®—ç¬¦ AND æ•°å­—èŒƒå›´ å·²çŸ¥èŒƒå›´ [m, n] å…¶ä¸­ 0 <= m <= n <= 2147483647, è¿”å›å¯¹èŒƒå›´ä¸­çš„æ‰€æœ‰æ•°æ®æŒ‰ä½è®¡ç®—ç¬¦ANDè®¡ç®—çš„ç»“æœã€‚ ä¾‹å¦‚, è¾“å…¥ [5, 7], åˆ™è¿”å› 4. int rangeBitwiseAnd ( int m , int n ) { int a = 0 ; while ( m != n ) { m >>= 1 ; n >>= 1 ; a ++ ; } return m << a ; } 1çš„æ•°é‡ int hammingWeight ( uint32_t n ) { ulong mask = 1 ; int count = 0 ; for ( int i = 0 ; i < 32 ; ++ i ){ //31 will not do, delicate; if ( mask & n ) count ++ ; mask <<= 1 ; } return count ; } åº”ç”¨ é‡å¤DNAåºåˆ— æ‰€æœ‰DNAç”±ä¸€ç³»åˆ—ç¼©å†™ä¸ºAã€Gã€Cã€Tçš„æ ¸è‹·é…¸ç»„æˆ, ä¾‹å¦‚: \"ACGAATTCCG\". å½“ç ”ç©¶DNAåºåˆ—çš„æ—¶å€™ï¼ŒDNAä¸­çš„é‡å¤åºåˆ—æ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„çš„éƒ¨åˆ†. ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ‰¾åˆ°å‡ºç°å¤šäºä¸¤æ¬¡çš„åå­—ç¬¦é•¿åº¦åºåˆ—ã€‚ ä¾‹å¦‚, ç»™å‡º s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\", è¿”å›: [\"AAAAACCCCC\", \"CCCCCAAAAA\"]. class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { int sLen = s . length (); vector < string > v ; if ( sLen < 11 ) return v ; char keyMap [ 1 << 21 ]{ 0 }; int hashKey = 0 ; for ( int i = 0 ; i < 9 ; ++ i ) hashKey = ( hashKey << 2 ) | ( s [ i ] - 'A' + 1 ) % 5 ; for ( int i = 9 ; i < sLen ; ++ i ) { if ( keyMap [ hashKey = (( hashKey << 2 ) | ( s [ i ] - 'A' + 1 ) % 5 ) & 0xfffff ] ++ == 1 ) v . push_back ( s . substr ( i - 9 , 10 )); } return v ; } }; ä»¥ä¸Šæ–¹æ³•ä¼šåœ¨é‡å¤åºåˆ—å‡ºç°å¤ªå¤šæ¬¡æ—¶å€™å¤±æ•ˆã€‚ ä¸ºäº†é¿å…è¿™ç§æƒ…å†µçš„å‘ç”Ÿï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ unordered_map<int, int> keyMap æ¥æ›¿ä»£è¿™é‡Œçš„ char keyMap[1<<21]{0} . ä¸»å…ƒç´  å¯¹äºä¸€ä¸ªå¤§å°ä¸ºnçš„æ•°ç»„ï¼Œæ±‚å…¶ä¸»å…ƒç´ . ä¸»å…ƒç´ æ˜¯åœ¨æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°å¤§äº âŒŠ n/2 âŒ‹ æ¬¡çš„å…ƒç´ . (æ¯”ç‰¹è®¡æ•°æ˜¯ä¸æ˜¯ä¸€ä¸ªé€šå¸¸æ–¹æ³•, æˆ‘ä»¬é€šå¸¸ä¼šåº”ç”¨æ’åºå’ŒMoore Votingç®—æ³•) int majorityElement ( vector < int >& nums ) { int len = sizeof ( int ) * 8 , size = nums . size (); * int count = 0 , mask = 1 , ret = 0 ; for ( int i = 0 ; i < len ; ++ i ) { count = 0 ; for ( int j = 0 ; j < size ; ++ j ) if ( mask & nums [ j ]) count ++ ; if ( count > size / 2 ) ret |= mask ; mask <<= 1 ; } return ret ; } å•ä¸€æ•°å­— III å¯¹äºç»™äºˆçš„ä¸€ä¸ªæ•´æ•°æ•°ç»„, é™¤äº†ä¸€ä¸ªå…ƒç´ ä»¥å¤–çš„æ‰€æœ‰å…ƒç´ ä¼šå‡ºç°ä¸‰æ¬¡ï¼Œä½ çš„ç›®æ ‡æ˜¯æ‰¾åˆ°é‚£ä¸ªå•ä¸€çš„æ•°å­—. (è¿™ç§ç±»å‹çš„é—®é¢˜åŒæ ·ä¹Ÿå¯ä»¥ç”¨æ¯”ç‰¹è®¡æ•°ç®€å•åœ°è§£å†³ï¼Œä½†åœ¨è¿™é‡Œæˆ‘ä»¬å°†ä½¿ç”¨ digital logic design æ¥å¤„ç†å®ƒ) //inspired by logical circuit design and boolean algebra; //counter - unit of 3; //current incoming next //a b c a b //0 0 0 0 0 //0 1 0 0 1 //1 0 0 1 0 //0 0 1 0 1 //0 1 1 1 0 //1 0 1 0 0 //a = a&~b&~c + ~a&b&c; //b = ~a&b&~c + ~a&~b&c; //return a|b since the single number can appear once or twice; int singleNumber ( vector < int >& nums ) { int t = 0 , a = 0 , b = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { t = ( a &~ b &~ nums [ i ]) | ( ~ a & b & nums [ i ]); b = ( ~ a & b &~ nums [ i ]) | ( ~ a &~ b & nums [ i ]); a = t ; } return a | b ; } æœ€å¤§å­—æ¯é•¿åº¦ç»„åˆ å¯¹äºç»™äºˆçš„ä¸€ç»„å•è¯, æ‰¾åˆ°å•è¯é•¿åº¦(word[i]) * length(word[j])ä¹‹ç§¯çš„æœ€å¤§å€¼ï¼Œ è¦æ±‚ä¸¤ä¸ªå•è¯ä¸èƒ½æœ‰ç›¸åŒçš„å­—æ¯. ä½ å¯ä»¥å‡å®šæ‰€æœ‰å•è¯åªåŒ…å«å°å†™å­—æ¯. å¦‚æœæ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„å•è¯ç»„å­˜åœ¨åˆ™è¿”å› 0. ç¤ºä¾‹ 1: ç»™äºˆ [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"] è¿”å› 16 ç¬¦åˆæ¡ä»¶çš„ä¸¤ä¸ªå•è¯å¯ä»¥æ˜¯ \"abcw\", \"xtfn\". ç¤ºä¾‹ 2: ç»™äºˆ [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"] è¿”å› 4 ç¬¦åˆæ¡ä»¶çš„ä¸¤ä¸ªå•è¯å¯ä»¥æ˜¯ \"ab\", \"cd\". ç¤ºä¾‹ 3: ç»™äºˆ [\"a\", \"aa\", \"aaa\", \"aaaa\"] è¿”å› 0 æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„å•è¯ç»„. æ˜¾ç„¶æˆ‘ä»¬å°†ä¼šé¢‘ç¹ä½¿ç”¨å•è¯çš„é•¿åº¦ä»¥åŠæ¯”è¾ƒä¸¤ä¸ªå•è¯æ˜¯å¦æ‹¥æœ‰ç›¸åŒçš„å­—æ¯: ä½¿ç”¨ä¸€ä¸ªæ•´å½¢æ•°ç»„å»é¢„å­˜æ¯ä¸ªå•è¯çš„é•¿åº¦å°†èƒ½å¤Ÿæœ‰æ•ˆå‡å°‘æµ‹é‡é•¿åº¦è¿™ä¸€è¿‡ç¨‹é¢‘åº¦; æ•´å½¢æ˜¯ä¸€ä¸ªå››ä¸ªå­—èŠ‚ä¸‰åäºŒä½å­˜å‚¨å•å…ƒ, è€Œæˆ‘ä»¬åªæœ‰äºŒåå…­ä¸ªä¸åŒçš„å­—æ¯, æ‰€ä»¥æˆ‘ä»¬å°±å¯ä»¥ç”¨æ¯ä¸€ä½æ¥è¡¨ç¤ºå•è¯æ˜¯å¦åŒ…å«æŸä¸€å­—æ¯. int maxProduct ( vector < string >& words ) { vector < int > mask ( words . size ()); vector < int > lens ( words . size ()); for ( int i = 0 ; i < words . size (); ++ i ) lens [ i ] = words [ i ]. length (); int result = 0 ; for ( int i = 0 ; i < words . size (); ++ i ) { for ( char c : words [ i ]) mask [ i ] |= 1 << ( c - 'a' ); for ( int j = 0 ; j < i ; ++ j ) if ( ! ( mask [ i ] & mask [ j ])) result = max ( result , lens [ i ] * lens [ j ]); } return result ; } æ³¨æ„ å·¦å³ä½ç§»å¤ªå¤šçš„è¿”å›å€¼æ˜¯ undefined å¯¹äºè´Ÿæ•°çš„å³ç§»å¤ªå¤šçš„è¿”å›å€¼æ˜¯ undefined right operand in shifting should be non-negative, otherwise the result is undefined & å’Œ | è¿ç®—ç¬¦ç›¸å¯¹äºæ¯”è¾ƒè¿ç®—ç¬¦æ¥è¯´æ‹¥æœ‰æ›´ä½çš„ä¼˜å…ˆçº§ é›†åˆ æ‰€æœ‰çš„å­é›† åœ¨è¿™ç§æƒ…å†µä¸‹ä½æ“ä½œä¼šä½“ç°å‡ºå·¨å¤§çš„ä¼˜åŠ¿ï¼šå½“éå†ä¸€ä¸ªNå…ƒç´ é›†åˆçš„æ‰€æœ‰å­é›†æ˜¯éå¸¸ç¹ççš„æ—¶å€™ï¼Œè€Œä¸€ä¸ªNä½æ¯”ç‰¹å€¼èƒ½å¤Ÿè¡¨ç¤ºå…¶æ‰€æœ‰å­é›†ã€‚ å¦‚æœAæ˜¯Bçš„å­é›†ï¼Œåˆ™è¡¨è¾¾Aæ‰€éœ€çš„æ•°å­—å°äºç›´æ¥è¡¨ç¤ºBæ—¶å€™ï¼Œä½æ“ä½œå¯¹äºä¸€äº›åŠ¨æ€çš„ç¼–ç¨‹æ–¹æ¡ˆæ˜¯ä¸€ä¸ªæ›´å¥½çš„é€‰æ‹©ã€‚ å¦‚æœä½ ä¸ä»‹æ„ä»¥é€†åºéå†å­é›†çš„è¯ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨ä¸€ä¸ªç‰¹å®šçš„å­é›†é‡Œéå†åˆ°æ‰€æœ‰å¯èƒ½çš„å­é›†æ˜ŸçŸ¢ (ç”¨æ¯”ç‰¹æ¨¡å¼è¡¨ç¤º). ä½¿ç”¨çš„æŠ€å·§å’Œæ‰¾åˆ°æ•°å­—ä¸­çš„æœ€ä½ä½çš„æ–¹æ³•ç›¸ä¼¼. å¦‚æœæˆ‘ä»¬ä»ä¸€ä¸ªå­é›†ä¸­å‡å»1, åˆ™é›†åˆçš„æœ€ä½çš„å…ƒç´ å°†ä¼šè¢«æ¸…æ¥š, å¹¶ä¸”æ¯ä¸ªæ›´ä½çš„å…ƒç´ å°†ä¼šè¢«è®¾ç½®. ç„¶è€Œ, æˆ‘ä»¬ä»…ä»…æƒ³è¦åœ¨çˆ¶é›†åˆä¸­è®¾ç½®è¿™äº›æ›´ä½çš„å…ƒç´ . å› æ­¤éå†çš„æ­¥éª¤åªä¼šæ˜¯ i = (i - 1) & superset. vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> vv ; int size = nums . size (); if ( size == 0 ) return vv ; int num = 1 << size ; vv . resize ( num ); for ( int i = 0 ; i < num ; ++ i ) { for ( int j = 0 ; j < size ; ++ j ) if (( 1 << j ) & i ) vv [ i ]. push_back ( nums [ j ]); } return vv ; } äº‹å®ä¸Šè¿˜æœ‰å¦å¤–ä¸¤ç§æ–¹å¼ï¼š recursion å’Œ iteration ä¹Ÿèƒ½åˆ†åˆ«è§£å†³è¿™ä¸ªé—®é¢˜. Bitsetç±» Bitsetå‚¨å­˜ä½ (åªæœ‰ä¸¤ç§å¯èƒ½å€¼çš„å…ƒç´ : 0 or 1, true or false, ...). è¿™ä¸ªç±»æœ‰äº›ç±»ä¼¼å¸ƒå°”å€¼æ•°ç»„ï¼Œä¸è¿‡å…·æœ‰ç©ºé—´ä¼˜åŒ–ï¼šé€šå¸¸æ¯ä¸ªå…ƒç´ åªå ä¸€ä½ (åœ¨å¤§éƒ¨åˆ†ç³»ç»Ÿä¸­æ¯”æœ€å°çš„å…ƒç´ ç§ç±»ï¼šcharå°å…«å€). // bitset::count #include <iostream> // std::cout #include <string> // std::string #include <bitset> // std::bitset int main () { std :: bitset < 8 > foo ( std :: string ( \"10110011\" )); std :: cout << foo << \" has \" ; std :: cout << foo . count () << \" ones and \" ; std :: cout << ( foo . size () - foo . count ()) << \" zeros. \\n \" ; return 0 ; }","tags":"Python,C","title":"æ€»ç»“ï¼šå¦‚ä½•ç”¨ä½è¿ç®—æ¥ç®€å•é«˜æ•ˆåœ°è§£å†³é—®é¢˜"},{"url":"leetcode-find-the-difference.html","text":"Description Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t . Example: Input : s = \"abcd\" t = \"abcde\" Output : e Explanation : 'e' is the letter that was added . Source link Best practice ä½¿ç”¨å¼‚æˆ–å’ŒC++11çš„éå†ç‰¹æ€§ã€‚ C++ class Solution { public : char findTheDifference ( string s , string t ) { char r = 0 ; for ( char c : s ) r &#94;= c ; for ( char c : t ) r &#94;= c ; return r ; } }; Mark: 6ms Python version class Solution ( object ): def findTheDifference ( self , s , t ): \"\"\" :type s: str :type t: str :rtype: str \"\"\" asc = 0 ; for item in t : asc += ord ( item ) for item in s : asc -= ord ( item ) return chr ( asc ) class Solution ( object ): def findTheDifference ( self , s , t ): \"\"\" :type s: str :type t: str :rtype: str \"\"\" ans = 0 for c in s + t : ans &#94;= ord ( c ) return chr ( ans ) Mark: 35ms Additional","tags":"Python,C","title":"LeetCode - Find the Difference"},{"url":"leetcode-most-frequent-subtree-sum.html","text":"Description Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order. Examples 1 Input : 5 / \\ 2 - 3 return [2, -3, 4], since all the values happen only once, return all of them in any order. Examples 2 Input : 5 / \\ 2 - 5 return [2], since 2 happens twice, however -5 only occur once. Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer. Source link Best practice C++çš„regæœ‰ç‚¹æ…¢å•Š! C++ reg verison /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { private : unordered_map < int , int > mp ; int max = 0 ; public : vector < int > findFrequentTreeSum ( TreeNode * root ) { vector < pair < int , int >> v ; vector < int > res ; calSum ( root ); for ( auto & it : mp ) if ( it . second == max ) res . push_back ( it . first ); return res ; } int calSum ( TreeNode * root ) { if ( root == NULL ) return 0 ; int k ; k = root -> val + calSum ( root -> left ) + calSum ( root -> right ); mp [ k ] ++ ; max = max < mp [ k ] ? mp [ k ] : max ; return k ; } }; Mark: 12ms æ™®é€šçš„dfséå†,éå†çš„åŒæ—¶ä¿å­˜æœ€å¤§å€¼å‡ºç°æ¬¡æ•°ã€‚ Python version - dfs class Solution ( object ): count = 0 def findFrequentTreeSum ( self , root ): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" dic = {} self . helper ( root , dic ) return [ item for item in dic . keys () if dic [ item ] == self . count ] def helper ( self , node , dic ): if not node : return 0 sums = node . val + self . helper ( node . left , dic ) + self . helper ( node . right , dic ) dic [ sums ] = dic . get ( sums , 0 ) + 1 self . count = max ( self . count , dic [ sums ]) return sums Mark: 78ms Additional","tags":"Python,C","title":"LeetCode - Most Frequent Subtree Sum"},{"url":"leetcode-detect-capital.html","text":"Description Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like \"USA\". All letters in this word are not capitals, like \"leetcode\". Only the first letter in this word is capital if it has more than one letter, like \"Google\". Otherwise, we define that this word doesn't use capitals in a right way. Example 1: Input: \"USA\" Output: True Example 2: Input: \"FlaG\" Output: False Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters. Source link Best practice C++çš„regæœ‰ç‚¹æ…¢å•Š! C++ reg verison class Solution { public : bool detectCapitalUse ( string & word ) { const regex pattern ( \"[A-Z]+$|[a-z]+$|[A-Z][a-z]*$\" ); match_results < string :: const_iterator > result ; bool valid = regex_match ( word , result , pattern ); return valid ; } }; Mark: 149ms åˆ©ç”¨æ­£åˆ™è¡¨è¾¾å¼å†™çš„æ ‡å‡†åŒ¹é…ç¨‹åºã€‚ Python version v1 - Re solution class Solution ( object ): def detectCapitalUse ( self , word ): \"\"\" :type word: str :rtype: bool \"\"\" return True if re . match ( r '[A-Z]+$|[a-z]+$|[A-Z][a-z]*$' , word ) else False Mark: 45ms çœ‹äº†å…¶ä»–å°ä¼™å­çš„ä»£ç ä¹‹åå‘ç°pythonæœ‰è‡ªå·±å®šä¹‰çš„æ–¹æ³•åŒ¹é…é¢˜ç›®æ‰€è¿°çš„ä¸‰é’Ÿstringçš„æƒ…å†µï¼Œä¾¿æœ‰äº†ä»¥ä¸‹ä»£ç ã€‚ Python version v2 - Bulit in solution class Solution ( object ): def detectCapitalUse ( self , word ): \"\"\" :type word: str :rtype: bool \"\"\" return word . isupper () or word . istitle () or word . islower () Mark: 38ms Additional","tags":"Python,C","title":"LeetCode - Detect Capital"},{"url":"leetcode-convert-bst-to-greater-tree.html","text":"Description Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: Input : The root of a Binary Search Tree like this : 5 / \\ 2 13 Output : The root of a Greater Tree like this : 18 / \\ 20 13 Source link Best practice åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§ï¼Œä»¥å³ä¸­å·¦çš„æ–¹å¼éå†å…¨æ ‘ã€‚pythonç‰ˆæœ¬å…ˆå®Œæˆï¼Œä½¿ç”¨äº†å…¨å±€å˜é‡è®°å½•ç´¯è®¡å€¼æ¥è¾…åŠ©é€’å½’ã€‚C++ç‰ˆæœ¬åˆ™å°†å˜é‡åŠ å…¥é€’å½’,ä¸ä½¿ç”¨å…¨å±€å˜é‡ã€‚ C++ version class Solution { public : int helper ( TreeNode * root , int cum ) { if ( root -> right ) cum = helper ( root -> right , cum ); root -> val = root -> val + cum ; return ( root -> left ) ? helper ( root -> left , root -> val ) : root -> val ; } TreeNode * convertBST ( TreeNode * root ) { if ( ! root ) return NULL ; helper ( root , 0 ); return root ; } }; Mark: 35ms Python version class Solution ( object ): cum = 0 def convertBST ( self , root ): \"\"\" :type root: TreeNode :rtype: TreeNode \"\"\" self . helper ( root ) return root def helper ( self , node ): if not node : return self . helper ( node . right ) self . cum += node . val node . val = self . cum self . helper ( node . left ) Mark: 178ms Additional","tags":"Python,C","title":"LeetCode - Convert BST to Greater Tree"},{"url":"leetcode-longest-uncommon-subsequence-i.html","text":"Description Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence . If the longest uncommon subsequence doesn't exist, return -1. Example 1: Input: \"aba\", \"cdc\" Output: 3 Explanation: The longest uncommon subsequence is \"aba\" (or \"cdc\"), because \"aba\" is a subsequence of \"aba\", but not a subsequence of any other strings in the group of two strings. Note: Both strings' lengths will not exceed 100. Only letters from a ~ z will appear in input strings. Source link Best practice è¿™å…¶å®æ˜¯ä¸ªå¾ˆæ†¨åšçš„é—®é¢˜ã€‚ For strings A, B, when len(A) > len(B), the longest possible subsequence of either A or B is A, and no subsequence of B can be equal to A. Answer: len(A). When len(A) == len(B), the only subsequence of B equal to A is B; so as long as A != B, the answer remains len(A). When A == B, any subsequence of A can be found in B and vice versa, so the answer is -1. Python version class Solution ( object ): def findLUSlength ( self , a , b ): \"\"\" :type a: str :type b: str :rtype: int \"\"\" if a == b : return - 1 return max ( len ( a ), len ( b )) Mark: 45ms Additional Python String","tags":"Python,C","title":"LeetCode - Longest Uncommon Subsequence I"},{"url":"leetcode-single-number.html","text":"Description Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Source link Best practice åˆ©ç”¨å¼‚æˆ–ä½è¿ç®—æ¶ˆé™¤æˆå¯¹å‡ºç°çš„å…ƒç´ åªç•™ä¸‹é‚£ä¸ªå•èº«å…ƒç´ ã€‚ C++ version class Solution { public : int singleNumber ( vector < int >& nums ) { int result = 0 ; int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) { result = result &#94; nums [ i ]; } return result ; } }; Mark: 16ms Python version class Solution ( object ): def singleNumber ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" result = 0 for item in nums : result &#94;= item return result Mark: 45ms Additional æ¥è°ˆè°ˆC++ ä½è¿ç®—","tags":"Python,C","title":"LeetCode - Single Number"},{"url":"leetcode-find-largest-value-in-each-tree-row.html","text":"Description You need to find the largest value in each row of a binary tree. Example: Input : 1 / \\ 3 2 / \\ \\ 5 3 9 Output : [ 1 , 3 , 9 ] Source link Best practice è®¾æ ‘æ ¹ä¸ºç¬¬0å±‚ï¼Œåˆ™ç¬¬iå±‚çš„æœ€å¤§å€¼ç­‰äºç»“æœé›†result[i]ã€‚éå†æ¯ä¸€å±‚æ¯”è¾ƒç›¸åŒåºå·çš„æ ¹å€¼çš„æœ€å¤§å€¼ã€‚ C++ version #include <iostream> #include <vector> #include <algorithm> class Solution { vector < int > result ; public : vector < int > largestValues ( TreeNode * root ) { helper ( root , 0 ); return result ; } void helper ( TreeNode * node , int level ) { if ( ! node ) return ; if ( result . size () <= level ) { result . push_back ( node -> val ); } else { result [ level ] = max ( result [ level ], node -> val ); } helper ( node -> left , level + 1 ); helper ( node -> right , level + 1 ); } }; Mark: 12ms æœ¬é¢˜å…ˆç”Ÿæˆä¸€è¡Œä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œä¹‹åå†æ¯”è¾ƒå‡ºæœ€å¤§å€¼ã€‚ Python version class Solution ( object ): def largestValues ( self , root ): \"\"\" :type root: TreeNode :rtype: List[int] \"\"\" lst = [] child = [ root ] while any ( child ): lst . append ( max ([ item . val for item in child ])) child = [ item for node in child for item in filter ( None ,( node . left , node . right ))] return lst Mark: 96ms Additional C++æŒ‡é’ˆè¯¦è§£","tags":"Python,C","title":"LeetCode - Find Largest Value in Each Tree Row"},{"url":"leetcode-find-all-duplicates-in-an-array.html","text":"Description Given an array of integers, 1 â‰¤ a[i] â‰¤ n (n = size of array), some elements appear twice and others appear once . Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime? Example: Input : [ 4 , 3 , 2 , 7 , 8 , 2 , 3 , 1 ] Output : [ 2 , 3 ] Source link Best practice æ•°åˆ—æœ‰ä¸¤ä¸ªç‰¹å¾ï¼šä¸€æ˜¯é•¿åº¦ä¸ºnçš„æ•°åˆ—åªä¼šç”±1åˆ°nçš„æ•°å­—ç»„æˆï¼ŒäºŒæ˜¯é‡å¤æ•°é‡ä¸è¶…è¿‡ä¸¤æ¬¡ã€‚å¯¹äºä»»æ„ä¸€ä¸ªæ•°åˆ—å…ƒç´ iï¼Œåºå·i-1å¿…å®šå­˜åœ¨ä¸”å”¯ä¸€ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨æ•°åˆ—çš„åºå·ä½¿æ•°åˆ—æœ¬èº«æˆä¸ºä¸€ä¸ªå­˜æ”¾å·²åŒ¹é…åˆ°æ•°å­—çš„å“ˆå¸Œè¡¨â€”â€”å½“åŒ¹é…å…ƒç´ å€¼æ—¶ï¼Œå°†å…¶å¯¹åº”çš„åºå·çš„å…ƒç´ å€¼è®¾ä¸ºè´Ÿæ•°ã€‚ C++ version class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > res ; for ( int i = 0 ; i < nums . size (); i ++ ) { int index = abs ( nums [ i ]) - 1 ; if ( nums [ index ] < 0 ) { res . push_back ( abs ( nums [ i ])); } else { nums [ index ] = - nums [ index ]; } } return res ; } }; Mark: 139ms Python version class Solution ( object ): def findDuplicates ( self , nums ): \"\"\" :type nums: List[int] :rtype: List[int] \"\"\" res = [] for x in nums : if nums [ abs ( x ) - 1 ] < 0 : res . append ( abs ( x )) else : nums [ abs ( x ) - 1 ] *= - 1 print ( nums ) return res Mark: 365ms Additional Find duplicates in O(n) time and O(1) extra space","tags":"Python,C","title":"LeetCode - Find All Duplicates in an Array"},{"url":"leetcode-beautiful-arrangement.html","text":"Description Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the i th position ( 1 â‰¤ i â‰¤ N ) in this array: The number at the i th position is divisible by i . i is divisible by the number at the i th position. Now given N, how many beautiful arrangements can you construct? Example 1: Input : 2 Output : 2 Explanation : The first beautiful arrangement is [ 1 , 2 ]: Number at the 1 st position ( i = 1 ) is 1 , and 1 is divisible by i ( i = 1 ). Number at the 2 nd position ( i = 2 ) is 2 , and 2 is divisible by i ( i = 2 ). The second beautiful arrangement is [ 2 , 1 ]: Number at the 1 st position ( i = 1 ) is 2 , and 2 is divisible by i ( i = 1 ). Number at the 2 nd position ( i = 2 ) is 1 , and i ( i = 2 ) is divisible by 1 . Note : N is a positive integer and will not exceed 15 . Source link Most popular C++ version class Solution { public : int countArrangement ( int N ) { vector < int > vs ; for ( int i = 0 ; i < N ; ++ i ) vs . push_back ( i + 1 ); return counts ( N , vs ); } int counts ( int n , vector < int >& vs ) { if ( n <= 0 ) return 1 ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( vs [ i ] % n == 0 || n % vs [ i ] == 0 ) { swap ( vs [ i ], vs [ n - 1 ]); ans += counts ( n - 1 , vs ); swap ( vs [ i ], vs [ n - 1 ]); } } return ans ; } }; Mark: 6ms My solution C++ version class Solution { public : int count = 0 ; int size = 0 ; int countArrangement ( int N ) { vector < int > vs ; if ( N == 0 ) return 0 ; for ( int i = 0 ; i < N ; ++ i ) vs . push_back ( 0 ); size = N ; helper ( N , vs ); return count ; } void helper ( int n , vector < int > & vs ) { if ( n <= 0 ) { //è¾¹ç•Œæ¡ä»¶ count ++ ; return ; } for ( int i = size - 1 ; i >= 0 ; -- i ) { if (( vs [ i ] == 0 ) && (( i + 1 ) % n == 0 || n % ( i + 1 ) == 0 )) { //å‰ªæ vs [ i ] = 1 ; helper ( n - 1 , vs ); vs [ i ] = 0 ; } } } }; Mark: 16ms DP Python version of leetcode user cache = {} class Solution ( object ): def countArrangement ( self , N ): def helper ( i , X ): if i == 1 : return 1 key = ( i , X ) if key in cache : return cache [ key ] total = 0 for j in range ( len ( X )): if X [ j ] % i == 0 or i % X [ j ] == 0 : total += helper ( i - 1 , X [: j ] + X [ j + 1 :]) cache [ key ] = total #ç”¨å“ˆå¸Œè¡¨æ¥å‚¨å­˜(ä½ç½®,([å‰©ä½™å…ƒç´ ])):é…å¯¹æ•°é‡ ä¿¡æ¯ return total return helper ( N , tuple ( range ( 1 , N + 1 ))) Mark: 66ms Additional å›æº¯ç®—æ³•ä»‹ç»: https://segmentfault.com/a/1190000006121957","tags":"Python,C","title":"LeetCode - Beautiful Arrangement"},{"url":"leetcode-max-consecutive-ones.html","text":"Description Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 Source link Most popular My solution C++ version class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int cnt = 0 ; int ans = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] == 1 ) { ans = ans > ++ cnt ? ans : cnt ; } else { cnt = 0 ; } } return ans ; } }; Mark: 2ms Python version class Solution ( object ): def findMaxConsecutiveOnes ( self , nums ): \"\"\" :type nums: List[int] :rtype: int \"\"\" lst = [ - 1 ] length = len ( nums ) for i in range ( length ): if nums [ i ] == 0 : lst . append ( i ) lst . append ( length ) return max ( map ( lambda x : x [ 1 ] - x [ 0 ] - 1 , zip ( lst [: - 1 ], lst [ 1 :]))) Mark: 105ms Additional","tags":"Python,C","title":"LeetCode - Max Consecutive Ones"},{"url":"leetcode-arithmetic-slices.html","text":"Description A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, these are arithmetic sequence: 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic. 1, 1, 2, 5, 7 A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N. A slice (P, Q) of array A is called arithmetic if the sequence: A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q. The function should return the number of arithmetic slices in the array A. Example: A = [ 1 , 2 , 3 , 4 ] return : 3 , for 3 arithmetic slices in A : [ 1 , 2 , 3 ], [ 2 , 3 , 4 ] and [ 1 , 2 , 3 , 4 ] itself . Source link Most popular python version class Solution ( object ): def numberOfArithmeticSlices ( self , A ): \"\"\" :type A: List[int] :rtype: int \"\"\" opt , i = [ 0 , 0 ], 1 for j in xrange ( 2 , len ( A )): if A [ j ] - A [ j - 1 ] == A [ j - 1 ] - A [ j - 2 ]: opt . append ( opt [ j - 1 ] + i ) i += 1 else : opt . append ( opt [ j - 1 ]) i = 1 return opt [ - 1 ] c++ version for 2ms class Solution { public : int numberOfArithmeticSlices ( vector < int >& A ) { int n = A . size (); if ( n < 3 ) return 0 ; vector < int > dp ( n , 0 ); // dp[i] means the number of arithmetic slices ending with A[i] if ( A [ 2 ] - A [ 1 ] == A [ 1 ] - A [ 0 ]) dp [ 2 ] = 1 ; // if the first three numbers are arithmetic or not int result = dp [ 2 ]; for ( int i = 3 ; i < n ; ++ i ) { // if A[i-2], A[i-1], A[i] are arithmetic, then the number of arithmetic slices ending with A[i] (dp[i]) // equals to: // the number of arithmetic slices ending with A[i-1] (dp[i-1], all these arithmetic slices appending A[i] are also arithmetic) // + // A[i-2], A[i-1], A[i] (a brand new arithmetic slice) // it is how dp[i] = dp[i-1] + 1 comes if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]) dp [ i ] = dp [ i - 1 ] + 1 ; result += dp [ i ]; // accumulate all valid slices } return result ; } }; My solution too ugly to post Additional","tags":"Python","title":"LeetCode - Arithmetic Slices"},{"url":"leetcode-optimal-division.html","text":"Description Given a list of positive integers , the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4. However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis . Example: ** Input ** : [ 1000 , 100 , 10 , 2 ] ** Output ** : \"1000/(100/10/2)\" ** Explanation ** : 1000 / ( 100 / 10 / 2 ) = 1000 / (( 100 / 10 ) / 2 ) = 200 However , the bold parenthesis in \"1000/((100/10)/2)\" are redundant , since they don ' t influence the operation priority . So you should return \"1000/(100/10/2)\" . Other cases : 1000 / ( 100 / 10 ) / 2 = 50 1000 / ( 100 / ( 10 / 2 )) = 50 1000 / 100 / 10 / 2 = 0 . 5 1000 / 100 / ( 10 / 2 ) = 2 Note: 1. The length of the input array is [1, 10]. 2. Elements in the given array will be in range [2, 1000]. 3. There is only one optimal division for each test case. Source link Most popular Regardless of parentheses, every element is either in the numerator or denominator of the final fraction. The expression A[0] / ( A[1] / A[2] / ... / A[N-1] ) has every element in the numerator except A[1], and it is impossible for A[1] to be in the numerator, so it is the largest. We must also be careful with corner cases. class Solution ( object ): def optimalDivision ( self , A ): A = map ( str , A ) if len ( A ) <= 2 : return '/' . join ( A ) return ' {} /( {} )' . format ( A [ 0 ], '/' . join ( A [ 1 :])) My solution class Solution ( object ): def optimalDivision ( self , nums ): \"\"\" :type nums: List[int] :rtype: str \"\"\" length = len ( nums ) if length == 1 : return str ( nums [ 0 ]) elif length == 2 : return str ( nums [ 0 ]) + \"/\" + str ( nums [ 1 ]) return str ( nums [ 0 ]) + \"/(\" + \"/\" . join ( map ( str , nums [ 1 :])) + \")\" Additional","tags":"Python","title":"LeetCode - Optimal Division"},{"url":"leetcode-queue-reconstruction-by-height.html","text":"Description Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k) , where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h . Write an algorithm to reconstruct the queue. Example: Input : [[ 7 , 0 ], [ 4 , 4 ], [ 7 , 1 ], [ 5 , 0 ], [ 6 , 1 ], [ 5 , 2 ]] Output : [[ 5 , 0 ], [ 7 , 0 ], [ 5 , 2 ], [ 6 , 1 ], [ 4 , 4 ], [ 7 , 1 ]] Note: The number of people is less than 1,100. Source link Most popular My solution å…ˆå°†åˆ—è¡¨ä»¥h DEC, k ASCæ’åº å°†å…ƒç´ ä¸€ä¸€å…¥æ ˆ, è‹¥ k > æ ˆæ·±, åˆ™æ— è§£; å¦åˆ™æ’å…¥åˆ°åˆ—è¡¨çš„ä½ç½®k class Solution ( object ): def reconstructQueue ( self , people ): \"\"\" :type people: List[List[int]] :rtype: List[List[int]] \"\"\" stack = [] for item in sorted ( people , key = lambda x : ( - x [ 0 ], x [ 1 ])): if len ( stack ) < item [ 1 ]: return False stack . insert ( item [ 1 ], item ) return stack Additional","tags":"Python","title":"LeetCode - Queue Reconstruction by Height"},{"url":"leetcode-find-bottom-left-tree-value.html","text":"Description Given a binary tree, find the leftmost value in the last row of the tree. Example 1: Input : 2 / \\ 1 3 Output : 1 Example 2: Input : 1 / \\ 2 3 / / \\ 4 5 6 / 7 Output : 7 Note: You may assume the tree (i.e., the given root node) is not NULL. Source link Most popular solution class Solution ( object ): def findLeftMostNode ( self , root ): queue = [ root ] for node in queue : queue += filter ( None , ( node . right , node . left )) return node . val My solution Additional It's leftmost in last row not left left node","tags":"Python","title":"LeetCode - Find Bottom Left Tree Value"},{"url":"leetcode-island-perimeter.html","text":"Description You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have \"lakes\" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island. Example 1: [[ 0 , 1 , 0 , 0 ], [ 1 , 1 , 1 , 0 ], [ 0 , 1 , 0 , 0 ], [ 1 , 1 , 0 , 0 ]] Answer : 16 Explanation : The perimeter is the 16 yellow stripes in the image below : Note: 1. All elements in nums1 and nums2 are unique. 2. The length of both nums1 and nums2 would not exceed 1000. Source link Most popular Since there are no lakes, every pair of neighbour cells with different values is part of the perimeter (more precisely, the edge between them is). So just count the differing pairs, both horizontally and vertically (for the latter I simply transpose the grid). def islandPerimeter ( self , grid ): return sum ( sum ( map ( operator . ne , [ 0 ] + row , row + [ 0 ])) for row in grid + map ( list , zip ( * grid ))) My solution Add 4 for each land and remove 2 for each internal edge. class Solution ( object ): def islandPerimeter ( self , grid ): \"\"\" :type grid: List[List[int]] :rtype: int \"\"\" total = 0 for row in range ( len ( grid )): for column in range ( len ( grid [ row ])): if grid [ row ][ column ] == 1 : total += ( int ( grid [ row - 1 ][ column ] == 1 ) * ( row != 0 ) + int ( grid [ row ][ column - 1 ] == 1 ) * ( column != 0 )) * ( - 2 ) + 4 return total Additional","tags":"Python","title":"LeetCode - Island Perimeter"},{"url":"leetcode-keyboard-row.html","text":"Description Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below. Example 1: Input: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"] Output: [\"Alaska\", \"Dad\"] Note: 1. You may use one character in the keyboard more than once. 2. You may assume the input string will only contain letters of alphabet. Source link My solution class Solution ( object ): def findWords ( self , words ): return list ( filter ( re . compile ( r '(?i)&#94;([qwertyuiop]+|[asdfghjkl]+|[zxcvbnm]+)$' ) . match , words )) Additional Regular Expression","tags":"Python","title":"LeetCode - Keyboard Row"},{"url":"leetcode-next-greater-element-i.html","text":"Description You are given two arrays (without duplicates) nums1 and nums2 where nums1 's elements are subset of nums2 . Find all the next greater numbers for nums1 's elements in the corresponding places of nums2 . The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2 . If it does not exist, output -1 for this number. Example 1: Input : nums1 = [ 4 , 1 , 2 ], nums2 = [ 1 , 3 , 4 , 2 ]. Output : [- 1 , 3 ,- 1 ] Explanation : For number 4 in the first array , you cannot find the next greater number for it in the second array , so output - 1 . For number 1 in the first array , the next greater number for it in the second array is 3 . For number 2 in the first array , there is no next greater number for it in the second array , so output - 1 . Example 2: Input : nums1 = [ 2 , 4 ], nums2 = [ 1 , 2 , 3 , 4 ]. Output : [ 3 ,- 1 ] Explanation : For number 2 in the first array , the next greater number for it in the second array is 3 . For number 4 in the first array , there is no next greater number for it in the second array , so output - 1 . Note: 1. All elements in nums1 and nums2 are unique. 2. The length of both nums1 and nums2 would not exceed 1000. Source link Most popular class Solution ( object ): def nextGreaterElement ( self , findNums , nums ): \"\"\" :type findNums: List[int] :type nums: List[int] :rtype: List[int] \"\"\" d = {} st = [] ans = [] for x in nums : while len ( st ) and st [ - 1 ] < x : d [ st . pop ()] = x st . append ( x ) for x in findNums : ans . append ( d . get ( x , - 1 )) return ans Mark: 83% My solution class Solution ( object ): def nextGreaterElement ( self , findNums , nums ): \"\"\" :type findNums: List[int] :type nums: List[int] :rtype: List[int] \"\"\" lst = [] for k , i in enumerate ( findNums ): for j in nums [ nums . index ( i ):]: if j > i : lst . append ( j ) break if len ( lst ) != k + 1 : lst . append ( - 1 ) return lst Mark: 50% Additional","tags":"Python","title":"LeetCode - Next Greater Element I"},{"url":"leetcode-reverse-words-in-a-string-iii.html","text":"Description Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: Input: \"Let's take LeetCode contest\" Output: \"s'teL ekat edoCteeL tsetnoc\" Note: In the string, each word is separated by single space and there will not be any extra space in the string. Source link Most popular solution class Solution ( object ): def reverseWords ( self , s ): \"\"\" :type s: str :rtype: str \"\"\" return \" \" . join ( map ( lambda x : x [:: - 1 ], s . split ())) My solution class Solution ( object ): def reverseWords ( self , s ): \"\"\" :type s: str :rtype: str \"\"\" string = '' for item in s . split (): string += ( item [:: - 1 ] + ' ' ) return string [: - 1 ] Mark: 38% Additional","tags":"Python","title":"LeetCode - Reverse Words in a String III"},{"url":"markdown-syntax.html","text":"Please Note: This is an unofficial kramdown sandbox, the official complete documentation for kramdown is here . documentation Code This demo uses highlight.js to enable client-side syntax highlighting inline or as a block (auto detect language): def ruby puts \"ruby\" end def hello(): print \"python\" Force language: function hello () { alert ( \"Javascript\" ); } Lists One Two Three Lorem Ipsum Dolar Etc. Dolar Example Meep Meep LaTeX Using MathJax . Inline: $$ \\varphi = \\frac{1+\\sqrt{5}}{2} = 1.61803\\,39887\\ldots. $$ Block: $$ \\int_0&#94;{2\\pi}\\sin{x}\\ dx=0 $$ Tables Header1 Header2 Header3 cell1 cell2 cell3 cell4 cell5 cell6 ---- cell1 cell2 cell3 cell4 cell5 cell6 ===== Foot1 Foot2 Foot3 etc.","tags":"Python","title":"Markdown Syntax"},{"url":"leetcode-array-partition-i.html","text":"Description Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. - Example: ''' Input: [1,4,3,2] Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4. ''' - Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. Source link Most popular solution class Solution ( object ) : def arrayPairSum ( self , nums ) : \"\"\" :type nums: List[int] :rtype: int \"\"\" return sum ( sorted ( nums ) [ ::2 ] ) Mark: 87% My solution class Solution ( object ) : def arrayPairSum ( self , nums ) : \"\"\" :type nums: List[int] :rtype: int \"\"\" nums . sort () return sum ( nums [ ::2 ] ) Mark: 85% Additional ''' Help on method_descriptor: sort(...) L.sort(cmp=None, key=None, reverse=False) -- stable sort IN PLACE ; cmp(x, y) -> -1, 0, 1 help(sorted) Help on built-in function sorted in module builtin : sorted(...) sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list '''","tags":"Python","title":"LeetCode - Array Partition I"},{"url":"leetcode-distribute-candies.html","text":"Description Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. - Example 1: Input : candies = [ 1 , 1 , 2 , 2 , 3 , 3 ] Output : 3 Explanation : There are three different kinds of candies ( 1 , 2 and 3 ), and two candies for each kind . Optimal distribution : The sister has candies [ 1 , 2 , 3 ] and the brother has candies [ 1 , 2 , 3 ], too . The sister has three different kinds of candies . - Example 2: Input : candies = [ 1 , 1 , 2 , 3 ] Output : 2 Explanation : For example , the sister has candies [ 2 , 3 ] and the brother has candies [ 1 , 1 ]. The sister has two different kinds of candies , the brother has only one kind of candies . - Note: The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000]. Source link Most popular solution class Solution ( object ): def distributeCandies ( self , candies ): \"\"\" :type candies: List[int] :rtype: int \"\"\" return min ( len ( candies ) / 2 , len ( set ( candies ))) My solution Same Mark: 97% Additional","tags":"Python","title":"LeetCode - Distribute Candies"},{"url":"leetcode-hamming-distance.html","text":"Description The Hamming distance 1 between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. - Note: 0 â‰¤ x, y < 231. - Example: Input : x = 1 , y = 4 Output : 2 Explanation : 1 ( 0 0 0 1 ) 4 ( 0 1 0 0 ) â†‘ â†‘ The above arrows point to positions where the corresponding bits are different . Source link Most popular solution class Solution ( object ): def hammingDistance ( self , x , y ): \"\"\" :type x: int :type y: int :rtype: int \"\"\" return bin ( x &#94; y ) . count ( '1' ) My solution class Solution ( object ): def hammingDistance ( self , x , y ): \"\"\" :type x: int :type y: int :rtype: int \"\"\" bit = x &#94; y count = 0 while bit : if bit & 1 : count += 1 bit = bit >> 1 return count Mark: 42 ms Additional Python ä½è¿ç®— Description Mark Comment æŒ‰ä½ä¸: & | æŒ‰ä½æˆ–: | | | | | æŒ‰ä½å¼‚æˆ–: | &#94; | | æŒ‰ä½ç¿»è½¬: | ~ | +1 ä¹‹åä¹˜ä»¥ -1| | å·¦ç§»è¿ç®—ç¬¦ | << | X << N å°†ä¸€ä¸ªæ•°å­—Xå‘å·¦ç§»åŠ¨Nä½| | å³ç§»è¿ç®—ç¬¦ | >> | | åœ¨ä¿¡æ¯è®ºä¸­ï¼Œä¸¤ä¸ªç­‰é•¿å­—ç¬¦ä¸²ä¹‹é—´çš„ æ±‰æ˜è·ç¦» (Hamming distanceï¼‰æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²å¯¹åº”ä½ç½®çš„ä¸åŒå­—ç¬¦çš„ä¸ªæ•°ã€‚æ¢å¥è¯è¯´ï¼Œå®ƒå°±æ˜¯å°†ä¸€ä¸ªå­—ç¬¦ä¸²å˜æ¢æˆå¦å¤–ä¸€ä¸ªå­—ç¬¦ä¸²æ‰€éœ€è¦æ›¿æ¢çš„å­—ç¬¦ä¸ªæ•°ã€‚ æ±‰æ˜é‡é‡ æ˜¯å­—ç¬¦ä¸²ç›¸å¯¹äºåŒæ ·é•¿åº¦çš„é›¶å­—ç¬¦ä¸²çš„æ±‰æ˜è·ç¦»ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒæ˜¯å­—ç¬¦ä¸²ä¸­éé›¶çš„å…ƒç´ ä¸ªæ•°ï¼šå¯¹äºäºŒè¿›åˆ¶å­—ç¬¦ä¸²æ¥è¯´ï¼Œå°±æ˜¯1çš„ä¸ªæ•°ï¼Œæ‰€ä»¥11101çš„æ±‰æ˜é‡é‡æ˜¯4ã€‚ â†©","tags":"Python","title":"LeetCode - Hamming Distance"},{"url":"leetcode-two-sum.html","text":"Description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [ 2 , 7 , 11 , 15 ], target = 9 , Because nums [ 0 ] + nums [ 1 ] = 2 + 7 = 9 , return [ 0 , 1 ]. Subscribe to see which companies asked this question. Source page Most popular solution class Solution ( object ): def twoSum ( self , nums , target ): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" if len ( nums ) <= 1 : return False dict = {} for i in range ( len ( nums )): if nums [ i ] in dict : return [ dict [ nums [ i ]], i ] else : dict [ target - nums [ i ]] = i My solution class Solution ( object ): def twoSum ( self , nums , target ): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" length = len ( nums ) num_temp = sorted ( range ( length ), key = lambda k : nums [ k ]) #æ’åºå‰çš„æ•°ç»„åºå· nums . sort () i = 0 j = length - 1 while 1 : sumed = nums [ i ] + nums [ j ] if sumed > target : j -= 1 elif sumed < target : i += 1 else : return [ num_temp [ i ], num_temp [ j ]] Mark: 86% Additional","tags":"Python","title":"LeetCode - Two Sum"},{"url":"top-10-python-libraries-of-2016.html","text":"We try to avoid most established choices such as Django, Flask, etc. that are kind of standard nowadays. Also, some of these libraries date prior to 2016, but either they had an explosion in popularity this year or we think they are great enough to deserve the spot. Here we go! Last year, we did a recap with what we thought were the best Python libraries of 2015 , which was widely shared within the Python community (see post in r/Python ). A year has gone by, and again it is time to give due credit for the awesome work that has been done by the open source community this year. Again, we try to avoid most established choices such as Django, Flask, etc. that are kind of standard nowadays. Also, some of these libraries date prior to 2016, but either they had an explosion in popularity this year or we think they are great enough to deserve the spot. Here we go! 1. Zappa Since the release of AWS Lambda (and others that have followed ), all the rage has been about serverless architectures . These allow microservices to be deployed in the cloud, in a fully managed environment where one doesn't have to care about managing any server, but is assigned stateless, ephemeral computing containers that are fully managed by a provider. With this paradigm, events (such as a traffic spike) can trigger the execution of more of these containers and therefore give the possibility to handle \"infinite\" horizontal scaling. Zappa is the serverless framework for Python , although (at least for the moment) it only has support for AWS Lambda and AWS API Gateway. It makes building so-architectured apps very simple, freeing you from most of the tedious setup you would have to do through the AWS Console or API, and has all sort of commands to ease deployment and managing different environments. 2. Sanic + uvloop Who said Python couldn't be fast? Apart from competing for the best name of a software library ever, Sanic also competes for the fastest Python web framework ever, and appears to be the winner by a clear margin. It is a Flask-like Python 3.5+ web server that is designed for speed. Another library, uvloop , is an ultra fast drop-in replacement for asyncio 's event loop that uses libuv under the hood. Together, these two things make a great combination! According to the Sanic author's benchmark , uvloop could power this beast to handle more than 33k requests/s which is just insane (and faster than node.js ). Your code can benefit from the new async/await syntax so it will look neat too; besides we love the Flask-style API. Make sure to give Sanic a try, and if you are using asyncio , you can surely benefit from uvloop with very little change in your code! 3. asyncpg In line with recent developments for the asyncio framework, the folks from MagicStack bring us this efficient asynchronous (currently CPython 3.5 only) database interface library designed specifically for PostgreSQL. It has zero dependencies, meaning there is no need to have libpq installed. In contrast with psycopg2 (the most popular PostgreSQL adapter for Python) which exchanges data with the database server in text format, asyncpg implements PostgreSQL binary I/O protocol , which not only allows support for generic types but also comes with numerous performance benefits. The benchmarks are clear: asyncpg is on average, at least 3x faster than psycopg2 (or aiopg ), and faster than the node.js and Go implementations. 4. boto3 If you have your infrastructure on AWS or otherwise make use of their services (such as S3), you should be very happy that boto , the Python interface for AWS API, got a completely rewrite from the ground up. The great thing is that you don't need to migrate your app all at once: you can use boto3 and boto (2) at the same time ; for example using boto3 only for new parts of your application. The new implementation is much more consistent between different services, and since it uses a data-driven approach to generate classes at runtime from JSON description files, it will always get fast updates. No more lagging behind new Amazon API features, move to boto3 ! 5. TensorFlow Do we even need an introduction here? Since it was released by Google in November 2015, this library has gained a huge momentum and has become the #1 trendiest GitHub Python repository. In case you have been living under a rock for the past year, TensorFlow is a library for numerical computation using data flow graphs, which can run over GPU or CPU. We have quickly witnessed it become a trend in the Machine Learning community (especially Deep Learning, see our post on 10 main takeaways from MLconf ), not only growing its uses in research but also being widely used in production applications. If you are doing Deep Learning and want to use it through a higher level interface, you can try using it as a backend for Keras (which made it to last years post) or the newer TensorFlow-Slim . 6. gym + universe If you are into AI, you surely have heard about the OpenAI non-profit artificial intelligence research company (backed by Elon Musk et al.). The researchers have open sourced some Python code this year! Gym is a toolkit for developing and comparing reinforcement learning algorithms. It consists of an open-source library with a collection of test problems (environments) that can be used to test reinforcement learning algorithms, and a site and API that allows to compare the performance of trained algorithms (agents). Since it doesn't care about the implementation of the agent, you can build them with the computation library of your choice: bare numpy, TensorFlow, Theano, etc. We also have the recently released universe , a software platform for researching into general intelligence across games, websites and other applications. This fits perfectly with gym , since it allows any real-world application to be turned into a gym environment. Researchers hope that this limitless possibility will accelerate research into smarter agents that can solve general purpose tasks. 7. Bokeh You may be familiar with some of the libraries Python has to offer for data visualization; the most popular of which are matplotlib and seaborn . Bokeh, however, is created for interactive visualization , and targets modern web browsers for the presentation. This means Bokeh can create a plot which lets you_explore_ the data from a web browser. The great thing is that it integrates tightly with Jupyter Notebooks , so you can use it with your probably go-to tool for your research. There is also an optional server component, bokeh-server , with many powerful capabilities like server-side downsampling of large dataset (no more slow network tranfers/browser!), streaming data, transformations, etc. Make sure to check the gallery for examples of what you can create. They look awesome! 8. Blaze Sometimes, you want to run analytics over a dataset too big to fit your computer's RAM. If you cannot rely on numpy or Pandas, you usually turn to other tools like PostgreSQL, MongoDB, Hadoop, Spark, or many others. Depending on the use case, one or more of these tools can make sense, each with their own strengths and weaknesses. The problem? There is a big overhead here because you need to learn how each of these systems work and how to insert data in the proper form. Blaze provides a uniform interface that abstracts you away from several database technologies. At the core, the library provides a way to express computations . Blaze itself doesn't actually do any computation: it just knows how to instruct a specific backend who will be in charge of performing it. There is so much more to Blaze (thus the ecosystem), as libraries that have come out of its development. For example, Dask implements a drop-in replacement for NumPy array that can handle content larger than memory and leverage multiple cores, and also comes with dynamic task scheduling. Interesting stuff. 9. arrow There is a famous saying that there are only two hard problems in Computer Science: cache invalidation and naming things. I think the saying is clearly missing one thing: managing datetimes . If you have ever tried to do that in Python, you will know that the standard library has a gazillion modules and types: datetime , date , calendar , tzinfo , timedelta , relativedelta , pytz , etc. Worse, it is timezone naive by default. Arrow is \"datetime for humans\", offering a sensible approach to creating, manipulating, formatting and converting dates, times, and timestamps. It is a replacement for the datetime type that supports Python 2 or 3, and provides a much nicer interface as well as filling the gaps with new functionality (such as humanize ). Even if you don't really need arrow, using it can greatly reduce the boilerplate in your code. 10. hug Expose your internal API externally, drastically simplifying Python API development. Hug is a next-generation Python 3 (only) library that will provide you with the cleanest way to create HTTP REST APIs in Python. It is not a web framework per se (although that is a function it performs exceptionally well), but only focuses on exposing idiomatically correct and standard internal Python APIs externally. The idea is simple: you define logic and structure once, and you can expose your API through multiple means . Currently, it supports exposing REST API or command line interface. You can use type annotations that let hug not only generate documentation for your API but also provide with validation and clean error messages that will make your life (and your API user's) a lot easier. Hug is built on Falcon's high performance HTTP library, which means you can deploy this to production using any wsgi-compatible server such as gunicorn . Follow the discussion of this post on: Reddit Original source: https://tryolabs.com/blog/2016/12/20/top-10-pythonâ€¦","tags":"posts","title":"Top 10 Python libraries of 2016"}]}