<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Tower of Babel - Python,R</title><link href="https://motor-taxi-master-rider.github.io/" rel="alternate"></link><link href="https://motor-taxi-master-rider.github.io/feeds/pythonr.atom.xml" rel="self"></link><id>https://motor-taxi-master-rider.github.io/</id><updated>2017-08-15T00:00:00+08:00</updated><entry><title>LeetCode - Linked List Random Node</title><link href="https://motor-taxi-master-rider.github.io/leetcode-linked-list-random-node.html" rel="alternate"></link><published>2017-08-15T00:00:00+08:00</published><updated>2017-08-15T00:00:00+08:00</updated><author><name>Charlie Hu</name></author><id>tag:motor-taxi-master-rider.github.io,2017-08-15:/leetcode-linked-list-random-node.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;
&lt;p&gt;Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.&lt;/p&gt;
&lt;p&gt;Follow up:
What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Description&lt;/h3&gt;
&lt;p&gt;Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.&lt;/p&gt;
&lt;p&gt;Follow up:
What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// Init a singly linked list [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.
solution.getRandom();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://leetcode.com/problems/linked-list-random-node/description/"&gt;Source link&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Analytics&lt;/h3&gt;
&lt;p&gt;当数据流长度已知或不大的时候可以简单的解决这个问题：遍历链表之后得到长度n，以&lt;/p&gt;
&lt;div class="math"&gt;$$ {\frac{1}{n}} $$&lt;/div&gt;
&lt;p&gt;的概率选取元素。&lt;/p&gt;
&lt;p&gt;但当给出数据流的长度很大或者未知时，我们将无法做遍历链表得到长度的操作。此时因为数据流很大，为了追求效率，该数据流中数据只能访问一次。有没有这么一个随机选择算法，使得该数据流中的所有数据被选中的概率相等呢？&lt;/p&gt;
&lt;p&gt;这个无边界的问题确实很让人头疼啊，但幸运的是，这我们可以用为蓄水池抽样（Reservoir Sampling）的方法来解决该类问题。&lt;/p&gt;
&lt;h2&gt;蓄水池抽样介绍&lt;/h2&gt;
&lt;p&gt;蓄水池抽样是一种从一个包含&lt;code&gt;n&lt;/code&gt;个元素的列表&lt;code&gt;S&lt;/code&gt;中随机抽取&lt;code&gt;k&lt;/code&gt;个样本的随机算法，这里的&lt;code&gt;n&lt;/code&gt;是一个非常大或者未知的值。&lt;/p&gt;
&lt;p&gt;这个算法的基本思想就是先选中&lt;code&gt;1&lt;/code&gt;到&lt;code&gt;k&lt;/code&gt;个元素，作为被选中的元素。然后依次对第&lt;code&gt;k+1&lt;/code&gt;至第&lt;code&gt;n&lt;/code&gt;个元素做以下操作：
每个元素都有&lt;/p&gt;
&lt;div class="math"&gt;$$ {\frac{k}{i}} $$&lt;/div&gt;
&lt;p&gt;的概率被选中，然后以等概率&lt;/p&gt;
&lt;div class="math"&gt;$$ {\frac{1}{k}} $$&lt;/div&gt;
&lt;p&gt;替换掉被选中的元素。其中&lt;code&gt;i&lt;/code&gt;是元素的序号。&lt;/p&gt;
&lt;h2&gt;算法证明&lt;/h2&gt;
&lt;p&gt;算法的成立是用数学归纳法证明的:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;设每次都是以k/i的概率来选择。假设当前是i+1, 按照我们的规定，i+1这个元素被选中的概率是k/i+1，也即第 i+1 这个元素在蓄水池中出现的概率是k/i+1
此时考虑前i个元素，如果前i个元素出现在蓄水池中的概率都是k/i+1的话，说明我们的算法是没有问题的。

对这个问题可以用归纳法来证明：k &amp;lt; i &amp;lt;=N：

1.当i=k+1的时候，蓄水池的容量为k，第k+1个元素被选择的概率明显为k/(k+1), 此时前k个元素出现在蓄水池的概率为 k/(k+1), 很明显结论成立。
2.假设当 j=i 的时候结论成立，此时以 k/i 的概率来选择第i个元素，前i-1个元素出现在蓄水池的概率都为k/i。
证明当j=i+1的情况：
即需要证明当以 k/i+1 的概率来选择第i+1个元素的时候，此时任一前i个元素出现在蓄水池的概率都为k/(i+1).
前i个元素出现在蓄水池的概率有2部分组成, ①在第i+1次选择前得出现在蓄水池中，②得保证第i+1次选择的时候不被替换掉
①.由2知道在第i+1次选择前，任一前i个元素出现在蓄水池的概率都为k/i
②.考虑被替换的概率：
首先要被替换得第 i+1 个元素被选中(不然不用替换了)概率为 k/i+1，其次是因为随机替换的池子中k个元素中任意一个，所以不幸被替换的概率是 1/k，故
前i个元素(池中元素)中任一被替换的概率 = k/(i+1) * 1/k = 1/i+1
则(池中元素中)没有被替换的概率为: 1 - 1/(i+1) = i/i+1
综合① ②,通过乘法规则
得到前i个元素出现在蓄水池的概率为 k/i * i/(i+1) = k/i+1
故证明成立
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;伪代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Init&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;reservoir&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;  
        &lt;span class="k"&gt;for&lt;/span&gt;    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;  
            &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  
                 &lt;span class="n"&gt;SWAP&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;Mth&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;ith&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;  
       &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;加权分布式蓄水池抽样&lt;/h2&gt;
&lt;p&gt;有时候我们的蓄水池中的数据是有权重，算法希望数据被抽样选中的概率和该数据的权重成正比。2005年Pavlos S. Efraimidis和Paul G. Spirakis的论文&lt;a href="http://dl.acm.org/citation.cfm?id=1138834"&gt;Weighted random sampling with a reservoir&lt;/a&gt;提供了对于加权状态下这一问题的解决方案。他的解法既简单又优雅，基本思想和上面的分布式蓄水池抽样一致：对于每个数据计算一个0-1的值R，并求r的n次方根作为该数据的新的R值。这里的n就是该数据的权重。最终算法返回前k个R值最高的数据然后返回。根据计算规则，权重越大的数据计算所得的R值越接近1，所以越有可能被返回。&lt;/p&gt;
&lt;h3&gt;Best practice&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;python实现的普通蓄水池算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;python version&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;### Definition for singly-linked list.&lt;/span&gt;
&lt;span class="c1"&gt;### class ListNode(object):&lt;/span&gt;
&lt;span class="c1"&gt;###     def __init__(self, x):&lt;/span&gt;
&lt;span class="c1"&gt;###         self.val = x&lt;/span&gt;
&lt;span class="c1"&gt;###         self.next = None&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;random&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        @param head The linked list&amp;#39;s head.&lt;/span&gt;
&lt;span class="sd"&gt;        Note that the head is guaranteed to be not null, so it contains at least one node.&lt;/span&gt;
&lt;span class="sd"&gt;        :type head: ListNode&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="c1"&gt;#随机选出的数量&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;getRandom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        Returns a random node&amp;#39;s value.&lt;/span&gt;
&lt;span class="sd"&gt;        :rtype: int&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="c1"&gt;#为linklist数量计数，视为i&lt;/span&gt;
            &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;randint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c1"&gt;#以k/i的概率来选择&lt;/span&gt;
                &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;  &lt;span class="c1"&gt;#这里没有用交换操作，会有数据丢失&lt;/span&gt;
            &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;


&lt;span class="c1"&gt;### Your Solution object will be instantiated and called as such:&lt;/span&gt;
&lt;span class="c1"&gt;### obj = Solution(head)&lt;/span&gt;
&lt;span class="c1"&gt;### param_1 = obj.getRandom()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Mark:&lt;/strong&gt; 362 ms&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;这是维基百科上关于加权蓄水池算法的R语言实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In many applications sampling is required to be according to the weights that are assigned to each items available in set. For example, it might be required to sample queries in a search engine with weight as number of times they were performed so that the sample can be analyzed for overall impact on user experience. There are two ways to interpret weights assigned to each item in the set:
1. Let the weight of each item be &lt;/p&gt;
&lt;div class="math"&gt;$$ {\displaystyle w_{i}} w_{i} $$&lt;/div&gt;
&lt;p&gt; and sum of all weights be W. We can convert weight to probability of item getting selected in sample as &lt;/p&gt;
&lt;div class="math"&gt;$$ {\displaystyle P_{i}=w_{i}/W} $$&lt;/div&gt;
&lt;p&gt;.
2. Let the weight of two items i and j be &lt;/p&gt;
&lt;div class="math"&gt;$$ {\displaystyle w_{i}} w_{i} and {\displaystyle w_{j}} w_{j} $$&lt;/div&gt;
&lt;p&gt;. Let the probability of item i getting selected in sample be &lt;/p&gt;
&lt;div class="math"&gt;$$ {\displaystyle p_{i}} p_{i }$$&lt;/div&gt;
&lt;p&gt;, then we give&lt;/p&gt;
&lt;div class="math"&gt;$$ {\displaystyle p_{j}=\min(1,p_{i}{\frac {w_{j}}{w_{i}}})} {\displaystyle p_{j}=\min(1,p_{i}{\frac {w_{j}}{w_{i}}})} $$&lt;/div&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Algorithm A-Res&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;
  S is a stream of items to &lt;span class="kp"&gt;sample&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; R will contain the result
  S.Current returns current item &lt;span class="kr"&gt;in&lt;/span&gt; stream
  S.Weight  returns weight of current item &lt;span class="kr"&gt;in&lt;/span&gt; stream
  S.Next advances stream to &lt;span class="kr"&gt;next&lt;/span&gt; position
  The power operator is represented by &lt;span class="o"&gt;^&lt;/span&gt;
  &lt;span class="kp"&gt;min&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;priority&lt;span class="o"&gt;-&lt;/span&gt;queue supports&lt;span class="o"&gt;:&lt;/span&gt;
    Count &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; number of items &lt;span class="kr"&gt;in&lt;/span&gt; priority queue
    Minimum&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; returns minimum key value of all items
    Extract&lt;span class="o"&gt;-&lt;/span&gt;Min&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; Remove the item with minimum key
    Insert&lt;span class="p"&gt;(&lt;/span&gt;key&lt;span class="p"&gt;,&lt;/span&gt; Item&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; Adds item with specified key
 &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
ReservoirSample&lt;span class="p"&gt;(&lt;/span&gt;S&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1..&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; R&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1..&lt;/span&gt;k&lt;span class="p"&gt;])&lt;/span&gt;
  H &lt;span class="o"&gt;=&lt;/span&gt; new &lt;span class="kp"&gt;min&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;priority&lt;span class="o"&gt;-&lt;/span&gt;queue
  &lt;span class="kr"&gt;while&lt;/span&gt; S has data
    r &lt;span class="o"&gt;=&lt;/span&gt; Random&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;S.Weight&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt; important&lt;span class="o"&gt;:&lt;/span&gt; inclusive &lt;span class="kp"&gt;range&lt;/span&gt;
    &lt;span class="kr"&gt;if&lt;/span&gt; H.Count &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; k
      H.Insert&lt;span class="p"&gt;(&lt;/span&gt;r&lt;span class="p"&gt;,&lt;/span&gt; S.Current&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kp"&gt;else&lt;/span&gt;
      &lt;span class="kr"&gt;if&lt;/span&gt; H.Minimum &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; r
        H.Extract&lt;span class="o"&gt;-&lt;/span&gt;Min&lt;span class="p"&gt;()&lt;/span&gt;
        H.Insert&lt;span class="p"&gt;(&lt;/span&gt;r&lt;span class="p"&gt;,&lt;/span&gt; S.Current&lt;span class="p"&gt;)&lt;/span&gt;
    S.Next
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Additional&lt;/h3&gt;
&lt;p&gt;参考文献：
1. &lt;a href="https://en.wikipedia.org/wiki/Reservoir_sampling"&gt;Reservoir sampling&lt;/a&gt;
2. &lt;a href="http://www.cnblogs.com/hrlnw/archive/2012/11/27/2777337.html"&gt;蓄水池抽样及实现&lt;/a&gt;
3. &lt;a href="http://blog.jobbole.com/42550/"&gt;数据工程师必知算法：蓄水池抽样&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="LeetCode"></category><category term="Reservoir_sampling"></category></entry></feed>