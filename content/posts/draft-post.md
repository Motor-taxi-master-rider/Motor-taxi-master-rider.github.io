# 掌握Python并发让你更快享用午餐

> 一个关于线程、异步、多进程和云函数的午餐故事。
>
> 原作者：[Brendan Maginnis](https://sourcery.ai/blog/concurrency/)

## 简介

我将给你们讲一个故事来解释Python中不同的并发和并行选项。

在这个故事中，我们将看到为什么单个人的多任务处理像并发，而多个人执行自己的任务就像并行处理。 我们将在一些知名餐厅的午餐时间观察这些场景在实际中是否可以快速而有效地为客户提供服务。之后，我将使用Python模拟各类餐厅，最后比较不同的并发方案，并说明它们分别适用与何种场景。

在接下来的内容中，我会解释如下几点：

* 并发和并行之间有什么区别？
* 比较不同的并发方案，包括线程，异步，多进程和云函数
* 每种并发方案的优缺点
* 如何使用简单的流程图找到适合场景的并发方案



## 什么是并发？什么是并行？

让我们从它们的定义说起：

>如果一个系统可以同时支持两个或多个正在进行的操作，则称该系统是并发的。
>
>如果一个系统可以支持同时执行的两个或多个动作，则称该系统为并行系统。
>
>这两个概念之间的关键区别是“进行中”这一定义。
>
>——《并发的艺术》

现在让我们直接进入故事环节。

正值午餐时间，你转过一条从未见过的街道。摆在你面前的有两种就餐选择：一个叫**Concurrent Burgers**的市场摊位和一个叫**Parallel Salads**的商店。

两家店看起来都很美味，但排队的人又很多，所以你想知道哪家能先为你服务。

**Concurrent Burgers**由一名中年女士经营，工作时开心大笑，手臂上有着Python的蟒蛇纹身。她正在执行以下任务：

* 拿取一个订单
* 翻转汉堡肉饼
* 将沙拉、肉饼和调味料加入，完成订单

她在任务之间无缝切换。首先，她检查烤架上的肉饼，然后取出煮熟的肉饼；之后，她取出一个订单；在之后如果有肉饼，她就可以完成一个多汁的汉堡，并结束订单。

**Parallel Salads**则配备了许多人手，在工作中他们时刻微笑并礼貌地和顾客交谈。他们每个人都分别为一名顾客做沙拉。他们取订单，将所有成分添加到干净的碗中，优雅而干练，将它们充分混合，之后将沙拉放入给顾客的容器中，把之前的碗递给另一名员工。那名员工与此同时负责洗碗的工作。

两家餐厅之间的主要区别在于工人的数量以及任务的执行方式：

* **Concurrent Burgers**同时（但不是并行的）有多个正在进行的任务，只有一个工人在所有的任务之间切换。
* **Parallel Salads**并行执行多项任务，多个工人同每人执行一项任务。

你会发现两家餐厅都能以相同的速度为顾客提供服务。**Concurrent Burgers**的女老板在同一时间制作多个汉堡，整体速度受限于她的小烤架烤熟肉饼的速度。**Parallel Salads**雇用了多名员工，每人分别制作一份沙拉，整体速度被混合每份沙拉的时间所限制。

你意识到**Concurrent Burgers**处理的是**I/O密集型**任务而**Parallel Salads**则处理的是**CPU密集型**任务。

* **I/O密集型**意味着程序主要受到I/O子系统的限制，从计算机的角度来讲，I/O意味着从磁盘读取或执行网络请求之类的操作。 在**Concurrent Burgers**中，烤肉饼就是一种I/O操作
* **CPU密集型**意味着程序主要受到CPU运算速度的限制。如果CPU运行速度更快，则程序运行速度也会得到极大提升。在**Parallel Salads**中，CPU运行速度对应了制作沙拉的人的速度。

面对这两个选择，你绞尽脑汁想了五分钟依然不知所措，无法做出决定，然后有个能拿主意的朋友打断了你，邀请你去排它们中某家的队。

请注意：**Concurrent Burgers**因为“同时进行两个或多个操作”既是并发的也是并行的。并行处理是并发处理的子集。

这两家店为并发任务和并行任务之间的区别提供了直觉感受。现在，我们将研究如何用Python代码实现这两者的模式。



### 我们有哪些选择？

Python中有两种选项用于并发：

* **threading**
* **asyncio**

有内置的库用于并行：

* **multiprocessing**

如果你在云服务中运行python程序，还有另一个用于并行的选项：

* **cloud functions**



## 并发实战

让我们看一下使用**threading**和**asyncio**的两种**Concurrent Burgers**的可能实现。在这两种情况下，只有一个工人接单，烤肉饼，做汉堡。

对于**threading**和**asyncio**，只有一个处理器在执行任务，因此它在需要处理的不同任务之间进行切换。线程和异步之间的区别是如何决定任务该被切换。

* 对于**threading**库，操作系统掌握了不同线程的信息，可以在任何时候中断它们并切换成其他任务。程序本身对此没有控制权。这种模式被称为[抢先式多任务处理](https://en.wikipedia.org/wiki/Preemption_%28computing%29#Preemptive_multitasking)，因为操作系统可以抢占你的线程来进行线程间的切换在大多数编程语言中，线程可以在多核上并行运行，然而在Python中，一次只能执行一个线程。
* 借助**asyncio**，程序本身可以决定何时在任务之间进行切换 每个任务在准备好切换时都可以选择放弃控制，从而与其他任务协作。因此，这被称为[协作多任务处理](https://en.wikipedia.org/wiki/Cooperative_multitasking)，因为每个任务必须在无法继续进行时主动放弃控制权来相互协作。